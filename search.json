[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Curso: Geoanálisis",
    "section": "",
    "text": "Antecedentes\nEste libro corresponde al material de estudio del curso de Geoanálisis del Diplomado en Ciencia de Datos para Políticas Públicas 2023, dictado por Escuela de Gobierno de la Universidad Adolfo Ibáñez."
  },
  {
    "objectID": "index.html#introducción",
    "href": "index.html#introducción",
    "title": "Curso: Geoanálisis",
    "section": "Introducción",
    "text": "Introducción\nEste curso se enfoca en entregar a los alumnos conocimientos teóricos y herramientas técnicas para realizar análisis espacial de variables territoriales en diferentes campos de aplicación, con énfasis en afrontar desafíos relacionado a las políticas públicas, haciendo uso de lenguaje de programación R Project, para uso de metodologías de alto nivel y de forma automatizada."
  },
  {
    "objectID": "index.html#objetivos",
    "href": "index.html#objetivos",
    "title": "Curso: Geoanálisis",
    "section": "Objetivos",
    "text": "Objetivos\nEl objetivo general es proporcionar a los estudiantes los fundamentos, técnicas y aspectos básicos para analizar, modelar y representar información espacial, para apoyar la toma de decisiones con evidencia territorial robusta.\nLos objetivos específicos son:\n\nConocer los conceptos básicos del geoanálisis.\nManipular datos espaciales en R.\nConocer técnicas de inferencia, autocorrelación y regresión espacial.\nAplicar las técnicas a problemas de interés público."
  },
  {
    "objectID": "index.html#modulos",
    "href": "index.html#modulos",
    "title": "Curso: Geoanálisis",
    "section": "Modulos",
    "text": "Modulos\n\n\n\nModulos\n\n\n\nIntroducción a la Estadística Espacial y a Datos Espaciales\nManejo y Representación de datos vectoriales, construcción de indicadores\nManejo y Representación de datos raster, construcción de indicadores\nInferencia Espacial: Interpolación y mapas de calor\nRelaciones de Vecindad y autocorrelación espacial\nModelos de Regresión Espacial"
  },
  {
    "objectID": "index.html#docentes",
    "href": "index.html#docentes",
    "title": "Curso: Geoanálisis",
    "section": "Docentes",
    "text": "Docentes\n\nProfesor:\n\nDenis Berroeta González (denis.berroeta@uai.cl)\n\n\n\nCoordinador de Investigación Centro de Inteligencia Territorial UAI\nMagister en Inteligencia Artificial FIC-UAI\nDoctorado Master of Data Science FIC-UAI (cursando)\nIngeniero en Prevención en Riesgos\n\n\nAyudante:\n\nJaime Constanzo (jvconstanzo@gmail.com)\n\n\n\nCientista Político PUC\nBusiness intelligence analyst (UNICEF)\nDiplomado de Big data para políticas públicas"
  },
  {
    "objectID": "intro_estad_esp.html#objetivos",
    "href": "intro_estad_esp.html#objetivos",
    "title": "1  Estadística Espacial",
    "section": "1.1 Objetivos",
    "text": "1.1 Objetivos\n\n\n\nObjetivos\n\n\n\nConocer teóricos fundamentales de la estadística espacial."
  },
  {
    "objectID": "intro_estad_esp.html#origen-de-la-estadística",
    "href": "intro_estad_esp.html#origen-de-la-estadística",
    "title": "1  Estadística Espacial",
    "section": "1.2 Origen de la Estadística",
    "text": "1.2 Origen de la Estadística\nEstadística deriva del italiano statista (hombre de Estado) y se desarrolla desde la antigüedad para facilitar la gestión tributaria y estimar la capacidad bélica de un reino. Ej: censos egipcios desde el 3050 a.C.\nDurante la expansión de los imperios coloniales (siglos XVI - XIX) se desarrolla la estadística en estrecha relación con la cartografía, principalmente para la administración y dominio de territorios.\n\n\n\nOrigen de la Estadística"
  },
  {
    "objectID": "intro_estad_esp.html#definición-general",
    "href": "intro_estad_esp.html#definición-general",
    "title": "1  Estadística Espacial",
    "section": "1.3 Definición General",
    "text": "1.3 Definición General\nLa estadística es una herramienta fundamental en la ciencia de datos que nos permite comprender y analizar datos para obtener información significativa. En términos simples, es como un lenguaje que utilizamos para describir, resumir y tomar decisiones basadas en la información que los datos nos proporcionan. Al aplicar métodos estadísticos, podemos identificar patrones, tendencias y relaciones en los datos, lo que es esencial tanto para la investigación académica como para la toma de decisiones en el mundo real."
  },
  {
    "objectID": "intro_estad_esp.html#estadística-vs-estadística-espacial",
    "href": "intro_estad_esp.html#estadística-vs-estadística-espacial",
    "title": "1  Estadística Espacial",
    "section": "1.4 Estadística vs Estadística Espacial",
    "text": "1.4 Estadística vs Estadística Espacial\nLa estadística en general es una disciplina amplia que se aplica a diversos tipos de datos y problemas, utilizando métodos estadísticos convencionales. La estadística espacial, por otro lado, se enfoca en datos con ubicaciones geográficas explícitas y se especializa en el análisis de la dependencia espacial y la modelización de patrones espaciales.\nEstadística:\n\nAnálisis de la estructura de datos representativos de una población (en áreas arbitrarias)\nSe basa en matemáticas relativamente complejas\n\n Geoestadística\n\nAnálisis de relaciones de dependencia espacial entre datos georreferenciados y modelamiento de datos espacilizados.\nComplejidad de cálculo que hacía inviable su uso masivo\n\n\n\n\nDependencia espacial en geoestadística"
  },
  {
    "objectID": "intro_estad_esp.html#condideraciones-generales",
    "href": "intro_estad_esp.html#condideraciones-generales",
    "title": "1  Estadística Espacial",
    "section": "1.5 Condideraciones generales",
    "text": "1.5 Condideraciones generales\nLa inferencia estadística convencional se basa en dos supuestos fundamentales\n\nLos valores de una variable se distribuyen de forma aleatoria\nLos valores de una variable son independientes unos de otros\n\nPero ninguno de estos dos supuestos se cumple al utilizar datos espaciales, ya que:\n\nLos fenómenos más próximos en el espacio están más estrechamente relacionados entre sí. Ley de Tobler (1970)\nLa historia, el espacio y la sociedad se co-producen, por lo que el espacio tiene un rol activo en la reproducción y acumulación de fenómenos sociales. Lefebvre (1974)\n\nPara resolver esta limitación existen dos enfoques principales\n\nLa econometría espacial, que trata el efecto espacial como un error y lo elimina para generar estimaciones sin sesgo\nLa geoestadística, que identifica y cuantifica el efecto que el espacio genera en la estructura de la información"
  },
  {
    "objectID": "intro_estad_esp.html#ejemplos-de-correlación-espacial",
    "href": "intro_estad_esp.html#ejemplos-de-correlación-espacial",
    "title": "1  Estadística Espacial",
    "section": "1.6 Ejemplos de Correlación Espacial",
    "text": "1.6 Ejemplos de Correlación Espacial\n\n1.6.1 Autoproducción: Tráfico de Drogas\n\n\n\nAutoproducción Espacial en tráfico de Drogas\n\n\n\n\n1.6.2 Co-producción: Mercado inmobiliario local\n\n\n\nCo-producción Espacial en Mercado inmobiliario local\n\n\n\n\n1.6.3 Segregación y delincuencia\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nSegregación y delincuencia\n\n\n\n\n1.6.4 Valores de Vivienda\n\n\n\nValores de Vivienda"
  },
  {
    "objectID": "intro_estad_esp.html#inconsistencia-estadística-de-datos-espaciales-agregados-maup",
    "href": "intro_estad_esp.html#inconsistencia-estadística-de-datos-espaciales-agregados-maup",
    "title": "1  Estadística Espacial",
    "section": "1.7 Inconsistencia estadística de datos espaciales agregados: MAUP",
    "text": "1.7 Inconsistencia estadística de datos espaciales agregados: MAUP\nModifiable Areal Unit Problem: inconsistencia de indicadores estadísticos al modificar los perímetros de agregación (Gehlke & Biehl 1934, Openshaw & Taylor 1979)\n\n\n\nModifiable Areal Unit Problem\n\n\nEn general, es recomendable trabajar con datos a la menor escala posible, o agregarlos en zonas homogéneas\n\n\n\n\nLefebvre, Henri. 1974. “La Production de lespace.” L Homme Et La Société 31 (1): 15–32. https://doi.org/10.3406/homso.1974.1855.\n\n\nTobler, W. R. 1970. “A Computer Movie Simulating Urban Growth in the Detroit Region.” Economic Geography 46 (June): 234. https://doi.org/10.2307/143141."
  },
  {
    "objectID": "datos_espaciales.html#objetivos-del-módulo",
    "href": "datos_espaciales.html#objetivos-del-módulo",
    "title": "2  Datos Espaciales",
    "section": "2.1 Objetivos del Módulo",
    "text": "2.1 Objetivos del Módulo\n\n\n\nObjetivos\n\n\nLa presente Sesión tiene como objetivo principal introducir conceptos generales y manipulación básica de datos de tipo vectorial (punto, lineas, polígonos) y Raster, ambos con casos prácticos."
  },
  {
    "objectID": "datos_espaciales.html#definición-general-de-datos-espaciales",
    "href": "datos_espaciales.html#definición-general-de-datos-espaciales",
    "title": "2  Datos Espaciales",
    "section": "2.2 Definición General de Datos Espaciales",
    "text": "2.2 Definición General de Datos Espaciales\nLa representación de un territorio requiere datos geográficos compuestos por información espacial (geometrías asociadas a una ubicación real en el mundo) e información de atributos (características y variables asociadas a estas geometrías). Los tipos de datos espaciales principalmente los vectores y raster.\n\n\n\nCapas de datos espaciales"
  },
  {
    "objectID": "datos_espaciales.html#datos-vectoriales",
    "href": "datos_espaciales.html#datos-vectoriales",
    "title": "2  Datos Espaciales",
    "section": "2.3 Datos Vectoriales",
    "text": "2.3 Datos Vectoriales\n\nDatos Vectoriales\n\nRepresentación mediante coordenadas que se pueden unir espacialmente o no. Corresponde a 3 tipos de geometrías: puntos, líneas y polígonos.\n\n\n\nFuente: https://r-spatial.github.io/sf/articles/sf1.html\n\nPuntos\n\nTiene un par de coordenadas “x” e “y”. Es utilizado para información de tipo puntual, como por ejemplo equipamiento urbano, postes, árboles, entre otros.\n\n\n\n\n\nObjeto vectorial tipo punto\n\n\nCargar librerías\n\n# install.packages(\"sf\") \nlibrary(sf) # manipulación de datos vectoriales\nlibrary(mapview) # visualización de mapas dinámicos\nlibrary(ggplot2) # gráficos\nlibrary(RColorBrewer) #paleta de colores\n\n\n2.3.1 Lectura de archivos tipo puntos\n\nsii_LC &lt;- st_read(\"data/sii/sii_urbe_LC.shp\")\n\nReading layer `sii_urbe_LC' from data source \n  `/Users/denisberroeta/Library/CloudStorage/OneDrive-UniversidadAdolfoIbanez/Goblab/BDPP_Geoanalisis/geoanalisis_book/data/sii/sii_urbe_LC.shp' \n  using driver `ESRI Shapefile'\nSimple feature collection with 2310 features and 11 fields\nGeometry type: POINT\nDimension:     XY\nBounding box:  xmin: -70.60645 ymin: -33.44471 xmax: -70.47083 ymax: -33.36548\nGeodetic CRS:  GCS_unknown\n\n\n\n\n2.3.2 Visualización de los puntos\n\n# Visualización ggplot y sf\nggplot() +\n  geom_sf(data = sii_LC, col = \"orange\", alpha=0.8,  size= 0.5)+\n  ggtitle(\"Datos del SII en Las Condes\" ) +\n  theme_bw() +\n  theme(legend.position=\"none\")+\n  theme(panel.grid.major = element_line(colour = \"gray80\"), \n        panel.grid.minor = element_line(colour = \"gray80\"))\n\n\n\n# mapview(sii_LC, zcol = \"atractor\", cex =2)\n\n\nLíneas\n\nTiene tantas coordenadas como vértices. La información que representa es de tipo lineal, como por ejemplo calles, ríos, redes energéticas, entre otros. Existen las líneas cerradas, las cuales se pueden entender como el perímetro de una superficie (sin relleno).\n\n\n\n\n\nObjeto vectorial tipo Línea\n\n\n\n\n2.3.3 Lectura de líneas\n\nlas_condes_red &lt;- readRDS(\"data/redes/RED_LAS_CONDES.rds\") \n# las_condes_red\n\n\n\n2.3.4 visualización Líneas\n\nggplot() +\n  geom_sf(data = las_condes_red, col = \"gray70\", alpha=0.8,  size= 0.5)+\n  ggtitle(\"Red víal de la comuna Las Condes\" ) +\n  theme_bw() +\n  theme(legend.position=\"none\")+\n  theme(panel.grid.major = element_line(colour = \"gray80\"), \n        panel.grid.minor = element_line(colour = \"gray80\"))\n\n\n\n# mapview(las_condes_red)\n\n\nPolígonos\n\nTiene tantas coordenadas como vértices. La información que representa es de tipo área, como por ejemplo división política administrativa, manzanas, construcciones, entre otras.\n\n\n\n\n\nObjeto vectorial tipo polígono\n\n\n\n\n2.3.5 Lectura de polígonos\n\nlas_condes_mz &lt;- st_read(\"data/shape/icv_las_condes.shp\", quiet=T) \n# las_condes_ptos\n\n\n\n2.3.6 Visualización polígonos\n\nggplot() +\n  geom_sf(data = las_condes_mz, aes(fill = veg_cob), color =\"gray80\", \n          alpha=0.8,  size= 0.1)+\n  scale_fill_distiller(palette=\"Greens\", direction = 1)+\n  ggtitle(\"Cobertura Vegetal de la comuna Las Condes\" ) +\n  theme_bw() +\n  theme(panel.grid.major = element_line(colour = \"gray80\"), \n        panel.grid.minor = element_line(colour = \"gray80\"))\n\n\n\n# mapview(las_condes_mz, zcol = \"veg_cob\")\n\nTabla General de tipo de Datos Vectoriales\n\n\n\n\n\n\n\ntype\ndescription\n\n\n\n\nPOINT\nzero-dimensional geometry containing a single point\n\n\nLINESTRING\nsequence of points connected by straight, non-self intersecting line pieces; one-dimensional geometry\n\n\nPOLYGON\ngeometry with a positive area (two-dimensional); sequence of points form a closed, non-self intersecting ring; the first ring denotes the exterior ring, zero or more subsequent rings denote holes in this exterior ring\n\n\nMULTIPOINT\nset of points; a MULTIPOINT is simple if no two Points in the MULTIPOINT are equal\n\n\nMULTILINESTRING\nset of linestrings\n\n\nMULTIPOLYGON\nset of polygons\n\n\nGEOMETRYCOLLECTION\nset of geometries of any type except GEOMETRYCOLLECTION\n\n\n\n\n\n\nCapas de datos tipos raster y vectores"
  },
  {
    "objectID": "datos_espaciales.html#datos-raster",
    "href": "datos_espaciales.html#datos-raster",
    "title": "2  Datos Espaciales",
    "section": "2.4 Datos Raster",
    "text": "2.4 Datos Raster\n\nRaster\n\nRepresentación del espacio mediante una matriz de celdas organizada en filas y columnas, donde cada celda tiene un valor que representa información.\n\n\n\n\n\nRepresentación Raster\n\n\n\n\n\nResolución Raster\n\n\nPara ejemplificar el uso y ver características de Raster vamos a utilizar una imágenes satelital del Satelite Landsat 8.\n\n\n\nImágenes Satelitales\n\n\nEste tipos de imágenes satelitales generalmente contiene una series de de bandas que corresponden a capas de información tipos raster conformando una especie de brick de raster.\n\n\n\nConfiguración de Bandas\n\n\nPara este ejemplo de visualización necesitamos conocer las bandas satelitales que componen nuestra imagen satelital.\n\n\n\nBandas de Landsat 8\n\n\n\n2.4.1 lectura de imagen Raster.\n\nlibrary(raster)\nlas_condes_raster &lt;- brick(\"data/raster/OLI_LC.tif\")\nnames(las_condes_raster) &lt;- c(\"aerosol\", \"blue\", \"green\", \"red\" , \"nir\", \"swir1\", \"swir2\", \"tirs1\")\nlas_condes_raster\n\nclass      : RasterBrick \ndimensions : 449, 562, 252338, 8  (nrow, ncol, ncell, nlayers)\nresolution : 30, 30  (x, y)\nextent     : 350505, 367365, 6293905, 6307375  (xmin, xmax, ymin, ymax)\ncrs        : +proj=utm +zone=19 +south +datum=WGS84 +units=m +no_defs \nsource     : OLI_LC.tif \nnames      : aerosol,  blue, green,   red,   nir, swir1, swir2, tirs1 \nmin values :    8465,  7604,  6500,  5924,  5520,  5191,  5197,  5002 \nmax values :   19119, 20517, 21248, 23237, 29344, 30012, 31166,  5512 \n\n\n\n\n2.4.2 Visualización Raster\n\n# Visualización de imagen recortada de Las Condes en Color Natural\nplotRGB(las_condes_raster, r = 4, g = 3, b = 2, stretch = \"lin\")\n\n\n\n# viewRGB(las_condes_raster, r = 4, g = 3, b = 2)"
  },
  {
    "objectID": "datos_espaciales.html#sistema-de-referencias-de-coordenadas",
    "href": "datos_espaciales.html#sistema-de-referencias-de-coordenadas",
    "title": "2  Datos Espaciales",
    "section": "2.5 Sistema de Referencias de Coordenadas",
    "text": "2.5 Sistema de Referencias de Coordenadas\n\n\n\nSistema de Referencias de Coordenadas\n\n\nLos sistemas de coordenadas forman la base de cálculo para describir la posición de un punto a partir de mediciones geodésicas: distancias, proporciones de distancias (sin escala) y ángulos. Las coordenadas nunca pueden medirse, solamente se calculan con referencia un sistema de coordenadas bien definido. Los tipos de sistemas de coordenadas principales que existen son:\n\nCoordenadas elipsoidales\n\nson la representación de las coordenadas sobre la superficie de un elipsoide determinado, se representan por [φ, λ, h] siendo respectivamente, la latitud, longitud y altura elipsoidal.\n\n\n\n\n\nCoordenadas Geodésicas. Fuente: (Drewes & Sánchez, 2011)\n\n\n\nCoordenadas proyectadas o cartográficas\n\nSegún la proyección empleada las coordenadas elipsoidales pueden representarse en un plano, en el caso de Chile continental, se emplea la proyección Universal Transversal de Mercator (UTM), huso 19 y huso 18.\n\n\n\n\n\nproyección Universal Transversal Mercator (UTM) Fuente: (Drewes & Sánchez, 2011)\n\n\nPara hacer reproyecciones en R, se le tiene que asignar el Sistema de Referencia de Coordenadas de dos formas, uno como cadena de texto (\"+proj=longlat +datum=WGS84 +no_defs\") o como número que corresponde a EPSG (EPSG es el acrónimo de European Petroleum Survey Group) que representan sistema de referencia de coordenadas también.\nPara el caso de Chile usamos dos sistemas de referencias de coordenadas:\n\nCoordenadas elipsoidales (geodésicas):\n\n4326 o \"+proj=longlat +datum=WGS84 +no_defs\"\n\nCoordenadas proyectadas (métricas):\n\n32719 o \"+proj=utm +zone=19 +south +datum=WGS84 +units=m +no_defs\"\n\n\n\n2.5.1 Reproyectar Vectores\n\nLC_mz_32719 &lt;- las_condes_mz %&gt;% st_transform(32719)\nst_crs(LC_mz_32719)\n\nCoordinate Reference System:\n  User input: EPSG:32719 \n  wkt:\nPROJCRS[\"WGS 84 / UTM zone 19S\",\n    BASEGEOGCRS[\"WGS 84\",\n        ENSEMBLE[\"World Geodetic System 1984 ensemble\",\n            MEMBER[\"World Geodetic System 1984 (Transit)\"],\n            MEMBER[\"World Geodetic System 1984 (G730)\"],\n            MEMBER[\"World Geodetic System 1984 (G873)\"],\n            MEMBER[\"World Geodetic System 1984 (G1150)\"],\n            MEMBER[\"World Geodetic System 1984 (G1674)\"],\n            MEMBER[\"World Geodetic System 1984 (G1762)\"],\n            MEMBER[\"World Geodetic System 1984 (G2139)\"],\n            ELLIPSOID[\"WGS 84\",6378137,298.257223563,\n                LENGTHUNIT[\"metre\",1]],\n            ENSEMBLEACCURACY[2.0]],\n        PRIMEM[\"Greenwich\",0,\n            ANGLEUNIT[\"degree\",0.0174532925199433]],\n        ID[\"EPSG\",4326]],\n    CONVERSION[\"UTM zone 19S\",\n        METHOD[\"Transverse Mercator\",\n            ID[\"EPSG\",9807]],\n        PARAMETER[\"Latitude of natural origin\",0,\n            ANGLEUNIT[\"degree\",0.0174532925199433],\n            ID[\"EPSG\",8801]],\n        PARAMETER[\"Longitude of natural origin\",-69,\n            ANGLEUNIT[\"degree\",0.0174532925199433],\n            ID[\"EPSG\",8802]],\n        PARAMETER[\"Scale factor at natural origin\",0.9996,\n            SCALEUNIT[\"unity\",1],\n            ID[\"EPSG\",8805]],\n        PARAMETER[\"False easting\",500000,\n            LENGTHUNIT[\"metre\",1],\n            ID[\"EPSG\",8806]],\n        PARAMETER[\"False northing\",10000000,\n            LENGTHUNIT[\"metre\",1],\n            ID[\"EPSG\",8807]]],\n    CS[Cartesian,2],\n        AXIS[\"(E)\",east,\n            ORDER[1],\n            LENGTHUNIT[\"metre\",1]],\n        AXIS[\"(N)\",north,\n            ORDER[2],\n            LENGTHUNIT[\"metre\",1]],\n    USAGE[\n        SCOPE[\"Engineering survey, topographic mapping.\"],\n        AREA[\"Between 72°W and 66°W, southern hemisphere between 80°S and equator, onshore and offshore. Argentina. Bolivia. Brazil. Chile. Colombia. Peru.\"],\n        BBOX[-80,-72,0,-66]],\n    ID[\"EPSG\",32719]]\n\n\n\n\n2.5.2 Reproyectar Raster\n\n# las_condes_raster\ncrs_latlon &lt;- \"+proj=longlat +datum=WGS84 +no_defs\"# geográficas o elipsoidales\ncrs_utm &lt;- \"+proj=utm +zone=19 +south +datum=WGS84 +units=m +no_defs\" # UTM o cartográficas\nlas_condes_raster2 &lt;- projectRaster(from= las_condes_raster,                                             crs = crs_latlon)\nlas_condes_raster2\n\nclass      : RasterBrick \ndimensions : 470, 578, 271660, 8  (nrow, ncol, ncell, nlayers)\nresolution : 0.000323, 0.00027  (x, y)\nextent     : -70.61069, -70.424, -33.48775, -33.36085  (xmin, xmax, ymin, ymax)\ncrs        : +proj=longlat +datum=WGS84 +no_defs \nsource     : memory\nnames      :  aerosol,     blue,    green,      red,      nir,    swir1,    swir2,    tirs1 \nmin values : 8592.067, 7778.388, 6806.291, 6280.802, 5729.628, 5316.893, 5303.627, 5005.409 \nmax values : 18590.84, 19485.05, 20596.61, 22406.07, 28732.09, 26707.17, 26787.15,  5495.00"
  },
  {
    "objectID": "datos_espaciales.html#actividades-prácticas",
    "href": "datos_espaciales.html#actividades-prácticas",
    "title": "2  Datos Espaciales",
    "section": "2.6 Actividades Prácticas",
    "text": "2.6 Actividades Prácticas\n\nSeleccione una comuna de las manzanas del INE, visualiza con ggplot. Además genere una tabla resumen de suma de personas, hombres, mujeres viviendas por Zona Censal.\n\n\n\n\n\n\n\nTip\n\n\n\nLeer Archivo:\n\nmz_ine &lt;- readRDS(\"../data/censo/manz_INE_2017_sf.rds\")\n\nSeleccionar Comuna con dplyr::filter()\nEliminar geometrías sf::st_drop_geometry() ya que no es necesaria para realizar tabla resumen.\n\n\n\nVisualización de Combinación de Bandas Satelitales\n\n\n\n\n\n\n\nTip\n\n\n\n Referencias: https://mappinggis.com/2019/05/combinaciones-de-bandas-en-imagenes-de-satelite-landsat-y-sentinel/\n\nplotRGB(las_condes_raster, r = 7, g = 6, b = 4, stretch = \"lin\")"
  },
  {
    "objectID": "datos_espaciales.html#referencias",
    "href": "datos_espaciales.html#referencias",
    "title": "2  Datos Espaciales",
    "section": "2.7 Referencias",
    "text": "2.7 Referencias\nGeodesia en Chile, teoría y aplicación del Sistema de Referencia Geocéntrico para las Américas (SIRGAS) - 2018\nSimple Features for R"
  },
  {
    "objectID": "datos_vectoriales.html#objetivos-del-módulo",
    "href": "datos_vectoriales.html#objetivos-del-módulo",
    "title": "3  Datos Vectoriales",
    "section": "3.1 Objetivos del Módulo",
    "text": "3.1 Objetivos del Módulo\n\nManipulación de Datos Vectoriales\nDefinición de Indicadores Territoriales\nConstrucción de Indicadores Socioeconómicos"
  },
  {
    "objectID": "datos_vectoriales.html#manipulación-de-datos-vectoriales",
    "href": "datos_vectoriales.html#manipulación-de-datos-vectoriales",
    "title": "3  Datos Vectoriales",
    "section": "3.2 Manipulación de Datos Vectoriales",
    "text": "3.2 Manipulación de Datos Vectoriales\n\nLectura de Insumos\nFiltros y selección\nResumen Estadísticos\nJoining\nBuffer Espacial\n\n\n3.2.1 Lectura de Insumos\nPara los efectos prácticos de esta etapa se utilizará la base de datos del censo a nivel zonal a nivel nacional.\n\nzonas_censales &lt;-  readRDS(\"data/censo/zonas_urb_consolidadas.rds\")\n\n\n\n\n\nTable 3.1: Registros de Zonas Censales del Censo 2017\n\n\nREGION\nNOM_REGION\nPROVINCIA\nNOM_PROVIN\nCOMUNA\nNOM_COMUNA\nURBANO\nDISTRITO\nLOC_ZON\nGEOCODIGO\nAREA\nCOD_INE_15\nCOD_INE_16\nVALIDO\nKM2\nESC_JH\nPERS\nM2_O\nM2_C\nDENS_HAB\nDENS_OF\nDENS_COM\ngeometry\n\n\n\n\n1\nREGIÓN DE TARAPACÁ\n14\nTAMARUGAL\n1405\nPICA\nPICA\n1\n1\n1405011001\n9336400.3\n1405011001\n1405011001\nTRUE\n9.3364003\n10.817377\n3876\n0.0000\n0.0000\n415.1493\n0.0000\n0.00000\nMULTIPOLYGON (((-69.31192 -...\n\n\n1\nREGIÓN DE TARAPACÁ\n14\nTAMARUGAL\n1401\nPOZO ALMONTE\nPOZO ALMONTE\n1\n1\n1401011001\n1941994.2\n1401011001\n1401011001\nTRUE\n1.9419942\n10.224880\n2771\n1476.0000\n4093.0000\n1426.8838\n760.0435\n2107.62731\nMULTIPOLYGON (((-69.78591 -...\n\n\n1\nREGIÓN DE TARAPACÁ\n14\nTAMARUGAL\n1401\nPOZO ALMONTE\nPOZO ALMONTE\n1\n2\n1401011002\n3572254.9\n1401011002\n1401011002\nTRUE\n3.5722549\n10.253158\n6506\n1905.0000\n9696.0000\n1821.2586\n533.2766\n2714.25201\nMULTIPOLYGON (((-69.76215 -...\n\n\n1\nREGIÓN DE TARAPACÁ\n14\nTAMARUGAL\n1404\nHUARA\nHUARA\n1\n1\n1404011001\n603314.2\n1404011001\n1404011001\nTRUE\n0.6033142\n9.523220\n1082\n0.0000\n0.0000\n1793.4270\n0.0000\n0.00000\nMULTIPOLYGON (((-69.7696 -1...\n\n\n1\nREGIÓN DE TARAPACÁ\n11\nIQUIQUE\n1107\nALTO HOSPICIO\nALTO HOSPICIO\n1\n2\n1107011002\n2272129.2\n1107011002\n1107011002\nTRUE\n2.2721292\n9.747321\n4360\n475.0686\n180.6789\n1918.9050\n209.0852\n79.51965\nMULTIPOLYGON (((-70.09246 -...\n\n\n1\nREGIÓN DE TARAPACÁ\n11\nIQUIQUE\n1107\nALTO HOSPICIO\nALTO HOSPICIO\n3\n2\n1107031002\n5820325.8\n1107031002\n1107031002\nTRUE\n5.8203258\n9.397516\n7099\n4003.6214\n1008.7833\n1219.6912\n687.8690\n173.32076\nMULTIPOLYGON (((-70.05305 -...\n\n\n\n\n\n\n\n\n\n\n3.2.2 Filtros y selección de columnas\nPara efectos de practicar la manipulación de datos espaciales se creará un subset de la base de zonas censales de alguna provincia de Chile y se realizarán cálculos sencillos de densidad.\nFiltrar\n\n # zonas_censales$NOM_PROVIN %&gt;% unique() %&gt;% sort()\nzonas &lt;-  zonas_censales %&gt;% \n  filter(NOM_PROVIN == \"VALPARAÍSO\") %&gt;% \n  filter(URBANO %in% c(\"VIÑA DEL MAR\", \"VALPARAÍSO\") )\n\n# mapview::mapview(zonas, zcol = \"PERS\")\n\n\nggplot() +\n  geom_sf(data = zonas, aes(fill = PERS), color =NA, \n          alpha=0.8,  size= 0.1)+\n  scale_fill_distiller(palette= \"YlGnBu\", direction = 1)+\n  ggtitle(\"Población Zonas Censales - Urbano\" ) +\n  theme_bw() +\n  theme(panel.grid.major = element_line(colour = \"gray80\"), \n        panel.grid.minor = element_line(colour = \"gray80\"))\n\n\n\n\nFigure 3.1: Zonas Censales de comunas de Valparaíso y Viña del Mar - Urbano\n\n\n\n\nSelección de columnas\n\nzonas &lt;-  zonas %&gt;% \n  dplyr::select(GEOCODIGO,NOM_REGION, NOM_PROVIN, NOM_COMUNA, PERS, URBANO, ESC_JH)\n\n\n\n3.2.3 Operaciones Espaciales\nCálculo de superficie por polígono\n\nzonas &lt;- zonas %&gt;% \n  mutate(AREA = as.numeric(st_area(.))) %&gt;% # en metros cuadrados\n  mutate(AREA = AREA/10000) %&gt;% # en hectárea cuadrada\n  mutate(DENS_PERS= round(PERS/AREA, 1))\n\nzonas\n\nSimple feature collection with 270 features and 9 fields\nGeometry type: MULTIPOLYGON\nDimension:     XY\nBounding box:  xmin: -71.66215 ymin: -33.10497 xmax: -71.44276 ymax: -32.94484\nGeodetic CRS:  +proj=longlat +datum=WGS84 +ellps=WGS84 +towgs84=0,0,0\nFirst 10 features:\n    GEOCODIGO           NOM_REGION NOM_PROVIN   NOM_COMUNA PERS       URBANO\n1  5109041011 REGIÓN DE VALPARAÍSO VALPARAÍSO VIÑA DEL MAR 1099 VIÑA DEL MAR\n2  5109041001 REGIÓN DE VALPARAÍSO VALPARAÍSO VIÑA DEL MAR 2019 VIÑA DEL MAR\n3  5109041008 REGIÓN DE VALPARAÍSO VALPARAÍSO VIÑA DEL MAR 2909 VIÑA DEL MAR\n4  5109171001 REGIÓN DE VALPARAÍSO VALPARAÍSO VIÑA DEL MAR 4112 VIÑA DEL MAR\n5  5109041003 REGIÓN DE VALPARAÍSO VALPARAÍSO VIÑA DEL MAR 3848 VIÑA DEL MAR\n6  5109041009 REGIÓN DE VALPARAÍSO VALPARAÍSO VIÑA DEL MAR 1644 VIÑA DEL MAR\n7  5109041002 REGIÓN DE VALPARAÍSO VALPARAÍSO VIÑA DEL MAR 2622 VIÑA DEL MAR\n8  5109041004 REGIÓN DE VALPARAÍSO VALPARAÍSO VIÑA DEL MAR 4388 VIÑA DEL MAR\n9  5109171002 REGIÓN DE VALPARAÍSO VALPARAÍSO VIÑA DEL MAR 4370 VIÑA DEL MAR\n10 5109121002 REGIÓN DE VALPARAÍSO VALPARAÍSO VIÑA DEL MAR 3536 VIÑA DEL MAR\n      ESC_JH                       geometry      AREA DENS_PERS\n1  14.874739 MULTIPOLYGON (((-71.54403 -...  30.21474      36.4\n2  15.452073 MULTIPOLYGON (((-71.52892 -... 280.03089       7.2\n3  16.270210 MULTIPOLYGON (((-71.50958 -... 193.87803      15.0\n4  11.814570 MULTIPOLYGON (((-71.48 -32.... 359.81093      11.4\n5  14.875097 MULTIPOLYGON (((-71.51213 -... 438.40072       8.8\n6  15.539638 MULTIPOLYGON (((-71.53398 -...  38.79690      42.4\n7  14.691789 MULTIPOLYGON (((-71.52915 -...  47.69528      55.0\n8  16.590909 MULTIPOLYGON (((-71.5356 -3... 155.56770      28.2\n9   9.136792 MULTIPOLYGON (((-71.47489 -... 546.70960       8.0\n10 12.231474 MULTIPOLYGON (((-71.52137 -... 150.78167      23.5\n\n\n\nggplot() +\n  geom_sf(data = zonas, aes(fill = PERS), color =NA, \n          alpha=0.8,  size= 0.1)+\n  scale_fill_distiller(palette= \"YlGnBu\", direction = 1)+\n  ggtitle(\"Población Zonas Censales - Urbano\" ) +\n  theme_bw() +\n  theme(panel.grid.major = element_line(colour = \"gray80\"), \n        panel.grid.minor = element_line(colour = \"gray80\"))\nggplot() +\n  geom_sf(data = zonas, aes(fill = DENS_PERS), color =NA, \n          alpha=0.8,  size= 0.1)+\n  scale_fill_distiller(palette= \"YlGnBu\", direction = 1)+\n  ggtitle(\"Densidad de Población Zonas Censales - Urbano\" ) +\n  theme_bw() +\n  theme(panel.grid.major = element_line(colour = \"gray80\"), \n        panel.grid.minor = element_line(colour = \"gray80\"))\n\n\n\n\n\n\nFigure 3.2: Diferencias de un valor absoluto y densidad de Personas en Zonas Censales\n\n\n\n\n\n\n\nFigure 3.3: Diferencias de un valor absoluto y densidad de Personas en Zonas Censales\n\n\n\n\n\n\n\n\n3.2.4 Resumen Estadísticos\nEl objetivo de este punto es que con bases de datos espaciales también se pueden hacer resúmenes estadísticos, como se hacen normalmente con bases de datos. Ahora, se creará tabla con las poblaciones y promedio de años de estudio del Jefe de Hogar en todas las comunas de Chile.\nUn punto importante para generar esta tabla es eficiente eliminar la geometría para los cálculos ya que la salida será una tabla.\n\ntab_com &lt;- zonas_censales %&gt;% \n  st_drop_geometry() %&gt;% # eliminar geometría.\n  group_by(NOM_COMUNA) %&gt;% \n  summarise(POB_COM = sum(PERS),\n            ESC_JH_COM = round(mean(ESC_JH, na.rm= T), 1))\n\n\n\n\n\nTable 3.2: Registros de Población y Escolaridad por Comuna\n\n\nNOM_COMUNA\nPOB_COM\nESC_JH_COM\n\n\n\n\nALGARROBO\n10880\n12.1\n\n\nALHUÉ\n2706\n9.6\n\n\nALTO HOSPICIO\n105065\n10.4\n\n\nANCUD\n28162\n10.0\n\n\nANDACOLLO\n9989\n8.8\n\n\nANGOL\n48608\n10.1\n\n\nANTOFAGASTA\n349983\n12.2\n\n\nANTUCO\n2038\n9.2\n\n\nARAUCO\n27274\n9.8\n\n\nARICA\n203132\n11.5\n\n\n\n\n\n\n\n\n\n\n3.2.5 Joining\nEn este caso agregaremos a la tabla de resultados comunales antes creada, a la base de la comuna de Viña del Mar y Valparaíso, utilizaremos la función left_join.\n\nzonas &lt;-  zonas %&gt;% \n  left_join(tab_com, by = \"NOM_COMUNA\") %&gt;% # Ojo con las veces que se hace esta operación\n  mutate(DIF_EJH_COM = round(( ESC_JH-ESC_JH_COM), 2))\n\n\nggplot() +\n  geom_sf(data = zonas, aes(fill = DIF_EJH_COM), color =NA, \n          alpha=0.8,  size= 0.1)+\n  scale_fill_distiller(palette= \"PRGn\", direction = 1)+\n  ggtitle(\"Diferencias Esc. Jefe Hogar Zona/Comuna - Urbano\" ) +\n  theme_bw() +\n  theme(panel.grid.major = element_line(colour = \"gray80\"), \n        panel.grid.minor = element_line(colour = \"gray80\"))\n\n\n\n\nFigure 3.4: Diferencias Esc. Jefe Hogar respecto comuna - Urbano\n\n\n\n\n\n\n3.2.6 Buffer\nPrimeramente se creará una geometría comunal basándose en las zonas censales\n\nvalpo_com &lt;-  zonas %&gt;% filter(NOM_COMUNA == \"VALPARAÍSO\") %&gt;% \n  st_union()\n\n\nggplot() +\n  geom_sf(data = zonas, aes(fill = DIF_EJH_COM), color =NA, \n          alpha=0.3,  size= 0.1)+\n  scale_fill_distiller(palette= \"PRGn\", direction = 1)+\n  geom_sf(data = valpo_com,  color =\"magenta\", alpha=1,  size= 1, fill = NA)+\n  ggtitle(\"Resaltar la comuna de Valparaíso\" ) +\n  theme_bw() +\n  theme(panel.grid.major = element_line(colour = \"gray80\"), \n        panel.grid.minor = element_line(colour = \"gray80\"))\n\n\n\n\nFigure 3.5: Resaltar la comuna de Valparaíso\n\n\n\n\nAplicación de Buffer con la función de st_buffer.\n\nvalpo_com_buffer &lt;-  valpo_com %&gt;% \n  st_buffer(dist = 1000) # %&gt;% st_simplify(dTolerance = 100) \n\n\nggplot() +\n  geom_sf(data = valpo_com_buffer,  color =\"orange\", alpha=1,  size= 1, fill = NA)+\n  geom_sf(data = valpo_com,  color =\"magenta\", alpha=0.3,  size= 1, fill = \"magenta\")+\n  ggtitle(\"Buffer de la comuna de Valparaíso - 1000 mts.\" ) +\n  theme_bw() +\n  theme(panel.grid.major = element_line(colour = \"gray80\"), \n        panel.grid.minor = element_line(colour = \"gray80\"))\n\n\n\n\nFigure 3.6: Buffer de la comuna de Valparaíso - 1000 mts."
  },
  {
    "objectID": "datos_vectoriales.html#indicadores-territoriales",
    "href": "datos_vectoriales.html#indicadores-territoriales",
    "title": "3  Datos Vectoriales",
    "section": "3.3 Indicadores Territoriales",
    "text": "3.3 Indicadores Territoriales\n\n3.3.1 Definición de Indicadores\n\n¿Qué es un Indicador?:\n\nUn indicador es un instrumento que provee información de una determinada condición, situación, actividad o resultado. Este instrumento nos permite definir un punto de comparación para establecer diferencias entre individuos o respecto a sí mismo en diferentes tiempos. Son construidos a través de análisis y operaciones técnicas y nos entregan una medida cuantitativa (valor) o una descripción cualitativa (caracterización) de la magnitud o criterio que se pretende medir u observar.\n\n\n\n\n3.3.2 Indicadores Territoriales\nEl Centro de Inteligencia Territorial de la Universidad Adolfo Ibáñez, bajo proyecto denominado Matriz de Bienestar Humano Territorial (MBHT) construyó una serie indicadores territoriales, que buscan comprender las condiciones de los entornos urbanos y rurales, para construir soluciones que impacten positivamente en el bienestar de las personas y su hábitat.\n\n\n\nFigure 3.7: Centro de Inteligencia Territorial - UAI\n\n\nEl sistema MBHT consiste en 18 indicadores territoriales agrupados en 4 dimensiones, que corresponde a las dimensiones de Accesibilidad, Ambiental, Seguridad y Socoeconómicas, siendo esta última a la se replicará.\n\n\n\n\n\n\n\nFigure 3.8: Dimensiones de la Matriz de Bienestar Humano Territorial"
  },
  {
    "objectID": "datos_vectoriales.html#sec-indsoc",
    "href": "datos_vectoriales.html#sec-indsoc",
    "title": "3  Datos Vectoriales",
    "section": "3.4 Construcción de Indicadores Socioconómicos",
    "text": "3.4 Construcción de Indicadores Socioconómicos\nLas ciudades de Chile presentan altos índices de segregación (Sabatini, 2002), que reflejan la separación espacial de distintos grupos sociales (Ruiz-Tagle, 2014). La intensidad de este fenómeno hace imperativo el considerar la condición social como una dimensión estructurante en la evaluación de Políticas Públicas.\n\n\n\n\n\n\n\nFigure 3.9: Indicadores Socioconómicos\n\n\n\n3.4.1 Insumos Censo 2017\nPara la construcción de los indicadores territoriales que componen la dimensión seocioeconómica, se utiliza íntegramente información del Censo 2017.\n¿Que es Censo 2017?:\nEl censo de población y vivienda es la operación estadística más importante que realiza el INE y en la cual participan todos los habitantes del país, ya que este es un insumo esencial para elaborar estimaciones y proyecciones de población tanto para el país, las regiones y las comunas.\nEl censo permite contar con información esencial para el adecuado diseño de políticas públicas y toma de decisiones privadas y públicas. El último censo de población y vivienda realizado fue en 2017. Sus resultados indican que la población efectivamente censada llegó a un total de 17.574.003 personas.\nDe ellas, 8.601.989 (48,9%) son hombres y 8.972.014 (51,1%), mujeres. El número de viviendas, en tanto, fue 6.499.355, de las cuales 6.486.533 (99,8%) corresponden a viviendas particulares y 12.822 (0,2%) a colectivas.\nPara estos fines, se utilizaremos información censal agregada a nivel de manzanas obtenidos del Censo 2017, a continuación se explorará los insumos utilizados.\n\n\n\n\n\n\n\nFigure 3.10: Censo 2017 - Instituto Nacional de Estadísticas de Chile\n\n\n\n\n3.4.2 Insumos del Censo\nPara los indicadores que se crearán a continuación se utilizará una base proveniente de la consolidación de las bases del censo, denominadas microdatos de Personas, Viviendas y Hogares provenientes de los resultados de la Encuesta del Censo 2017 del Instituto Nacional de Estadísticas, Chile.\n\nlibrary(sf)\nlibrary(dplyr)\n\n# ruta de insumos\npath_insumos &lt;- \"data/socioeconomicos/insumos/\"\n\nLectura de Insumos y selección de región de estudio, en este caso seleccionará la Región de Coquimbo compuesta por las provincias de Elqui, Limarí y Choapa. Sus principales centros urbanos son la Conurbación La Serena-Coquimbo con 506 391 habitantes, seguida de Ovalle con 121.269 habitantes según el Censo chileno de 2017.\n\n# selección de región\nreg &lt;-  \"R04\"\n\n# Lectura de insumo espacial\npath_file &lt;- paste0(path_insumos, reg, \"_INSUMO_SOCIOECONOMICO.shp\")\ncenso &lt;- st_read(path_file, quiet = T)\n\nVisualización de Tabla de Información head()\n\n\n\n\nTable 3.3: Visualización de registros de insumos del Censo 2017 para indicadores socioeconómicos\n\n\nID_MANZ\nMANZ_EN\nNOM_COM\nCOD_COM\nNOM_REG\nCOD_REG\nNOM_PROV\nCOD_PROV\nZONA\nID_MANZCIT\nAREA\nTOTAL_V\nHOG_N\nPERSONAS\nE4A18\nE15A24\nESCOLAR\nP03A_4\nP03A_5\nP03A_6\nP03B_4\nP03B_6\nP03B_7\nP03C_4\nP03C_5\nNIV_HAC2\nNIV_HAC3\nHOMBRES\nMUJERES\nMONOPAR\nP17_ACT\nP17_4\nJ_NINI\nJH_HASTA_P\nJH_HASTA_S\ngeometry\n\n\n\n\n4101071001900\nURBANO\nLA SERENA\n4101\nREGIÓN DE COQUIMBO\n4\nELQUI\n41\n4101071001\n4101071001900001\n2873.376\n0\n0\n0\n0\n0\n0\n0\n0\n0\n0\n0\n0\n0\n0\n0\n0\n0\n0\n0\n0\n0\n0\n0\n0\nPOLYGON ((292811 6685815, 2...\n\n\n4101071001900\nURBANO\nLA SERENA\n4101\nREGIÓN DE COQUIMBO\n4\nELQUI\n41\n4101071001\n4101071001900002\n1256.480\n0\n0\n0\n0\n0\n0\n0\n0\n0\n0\n0\n0\n0\n0\n0\n0\n0\n0\n0\n0\n0\n0\n0\n0\nPOLYGON ((293056 6685511, 2...\n\n\n4102101001900\nURBANO\nCOQUIMBO\n4102\nREGIÓN DE COQUIMBO\n4\nELQUI\n41\n4102101001\n4102101001900001\n1230.344\n0\n0\n0\n0\n0\n0\n0\n0\n0\n0\n0\n0\n0\n0\n0\n0\n0\n0\n0\n0\n0\n0\n0\n0\nPOLYGON ((285917.8 6664517,...\n\n\n4102101001900\nURBANO\nCOQUIMBO\n4102\nREGIÓN DE COQUIMBO\n4\nELQUI\n41\n4102101001\n4102101001900002\n3877.142\n0\n0\n0\n0\n0\n0\n0\n0\n0\n0\n0\n0\n0\n0\n0\n0\n0\n0\n0\n0\n0\n0\n0\n0\nPOLYGON ((286085 6664254, 2...\n\n\n4102101001900\nURBANO\nCOQUIMBO\n4102\nREGIÓN DE COQUIMBO\n4\nELQUI\n41\n4102101001\n4102101001900003\n34392.873\n0\n0\n0\n0\n0\n0\n0\n0\n0\n0\n0\n0\n0\n0\n0\n0\n0\n0\n0\n0\n0\n0\n0\n0\nPOLYGON ((286082.4 6663489,...\n\n\n4106101001900\nURBANO\nVICUÑA\n4106\nREGIÓN DE COQUIMBO\n4\nELQUI\n41\n4106101001\n4106101001900001\n4033.107\n0\n0\n0\n0\n0\n0\n0\n0\n0\n0\n0\n0\n0\n0\n0\n0\n0\n0\n0\n0\n0\n0\n0\n0\nPOLYGON ((310231.6 6684580,..."
  },
  {
    "objectID": "datos_vectoriales.html#indicador-de-escolaridad-del-jefe-de-hogar-iej",
    "href": "datos_vectoriales.html#indicador-de-escolaridad-del-jefe-de-hogar-iej",
    "title": "3  Datos Vectoriales",
    "section": "3.5 Indicador de Escolaridad del jefe de hogar (IEJ)",
    "text": "3.5 Indicador de Escolaridad del jefe de hogar (IEJ)\nPara la construcción de este indicador se utilizó el promedio de años de estudio de jefes de hogar (EJH), que es una variable censal numérica (“ESCOLARIDAD”, en tabla de personas del censo 2017) que registra el nivel del curso más alto aprobado, medida en años sucesivos desde la enseñanza básica hasta estudios de postgrado.\nSe calcula el promedio de esta variable para todos los jefes de hogar en cada manzana. Esta variable es representativa del capital cultural de cada hogar y está altamente correlacionada con el nivel de ingresos en Chile (Agostini et al, 2016).\nIEJ = ESCOLAR\nCálculo Indicador de Escolaridad del jefe de hogar (IEJ)\n\ncenso &lt;- censo %&gt;% \n  mutate( IEJ = ifelse(PERSONAS ==0, NA, ESCOLAR))\n\nPara efectos de visualización se enfocará los resultados en las zonas urbanas de la comuna de La Serena en todos los indicadores que se presentarán.\n\nla_serena_urb &lt;- censo %&gt;% \n  filter(COD_COM == 4101 & MANZ_EN == \"URBANO\")\n\nVisualizar la Variable de IEJ comuna de La Serena URBANO:\n\nggplot() +\n  geom_sf(data = la_serena_urb, aes(fill = IEJ), color =NA, \n          alpha=0.8,  size= 0.1)+\n  scale_fill_distiller(palette= \"YlGnBu\", direction = 1)+\n  ggtitle(\"Indicador de Escolaridad del jefe de hogar (IEJ) - Urbano\" ) +\n  theme_bw() +\n  theme(panel.grid.major = element_line(colour = \"gray80\"), \n        panel.grid.minor = element_line(colour = \"gray80\"))\n\n\n\n\nFigure 3.11: Indicador de Escolaridad del jefe de hogar (IEJ) - Urbano\n\n\n\n\n\n# mapview::mapview(censo %&gt;% filter(COD_COM == 4101 & MANZ_EN == \"URBANO\"),\n                 # zcol = \"IEJ\", layer.name = \"IEJ\")\n\nVisualizar la Variable de IEJ comuna de La Serena RURAL:\n\nla_serena_rural &lt;- censo %&gt;% filter(COD_COM == 4101 & MANZ_EN == \"RURAL\")\n\nggplot() +\n  geom_sf(data = la_serena_rural, aes(fill = IEJ), color =NA, \n          alpha=0.8,  size= 0.1)+\n  scale_fill_distiller(palette= \"YlGnBu\", direction = 1)+\n  ggtitle(\"Indicador de Escolaridad del jefe de hogar (IEJ) - Rural\" ) +\n  theme_bw() +\n  theme(panel.grid.major = element_line(colour = \"gray80\"), \n        panel.grid.minor = element_line(colour = \"gray80\"))\n# mapview::mapview(censo %&gt;% filter(COD_COM == 4101 & MANZ_EN == \"RURAL\"),\n                 # zcol = \"IEJ\", layer.name = \"IEJ\")\n\n\n\n\nFigure 3.12: Indicador de Escolaridad del jefe de hogar (IEJ) - Rural"
  },
  {
    "objectID": "datos_vectoriales.html#indicador-de-empleo-iem",
    "href": "datos_vectoriales.html#indicador-de-empleo-iem",
    "title": "3  Datos Vectoriales",
    "section": "3.6 Indicador de Empleo (IEM)",
    "text": "3.6 Indicador de Empleo (IEM)\nPara este indicador se usó la proporción de población activa sin empleo que es la fracción de las personas que no tienen empleo y están buscando uno, respecto al total de personas en condiciones y con deseo de trabajar en cada manzana.\nEsta variable es similar al cálculo de desempleo, pero calculada a escala de manzanas y en un tiempo específico, por lo que representa las brechas potenciales que existen para acceder al empleo en barrios específicos (MDS, 2019).\nIEM = 1- \\left(\\frac{P17\\_4}{P17\\_ACT} \\right) \nCálculo Indicador de Empleo (IEM) \nP17_4: Trabajo la semana pasada, opción 4: “Se encontraba buscando empleo”\nP17_ACT: Total de Actividades Remuneradas (no es pregunta del Censo)\n\n# P17: Trabajo la semana pasada\n# opción `4`: \"Se encontraba buscando empleo\"\n# P17_ACT: Total de Actividades Remuneradas\n\ncenso &lt;- censo %&gt;% mutate( CESA_DENS = P17_4 / P17_ACT)\n\n# Invertir el valor de indicador 1\ncenso &lt;- censo %&gt;% mutate( IEM = 1 - CESA_DENS )\n\nDe aquí continuación se realizarán cartografías solo a zonas urbanas a efecto de limitar la extensión del presente documento, pero el cálculo urbano se puede efectuar perfectamente aplicando un filtro como se ejemplifico en el indicador anterior. Ahora, se procede a filtrar por zonas urbanas\n\nla_serena_urb &lt;- censo %&gt;% filter(COD_COM == 4101 & MANZ_EN == \"URBANO\")\n\nVisualizar la Variable de IEM comuna de La Serena URBANO:\n\nggplot() +\n  geom_sf(data = la_serena_urb, aes(fill = IEM), color =NA, \n          alpha=0.8,  size= 0.1)+\n  scale_fill_distiller(palette= \"PuBu\", direction = 1)+\n  ggtitle(\"Indicador de Empleo (IEM) - Urbano\" ) +\n  theme_bw() +\n  theme(panel.grid.major = element_line(colour = \"gray80\"), \n        panel.grid.minor = element_line(colour = \"gray80\"))\n\n\n\n\nFigure 3.13: Indicador de Empleo (IEM) - Urbano\n\n\n\n\n\n# mapview::mapview(la_serena_urb, \n#                  zcol = \"IEM\", layer.name = \"IEM\")"
  },
  {
    "objectID": "datos_vectoriales.html#indicador-de-participacion-juvenil-en-empleo-y-estudio-ipj",
    "href": "datos_vectoriales.html#indicador-de-participacion-juvenil-en-empleo-y-estudio-ipj",
    "title": "3  Datos Vectoriales",
    "section": "3.7 Indicador de Participación Juvenil en empleo y estudio (IPJ)",
    "text": "3.7 Indicador de Participación Juvenil en empleo y estudio (IPJ)\nPara la construcción de este indicador se utilizó la proporción de jóvenes entre 14 y 24 años que no trabajan ni estudian: es la fracción de jóvenes en este rango edad que no trabajan ni estudian, respecto al total de este segmento etario en cada manzana.\nEsta variable representa un riesgo de exclusión socioeconómica en el período de transición entre el ambiente educativo y el laboral, siendo característico de trayectorias de deserción escolar que conducen al desempleo y que podrían incrementar el riesgo de adopción de comportamientos delictivos (MDS, 2019).\nLuego, el indicador se normalizó con su inverso aditivo, para asegurar que el valor máximo, sea lo más deseable y el 0 lo menos deseable, convirtiéndose así en un indicador de empleo.\nIPJ = 1 - \\left(\\frac{J\\_NINI}{E15A24} \\right)\nCálculo Indicador de Participación Juvenil en empleo y estudio (IPJ) \nJ_NINI: Jóvenes que no trabajan ni estudian P17 E15A24: Jóvenes entre 15 y 24 años de edad\n\ncenso &lt;- censo %&gt;% mutate( NINI_DENS = J_NINI / E15A24)  \ncenso &lt;- censo %&gt;% mutate( NINI_DENS = ifelse(NINI_DENS &gt; 1, 1, NINI_DENS))  \ncenso &lt;- censo %&gt;% mutate( IPJ = 1 - NINI_DENS )\n\n\nla_serena_urb &lt;- censo %&gt;% filter(COD_COM == 4101 & MANZ_EN == \"URBANO\")\n\nVisualizar la Variable de IPJ comuna de La Serena URBANO:\n\nggplot() +\n  geom_sf(data = la_serena_urb, aes(fill = IPJ), color =NA, \n          alpha=0.8,  size= 0.1)+\n  scale_fill_distiller(palette= \"Purples\", direction = 1)+\n  ggtitle(\"Indicador de Participación Juvenil en empleo y estudio (IPJ) - Urbano\" ) +\n  theme_bw() +\n  theme(panel.grid.major = element_line(colour = \"gray80\"), \n        panel.grid.minor = element_line(colour = \"gray80\"))\n\n\n\n\nFigure 3.14: Indicador de Participación Juvenil enempleo y estudio (IPJ) - Urbano\n\n\n\n\n\n# mapview::mapview(la_serena_urb, \n#                  zcol = \"IPJ\", layer.name = \"IPJ\")"
  },
  {
    "objectID": "datos_vectoriales.html#indicador-de-resiliencia-de-hogares-irh",
    "href": "datos_vectoriales.html#indicador-de-resiliencia-de-hogares-irh",
    "title": "3  Datos Vectoriales",
    "section": "3.8 Indicador de Resiliencia de Hogares (IRH)",
    "text": "3.8 Indicador de Resiliencia de Hogares (IRH)\nEn particular, la monoparentalidad es ampliamente reconocida en la literatura internacional como una situación familiar frágil, que puede afectar las trayectorias de vida de los hijos, en términos de un mayor riesgo de mortalidad (Amato & Patterson, 2017), inestabilidad psicológica (Theodoritsi, Daliana & Antoniou, 2018), problemas de salud (Duriancik & Goff, 2019) y otros.\nEn suma, el Indicador de Resiliencia de Hogares (en base a la monoparentalidad), en complemento a otras variables, es conceptualmente relevante para evaluar riesgos no monetarios de condiciones sociales.\nEste indicador es el inverso aditivo de la proporción de hogares monoparentales dentro de una manzana. Los hogares monoparentales son aquellos con hijos que viven con un solo progenitor, lo que se asocia en diversas formas a la condición social, que abarcan desde un menor ingreso, problemas de salud y delincuencia, entre otros (MDS, 2019).\nAl contrario, los hogares biparentales permiten el apoyo entre progenitores y los hogares sin hijos tienen menores exigencias de gasto y tiempo relacionadas con la paternidad, por lo que se considera que en general son más resilientes.\nIRH = 1 - \\left(\\frac{MONOPAR}{HOG\\_N} \\right)\nCálculo de Indicador de Resiliencia de Hogares (IRH) \nMONOPAR: Hogares Monoparentales\nHOG_N: Número de Hogares\n\ncenso &lt;- censo %&gt;% mutate( MONO_DENS = MONOPAR / HOG_N)\ncenso &lt;- censo %&gt;% mutate( MONO_DENS = ifelse(MONO_DENS &gt; 1, 1, MONO_DENS))  \ncenso &lt;- censo %&gt;% mutate( IRH = 1 - MONO_DENS)\n\n\nla_serena_urb &lt;- censo %&gt;% filter(COD_COM == 4101 & MANZ_EN == \"URBANO\")\n\nVisualizar la Variable de IRH comuna de La Serena URBANO:\n\nggplot() +\n  geom_sf(data = la_serena_urb, aes(fill = IRH), color =NA, \n          alpha=0.8,  size= 0.1)+\n  scale_fill_distiller(palette= \"PuRd\", direction = 1)+\n  ggtitle(\"Indicador de Resiliencia de Hogares (IRH) - Urbano\") +\n  theme_bw() +\n  theme(panel.grid.major = element_line(colour = \"gray80\"), \n        panel.grid.minor = element_line(colour = \"gray80\"))\n\n\n\n\nFigure 3.15: Indicador de Resiliencia de Hogares (IRH) - Urbano\n\n\n\n\n\n# mapview::mapview(la_serena_urb, \n#                  zcol = \"IRH\", layer.name = \"IRH\")"
  },
  {
    "objectID": "datos_vectoriales.html#indicador-de-calidad-de-la-vivienda-ivi",
    "href": "datos_vectoriales.html#indicador-de-calidad-de-la-vivienda-ivi",
    "title": "3  Datos Vectoriales",
    "section": "3.9 Indicador de Calidad de la Vivienda (IVI)",
    "text": "3.9 Indicador de Calidad de la Vivienda (IVI)\nEl indicador de calidad de vivienda es una variable sintética de todas las materialidades de la vivienda. Inicialmente, se construyó como un indicador de mala calidad, tomando un valor más alto cuando la calidad de la vivienda es peor y es más bajo cuando es mejor. Fue elaborado como un promedio lineal del 3 sub-indicadores de paredes, suelo y techo. Cada uno de estos sub-indicadores registra el porcentaje de viviendas de la manzana que tienen paredes, suelo o techo considerado insuficiente. Las construcciones consideradas insuficientes son las siguientes:\nParedes: Material de los muros exteriores\nparedes= \\frac{(P03A\\_4 + P03A\\_5 + P03A\\_6)}{TOTAL\\_V}\n\nP03A_4: Tabique sin forro interior (madera u otro)\nP03A_5: Adobe, barro, quincha, pirca u otro artesanal tradicional\nP03A_6: Materiales precarios (lata, cartón, plástico, etc.)\n\nTecho: Material en la cubierta del techo\ntecho= \\frac{(P03B\\_4 + P03B\\_6 + P03B\\_7)}{TOTAL\\_V}\n\nP03B_4: Fonolita o plancha de fieltro embreado\nP03B_6: Materiales precarios (lata, cartón, plásticos, etc.)\nP03B_7: Sin cubierta sólida de techo\n\nSuelo: Material de construcción del piso\nsuelo= \\frac{(P03C\\_4 +  P03C\\_5)}{TOTAL\\_V}\n\nP03C_4: Capa de cemento sobre tierra\nP03C_5: Tierra\n\n\ncenso &lt;- censo %&gt;%\n  mutate(paredes = (P03A_4 + P03A_5 + P03A_6)/TOTAL_V,\n         techo = (P03B_4 + P03B_6 + P03B_7)/TOTAL_V,\n         suelo = (P03C_4 +  P03C_5)/TOTAL_V)\n\n# eliminar valores infinitos de la división anterior\ncenso &lt;- censo %&gt;%\n  mutate(paredes = ifelse(paredes &gt; 1, 1, paredes), \n         techo = ifelse(techo &gt; 1, 1, techo), \n         suelo = ifelse(suelo &gt; 1, 1, suelo))\n\nCálculo Indicador de Calidad de la Vivienda (IVI) \nIVI= 1 - \\left(\\frac{paredes+ suelo+ techo}{3}\\right)\n\ncenso &lt;- censo %&gt;%  mutate(IVI = (paredes+ suelo+ techo)/3)\ncenso &lt;- censo %&gt;%  mutate(IVI =  1 - IVI) # invertir sentido\n\n\nla_serena_urb &lt;- censo %&gt;% filter(COD_COM == 4101 & MANZ_EN == \"URBANO\")\n\nVisualizar la Variable de IVI comuna de La Serena URBANO:\n\nggplot() +\n  geom_sf(data = la_serena_urb, aes(fill = IVI), color =NA, \n          alpha=0.8,  size= 0.1)+\n  scale_fill_distiller(palette= \"YlOrRd\", direction = 1)+\n  ggtitle(\"Indicador de Calidad de la Vivienda (IVI) - Urbano\") +\n  theme_bw() +\n  theme(panel.grid.major = element_line(colour = \"gray80\"), \n        panel.grid.minor = element_line(colour = \"gray80\"))\n\n\n\n\nFigure 3.16: Indicador de Calidad de la Vivienda (IVI) - Urbano\n\n\n\n\n\n# mapview::mapview(la_serena_urb, \n#                  zcol = \"IVI\", layer.name = \"IVI\")"
  },
  {
    "objectID": "datos_vectoriales.html#indicador-de-suficiencia-de-viviendas-isv",
    "href": "datos_vectoriales.html#indicador-de-suficiencia-de-viviendas-isv",
    "title": "3  Datos Vectoriales",
    "section": "3.10 Indicador de Suficiencia de Viviendas (ISV)",
    "text": "3.10 Indicador de Suficiencia de Viviendas (ISV)\nEl indicador de Suficiencia de Viviendas se construyó inicialmente como un indicador de hacinamiento. Se realizó a partir de 2 variables que indican el número de viviendas que se encuentran en situación de hacinamiento y el número de viviendas que se encuentran en situación de hacinamiento severo. El indicador corresponde a la suma de 2 veces las viviendas en situación de hacinamiento severo con las viviendas en situación de hacinamiento normal, dividido por el total de viviendas.\nLuego, el indicador se normalizó con su inverso aditivo, para asegurar que el valor máximo, sea lo más deseable y el 0 lo menos deseable. Con esto se obtuvo el indicador de suficiencia de viviendas.\nEl indicador de sificiencia de la vivienda debe ser normalizado, por lo cual se usará la función de normalización minmax (Equation 3.1) que se describe a continuación:\nx^{\\prime}=\\frac{x-min(x)}{max(x)-min(x)} \\tag{3.1}\n\n# función de normalización\nminmax &lt;- function(x) {\n  x &lt;- (x - min(x, na.rm = TRUE)) / \n    (max(x, na.rm = TRUE) - min(x, na.rm = TRUE))\n  return(x)\n}\n\nCálculo de Indicador de Suficiencia de Viviendas (ISV) \nISV = 1 - minmax(NIV\\_HAC2 + (2 \\times  NIV\\_HAC3)\nNIV_HAC2: &gt;= 2.5 personas por habitación (Hacinamiento)\nNIV_HAC3: &gt;= 5 personas por habitación (Hacinamiento severo)\n\ncenso &lt;- censo %&gt;% mutate(ISV = NIV_HAC2 + (2 * NIV_HAC3))\ncenso &lt;- censo %&gt;% mutate(ISV = 1 - minmax(ISV))\n\n\nla_serena_urb &lt;- censo %&gt;% filter(COD_COM == 4101 & MANZ_EN == \"URBANO\")\n\nVisualizar la Variable de ISV comuna de La Serena URBANO:\n\nggplot() +\n  geom_sf(data = la_serena_urb, aes(fill = ISV), color =NA, \n          alpha=0.8,  size= 0.1)+\n  scale_fill_distiller(palette= \"YlOrRd\", direction = 1)+\n  ggtitle(\" Indicador de Suficiencia de Viviendas (ISV) - Urbano\") +\n  theme_bw() +\n  theme(panel.grid.major = element_line(colour = \"gray80\"), \n        panel.grid.minor = element_line(colour = \"gray80\"))\n\n\n\n\nFigure 3.17: Indicador de Suficiencia de Viviendas (ISV) - Urbano\n\n\n\n\n\n# mapview::mapview(la_serena_urb, \n#                  zcol = \"ISV\", layer.name = \"ISV\")"
  },
  {
    "objectID": "datos_vectoriales.html#consolidación-de-dimensión-socioeconómica",
    "href": "datos_vectoriales.html#consolidación-de-dimensión-socioeconómica",
    "title": "3  Datos Vectoriales",
    "section": "3.11 Consolidación de Dimensión Socioeconómica",
    "text": "3.11 Consolidación de Dimensión Socioeconómica\nSelección de Variables de Interés\n\n# names(censo)\nsoc &lt;- censo %&gt;% \n  dplyr::select(ID_MANZ:PERSONAS, IEJ, IEM, IPJ, IRH, IVI, ISV)\n\nVisualización de los Indicadores\n\ncomuna &lt;- soc %&gt;% filter(COD_COM == 4101 & MANZ_EN == \"URBANO\")\nmapview(comuna, zcol = \"IEJ\") + mapview(comuna, zcol = \"IEM\")+\n  mapview(comuna, zcol = \"IPJ\") + mapview(comuna, zcol = \"IRH\")+\n  mapview(comuna, zcol = \"IVI\") + mapview(comuna, zcol = \"ISV\")\n\nGuardar Resultados\n\n# guardar shapefile\npath_file_out &lt;- paste0(\"../data/socioeconomicos/resultados/\",\n                    reg, \"_ind_socioeconomicos.shp\")\nst_write(soc, path_file_out)\n\n#guardar en RDS\npath_file_out_rds &lt;- paste0(\"../data/socioeconomicos/resultados/\",\n                    reg, \"_ind_socioeconomicos.rds\")\nsaveRDS(soc, path_file_out_rds)"
  },
  {
    "objectID": "datos_vectoriales.html#referencias",
    "href": "datos_vectoriales.html#referencias",
    "title": "3  Datos Vectoriales",
    "section": "3.12 Referencias",
    "text": "3.12 Referencias\n\nR para Ciencia de Datos\nRStudio para Estadística Descriptiva en Ciencias Sociales\nR para Principiantes4/\nColores en Ggplot2"
  },
  {
    "objectID": "raster.html#objetivos-del-módulo",
    "href": "raster.html#objetivos-del-módulo",
    "title": "4  Datos tipo Raster",
    "section": "4.1 Objetivos del Módulo",
    "text": "4.1 Objetivos del Módulo\n\nDefinción de Conceptos\nManipulación de datos Raster de imágenes satelitales.\nConstrucción de Indicadores ambientales"
  },
  {
    "objectID": "raster.html#definición-de-conceptos",
    "href": "raster.html#definición-de-conceptos",
    "title": "4  Datos tipo Raster",
    "section": "4.2 Definición de Conceptos",
    "text": "4.2 Definición de Conceptos\n\nPercepción Remota:\n\nPercepción Remota o en una disciplina científica que entrega un amplio conjunto de conocimientos y tecnologías utilizadas para observación, análisis, la interpretación de fenómenos en el territorio. La percepción remota nos permite efectuar observaciones y mediciones de la superficie terrestre mediante dispositivos remotos instalados sobre plataformas como satélites, aviones y actualmente hasta en drones. Los sensores instalados en estas plataformas miden una gran variedad de datos como radiaciones electromagnéticas, espectro electromagnético, perturbaciones atmosféricas, firmas espectrales y captura de imágenes, entre otros.\n\n\n\n\n\nPercepción Remota\n\n\n\nPercepción Remota Satelital:\n\nLos satélites llevan instrumentos o sensores que miden la radiación electromagnética proveniente del sistema tierra - atmósfera. La intensidad de la radiación reflejada y emitida al espacio es influenciada por las condiciones en la superficie y la atmósfera.\n\n\n\n\n\nPercepción Remota Satelital\n\n\n\nEspectro Electromagnético:\n\nEs un conjunto de frecuencias o longitudes de onda en los que se organiza la radiación electromagnética. Abarca las radiaciones entre los rayos gamma y las ondas de radio.\n\n\n\n\n\nEspectro Electromagnético\n\n\n\n\n\nEspectro Electromagnético Satelital\n\n\n\nCaracterísticas de Satélites y Sensores:\n\nLa energía emitida o reflejada por la superficie terrestre es un fenómeno continuo en 4 cuatro dimensiones: espacio, tiempo, longitud de onda y radiancia.\n\n\n\n\n\nSatélites y Sensores\n\n\nResolución espacial: Tamaño del pixel o celda del raster que contiene a la banda espectral (Landsat: 30 m x 30 m)\n\n\n\nResolución espacial\n\n\nResolución temporal: Tiempo entre imágenes sucesivas (Landsat 16 días)\n\n\n\nResolución temporal\n\n\nResolución espectral: Número y rango de las regiones del espectro electromagnético para los que capta información el sensor .\n\n\n\nResolución espectral\n\n\n\nResolución radiométrica: Indica el número de intervalos de intensidad que puede captar el sensor (escala de grises) (Landsat 5 y 7: 256)\n\n\n\n\nResolución radiométrica\n\n\n\n4.2.1 Aplicaciones de Percepción Remota\n\nAplicaciones Generales: Ambientales\n\nBosque Nativo: Superficie anual, Vigor vegetacional y superficie incendiada\nGlaciares: Superficie de cuerpos glaciares\nAmbiente urbano: Superficie anual cubierta con vegetación por manzana urbana\nAmbiente marino costero: Calidad anual del agua superficial del mar\nHumedales Alto Andino: Superficie anual vegetada e inundada en el humedal\n\n\n\n\nAplicaciones Ambientales; temperatura superficial de glaciar\n\n\nAplicaciones Generales: Antrópicas\n\nMancha Urbana: Crecimiento evolutivo\nContaminación de Recursos Naturales: Borde Costero, red hídrica, cuerpos de agua, suelos, aire.\nDeforestación: Actividad de industria a Forestal\nMonitoreo de Edificaciones: Construcción de Industrias, asentamientos, cualquier edificación de grandes dimensiones\n\n\n\n\nAplicaciones Antrópicas; deforestación"
  },
  {
    "objectID": "raster.html#manipulación-de-datos-raster-de-imágenes-satelitales.",
    "href": "raster.html#manipulación-de-datos-raster-de-imágenes-satelitales.",
    "title": "4  Datos tipo Raster",
    "section": "4.3 Manipulación de datos Raster de imágenes satelitales.",
    "text": "4.3 Manipulación de datos Raster de imágenes satelitales.\n\nLeer Archivos Raster (Imagen Satelital)\nVisualización Raster\nReproyectar imagen tipo Raster (Sistema de Referencia de Coords.)\nCortar Imagen Raster desde archivo Shapefile\nCombinacionaciones de Bandas Satelitales\n\n\n4.3.1 Leer Archivos Raster (Imagen Satelital)\n\n\n\n\nlibrary(raster)\nOLI &lt;- brick(\"data/raster/corte_rm_m.tif\")\nnames(OLI) &lt;- c(\"aerosol\", \"blue\", \"green\", \"red\", \"nir\", \"swir1\", \"swir2\", \"thermal\")\nOLI\n\n\n\nclass      : RasterBrick \ndimensions : 4830, 5978, 28873740, 8  (nrow, ncol, ncell, nlayers)\nresolution : 30, 30  (x, y)\nextent     : 249045, 428385, 6211135, 6356035  (xmin, xmax, ymin, ymax)\ncrs        : +proj=utm +zone=19 +south +datum=WGS84 +units=m +no_defs \nsource     : corte_rm_m.tif \nnames      :  aerosol,     blue,    green,      red,      nir,    swir1,    swir2,  thermal \nmin values : 7036.001, 6386.001, 5463.000, 4955.001, 4585.000, 4639.001, 4854.000, 4832.000 \nmax values :    49865,    52771,    59275,    56142,    59312,    59124,    54972,    14789 \n\n\n\n\n4.3.2 Visualización Raster\n\nplotRGB(OLI, r = 4, g = 3, b = 2, stretch = \"lin\")\n\n\n\n# viewRGB(OLI, r = 4, g = 3, b = 2)\n\n\n\n4.3.3 Cortar Imagen Raster desde archivo Shapefile\nLeer archivo vectorialde la Región Metropolitana\n\nlibrary(sf)\n\n# Leer geometrías Nacional y filtrar RM\nregion_met &lt;- st_read(\"data/shape/Comunas_Chile.shp\") %&gt;% \n  filter(REGION == \"13\")\n\nReading layer `Comunas_Chile' from data source \n  `/Users/denisberroeta/Library/CloudStorage/OneDrive-UniversidadAdolfoIbanez/Goblab/BDPP_Geoanalisis/geoanalisis_book/data/shape/Comunas_Chile.shp' \n  using driver `ESRI Shapefile'\nSimple feature collection with 346 features and 9 fields\nGeometry type: MULTIPOLYGON\nDimension:     XY\nBounding box:  xmin: -3701691 ymin: 3734031 xmax: 705926.2 ymax: 8065316\nProjected CRS: WGS 84 / UTM zone 19S\n\n# selección de Comuna\nmi_comuna &lt;-  \"LAS CONDES\"\ncomuna &lt;- region_met %&gt;% filter(NOM_COMUNA == mi_comuna)\n\n\nggplot() +\n  geom_sf(data = comuna, fill = NA, color =\"orange\", \n          alpha=0.8,  size= 1)+\n  ggtitle(paste0(\"COMUNA DE \", mi_comuna) ) +\n  theme_bw() +\n  theme(panel.grid.major = element_line(colour = \"gray80\"), \n        panel.grid.minor = element_line(colour = \"gray80\"))\n\n\n\n\nRealizar el corte de la comuna que seleccione\n\ncomuna_img &lt;- mask(crop(OLI, extent(comuna), snap=\"out\"), comuna)\ncomuna_img\n\nclass      : RasterBrick \ndimensions : 449, 562, 252338, 8  (nrow, ncol, ncell, nlayers)\nresolution : 30, 30  (x, y)\nextent     : 350505, 367365, 6293905, 6307375  (xmin, xmax, ymin, ymax)\ncrs        : +proj=utm +zone=19 +south +datum=WGS84 +units=m +no_defs \nsource     : memory\nnames      : aerosol,  blue, green,   red,   nir, swir1, swir2, thermal \nmin values :    8465,  7604,  6500,  5924,  5520,  5191,  5197,    5002 \nmax values :   19119, 20517, 21248, 23237, 29344, 30012, 31166,    5512 \n\nplotRGB(comuna_img, r = 4, g = 3, b = 2, stretch = \"lin\")\n\n\n\n\n\ncomuna_img_df &lt;- as.data.frame(comuna_img[[-8]])\nsuppressMessages(library(tidyr))\n#Transformar una base con dos columnas \nbase &lt;- gather(na.omit(comuna_img_df), key = \"Banda\", value = \"Valor\")\n\nsuppressMessages(library(ggplot2))\nhist_bandas &lt;- ggplot(base, aes(Valor, fill = Banda)) +\n  geom_histogram(bins = 60) + facet_wrap( ~ Banda) + \n  theme(plot.subtitle = element_text(size = 10, hjust = 0.5),\n        axis.ticks = element_line(colour = \"gray10\"),\n        plot.title = element_text(size = 14, hjust = 0.5,\n        face = \"bold\", colour = \"gray30\"), \n        panel.background = element_rect(fill = \"gray98\")) +\n  labs(title = \"Histograma de las Bandas Espectrales Landsat 8\", \n       subtitle = mi_comuna)\n\n\n\nhist_bandas\n\n\n\n\n\n\n4.3.4 Reproyectar imagen tipo Raster (Sistema de Referencia de Coords.)\n\ncrs_latlon &lt;- \"+proj=longlat +datum=WGS84 +no_defs\"# geográficas o elipsoidales\ncrs_utm &lt;- \"+proj=utm +zone=19 +south +datum=WGS84 +units=m +no_defs\" # UTM o cartográficas\n\n# utm a latlon\ncomuna_img &lt;- projectRaster(comuna_img, crs = crs_latlon)\n\n# latlon a utm\ncomuna_img &lt;- projectRaster(comuna_img, crs = crs_utm)\n\n\n\n4.3.5 Combinacionaciones de Bandas Satelitales\n Referencias: https://mappinggis.com/2019/05/combinaciones-de-bandas-en-imagenes-de-satelite-landsat-y-sentinel/\n\n# Falso Color (7,6,4)\nplotRGB(comuna_img, r = 7, g = 6, b = 4, stretch = \"lin\")\n\n\n\n\n\n\n\n\n\n# Infrarojo (5,4,3)\nplotRGB(comuna_img, r = 5, g = 4, b = 3, stretch = \"lin\")\n\n\n\n\n\n\n\n\n\n# Agricultura (6,5,2)\nplotRGB(comuna_img, r = 6, g = 5, b = 2, stretch = \"lin\")\n\n\n\n\n\n\n\n\n\n# Penetración de la Radiación en la Atmósfera (7,6,5)\nplotRGB(comuna_img, r = 7, g = 6, b = 5, stretch = \"lin\")\n\n\n\n\n\n\n\n\n\n# Uso del Suelo / Masas de Agua (5,6,4)\nplotRGB(comuna_img, r = 5, g = 6, b = 4, stretch = \"lin\")\n\n\n\n\n\n\n\n\n\n# Infrarojo de Onda Corta (7,5,4)\nplotRGB(comuna_img, r = 7, g = 5, b = 4, stretch = \"lin\")\n\n\n\n\n\n\n\n\n\n# Análisis de Vegetación (6,5,4)\nplotRGB(comuna_img, r = 6, g = 5, b = 4, stretch = \"lin\")\n\n\n\n\n\n\n\n\n\n# Análisis de Vegetación Sana (5,6,2)\nplotRGB(comuna_img, r = 5, g = 6, b = 2, stretch = \"lin\")"
  },
  {
    "objectID": "raster.html#construcción-de-indicadores-ambientales",
    "href": "raster.html#construcción-de-indicadores-ambientales",
    "title": "4  Datos tipo Raster",
    "section": "4.4 Construcción de Indicadores ambientales",
    "text": "4.4 Construcción de Indicadores ambientales\n\nCalcular NDVI\nCalcular Indicador Cobertura Vegetacional\n\n\n4.4.1 Calcular NDVI\n\n\n\nFórmula para el cáculo de NDVI\n\n\nCreación de la función de NDVI\n\n#NDVI(img, red, NIR)\nNDVI &lt;- function(img, i, k) {\n   bi &lt;- img[[i]]\n   bk &lt;- img[[k]]\n   vi &lt;- (bk - bi) / (bk + bi)\n   return(vi)\n}\n\n\nNDVI_com &lt;- NDVI(comuna_img, 4, 5)\n\nVisualización de NDVI en ggplot2\n\n# rastero to df (na omit)\nNDVI_com_df &lt;- raster::as.data.frame(NDVI_com, xy = TRUE) %&gt;% na.omit()\n\n#paleta\npal_ndvi&lt;- colorRampPalette(c(\"gray20\", \"yellow\", \"green\",\"springgreen4\"))( 200 )\n\nggplot() +\n  geom_raster(data = NDVI_com_df , \n             aes(x = x, y = y, \n                  fill = layer)) + \n  scale_fill_gradientn(name = \"NDVI\", colors = pal_ndvi)+\n  coord_fixed()+\n  ggtitle(paste0(\"NDVI DE \", mi_comuna) ) +\n  theme_bw() +\n  theme(panel.grid.major = element_line(colour = \"gray80\"), \n        panel.grid.minor = element_line(colour = \"gray80\"))\n\n\n\n\n\n\n4.4.2 Calcular Indicador de Cobertura Vegetacional\nSe ha estudiado que el umbral de valores de NDVI superiores a 0.4 se entienede como vegetación y sana\n\nhist(NDVI_com, col=\"springgreen4\", main=\"Histograma NDVI\",\n  ylab=\"Número de Pixeles\", xlab=\"valor NDVI\")\n\n\n\n\nFigure 4.1: Histograma de valores de NDVI\n\n\n\n\nConsiderando el gráfico anterior se deberá crear una función para definir umbral y eliminar (transformar NA) los valores de pixeles que esten bajo ese umbral.\n\n#función para definir umbral\ncorte_eq_may &lt;- function(value) {\n  function(x) {\n    ifelse(x &gt;= value, 1, NA)\n  }\n}\n\n\nlibrary(mapview)\n\nmapview(NDVI_com, na.color = \"transparent\")\n\n\n\n\n\nAplicación de la función para definir umbral utilizando calc():\n\nvegetacion &lt;- calc(NDVI_com, fun = corte_eq_may(value = 0.30))\n\n\nvegetacion_df &lt;- raster::as.data.frame(vegetacion, xy = TRUE) %&gt;% na.omit()\nggplot() +\n  geom_sf(data = comuna, fill = NA, color =\"orange\", \n          alpha=0.8,  size= 0.5)+\n  geom_raster(data = vegetacion_df , \n             aes(x = x, y = y, \n                  fill = layer)) + \n  scale_fill_gradientn(name = \"Veg\", colors = \"springgreen4\")+\n  ggtitle(paste0(\"VEGETACIÓN DE \", mi_comuna) ) +\n  theme_bw() +\n  theme(panel.grid.major = element_line(colour = \"gray80\"), \n        panel.grid.minor = element_line(colour = \"gray80\"))\n\n\n\n\nVisualización Dinámica\n\nmview &lt;- mapview(vegetacion, na.color = \"transparent\", \n                 col.regions = \"springgreen4\", legend =FALSE)+\n  mapview(comuna, color = \"magenta\", alpha.region =0, size = 2,\n          legend =FALSE)\nmview\n\n\n\n\n\n\n\n\nCrear Indicador por manzana:\n\nPara esto se debe contar los pixeles que existe por manzana calcular su superficie sabiendo la resolución espacila (30x30) y dividirla por el toral de superficie de la manzana, afin de obtener un porcentaje de cobertura vegetal por manzana.\n\n\nLeer manzanas del Censo\n\nmz_comuna &lt;- readRDS(\"data/censo/manzanas.rds\") %&gt;% \n  filter(NOM_COM == mi_comuna) %&gt;% \n  st_transform(32719)\n\nCalcular el área por cada polígono\n\nmz_comuna &lt;-  mz_comuna %&gt;% \n  mutate(AREA = as.numeric(st_area(.))) #mts2\n\nContar los piexeles por manzana y multiplicar por área que representan estos pixeles. Para contar la cantidad de pixeles por manzana usaremos la función exacextract()\n\nlibrary(exactextractr)\n\nmz_comuna  &lt;- mz_comuna %&gt;% \n  mutate(pix_veg = exact_extract(vegetacion,y = ., 'sum', progress = FALSE)) %&gt;% \n  mutate(area_veg = pix_veg * 30 * 30) %&gt;% # resolución espacial landsat (30*30)\n  mutate(ICV = round((area_veg /AREA)*100, 1))  \n\nVisualización del Indicador\n\nggplot() +\n  geom_sf(data = mz_comuna, aes(fill = ICV), color =\"gray70\", \n          alpha=0.8,  size= 0.1)+\n  scale_fill_distiller(palette= \"Greens\", direction = 1)+\n  ggtitle(\"Indicador de Cobertura Vegetal (ICV) - Urbano\") +\n  theme_bw() +\n  theme(panel.grid.major = element_line(colour = \"gray80\"), \n        panel.grid.minor = element_line(colour = \"gray80\"))"
  },
  {
    "objectID": "inferencia.html#objetivos-del-módulo",
    "href": "inferencia.html#objetivos-del-módulo",
    "title": "5  Inferencia Espacial",
    "section": "5.1 Objetivos del Módulo",
    "text": "5.1 Objetivos del Módulo\n\n\n\nObjetivos del Módulo\n\n\n\nConocer los fundamentos teóricos de la inferencia espacial\nConstrucción Indicadores en base de Kernel Density Estimation (KDE)\nConstrucción Indicadores en base de Interpolación Inverso a la Distancia ponderada (IDW)"
  },
  {
    "objectID": "inferencia.html#kernel-density-estimation",
    "href": "inferencia.html#kernel-density-estimation",
    "title": "5  Inferencia Espacial",
    "section": "5.2 Kernel Density Estimation",
    "text": "5.2 Kernel Density Estimation\n\n5.2.1 Introducción\nIdentificar el tipo de distribución que tiene a una variable es un paso fundamental en prácticamente todos los estudios que implican datos, son muchas las ventajas que tiene disponer de una función que describa aproximadamente los datos. Por ejemplo, se puede calcular la probabilidad (o densidad en el caso de variables aleatorias continuas) de que una observación tome un determinado valor. También es posible simular nuevos. valores.\nEn términos generales, ajustar una distribución consiste en encontrar una función matemática capaz de describir un conjunto de datos. De entre todas las posibles funciones candidatas, lo interesante es encontrar aquella que, con mayor probabilidad, puede haber generado los datos observados.\nUna de las aproximaciones más prácticas es utilizar como candidatas distribuciones paramétricas, estas son distribuciones conocidas cuyo comportamiento está determinado usando un número finito de parámetros. Por ejemplo, la distribución normal está parametrizada por la media y la desviación típica.\nCuando ninguna de las distribuciones paramétricas disponibles describe correctamente los datos, es necesario recurrir lo que se conoce como métodos de ajuste no paramétricos, cuyo objetivo es encontrar funciones que describan distribuciones cualesquiera, entendiendo por cualesquiera a que no se limitan a las distribuciones paramétricas conocidas. Uno de los métodos más empleados es kernel density estimation (KDE).\n\n\n5.2.2 Conceptos relacionados KDE en general\nEn estadística, kernel density estimation (KDE), es un método no paramétrico que permite estimar la función de densidad de probabilidad de una variable aleatoria a partir de un número finito de observaciones (muestra). Fué propuesto por Fix y Hodges (1951) y Rosenblatt (1956).\nUna forma de entender cómo funciona un kernel density estimation (KDE) es partiendo del histograma. El histograma es una de las formas más utilizadas en estadística para representar la distribución de datos unidimensionales.\n\n\n\nHistograma de una variable aleatoria bimodal\n\n\nEl Kernel density estimation (KDE) expande la idea del histograma, “cada observación aumenta la densidad de probabilidad en la zona donde se encuentra”, pero lo hace de forma que las contribuciones se agrupen creando una curva continua y suave (smooth).\n\n\n\nObservaciones y sus posiciones ordenadas\n\n\nA continuación, sobre cada observación se centra una distribución normal, con media igual al valor de la observación y desviación típica de 1 (más adelante se detalla la elección de este valor).\n\n\n\nDistribución normal por cada observaciones con media igual valor y desviación estándar = 1\n\n\nDe esta forma se consigue que cada observación contribuya justo en la posición que ocupa pero también, de forma gradual, en las regiones cercanas.\nPor último, si se suman las contribuciones individuales y se dividen por el total de curvas (observaciones), se consigue una curva final que describe la distribución de las observaciones.sy\n\n\n\nSuma de las Distribuciones\n\n\nEn esta idea se fundamenta el método kernel density estimation (KDE): aproximar una función de densidad como la suma de funciones (kernel) de cada observación.\nDefinición matemática\nDado un conjunto de datos x={x_1,x_2,...,x_n} la función de distribución de densidad f(x) puede aproximarse utilizando un kernel density estimation (KDE) tal que:\n\n\\hat{f}(x)=\\frac{1}{n}\\sum_{i = 1}^{n}K_h(x-x_i)= \\frac{1}{nh}\\sum_{i = 1}^{n}K\\left(\\frac{x-x_i}{h}\\right)\n * n: es el número de datos (observaciones). Cada uno de ellos es el centro sobre el que se coloca un kernel.\n\nh: es el ancho de banda (bandwidth o smoothing parameter). Controla cuánto se expande la influencia de cada observación. Si se emplea como kernel una distribución normal, equivale a la desviación típica. Este es el valor más determinante a la hora de ajustar un KDE, puesto que condiciona el nivel de sobreajuste.\nK: es el Kernel, una función que define la forma y la distribución de la influencia (peso) que se asocian a cada observación. En los ejemplos anteriores se ha utilizado como kernel la distribución normal.\n\nSelección de Ancho de Banda\nEl ancho de banda es crucial a la hora de estimar una función densidad mediante el método KDE. Si su valor es muy bajo, se genera overfitting y la función resultante estará demasiado influenciada por el “ruido” de los datos. Si su valor es muy elevado, la función resultante no será capaz de aprender la distribución subyacente.\n\n\n\nTipos de Distribuciones de acuerdo a valor de ancho de Banda\n\n\nReglas empíricas\n\nScott’s rule: h≈1.06 \\cdot \\hat{\\sigma}n^{−1/5}\nSilverman’s rule: h=0.9\\cdot min(\\hat{\\sigma},IQR/1.35)n^{−1/5}\n\nSi bien estos métodos son muy rápidos, tienen el limitante de funcionar bien solo cuando la función de densidad real es aproximadamente normal.\nTambién se puede usar validación cruzada que requiere de mayor tiempo de computación pero es útil para cualquier tipo de distribución. Validación cruzada es la opción disponible en Scikit learn, utilizando como métrica de comparación en log-likelihood.\nEs importante destacar que, cuando se dispone de pocos datos, conviene utilizar one leave out crossvalidation.\nTipos de kernel\nEl kernel es la función que determina cómo se distribuye la influencia de cada observación, por lo tanto, puede tener un impacto notable en la estimación de la función de densidad resultante. Aunque en la gran mayoría de casos se emplea un kernel gaussiano (distribución normal), existen otras posibilidades.\n\nGaussian: asigna los pesos siguiendo la distribución normal con una desviación estándar equivalente al ancho de banda.\nEpanechnikov: las observaciones que están a una distancia entre 0 y h tienen un peso entre \\frac{3}{4} y 0 con disminución cuadrática. Toda observación fuera de este rango tiene pero 0.\nTophat: Asigna el mismo peso a todas las observaciones que estén dentro del ancho de banda.\nExponential: el peso decae de forma exponencial.\nLinear: el peso decae de forma lineal dentro del ancho de banda. Más allá de este el pero es 0.\nCosine: el peso dentro del ancho de banda es proporcional al coseno.\n\n\n\n\nAlgunos tipos de Kernel más utilizados\n\n\nTO-DO: Agregar formulas de cada Kernel\n\n\n5.2.3 KDE aproximación espacial\nPara entender el concepto KDE se presentó anteriormente en su forma básica correspondiente a una distribución univariada, como por ejemplo la distribución (bimodal) siguiente:\n\n\n\nDistribución Univariada\n\n\nPara aplicar los KDE a casos espaciales, se tiene que entender que las variables aleatorias antes señaladas, ahora van a corresponder a eventos o condiciones físicas que ocurren en el espacio, por ende bajo un sistema de coordenadas, por lo cual el eje de coordenadas x e y que también intervienen como nuevas dimensiones, entonces los que se predente estimar una distribución multivariante.\n\n\n\nDe puentos espaciales a Mapa de Densidad.\n\n\nUna de las aplicaciones más comunas es de el análisis criminal, ya que los algunas categorías delitos coproducen bajo ciertas condiciones espaciales.\n\n\n\nEjemplo de Kernel Density Estimation de Delitos en Domicilios en la Comuna de Las Condes\n\n\nEntonces para el caso espacial lo que se prentende identificar patrones de cluster basándose en proximidad espacial\nLos elementos del KDE Univariado tambien están presentes en el caso espacial como por ejemplo en ancho debanda como se observa a continuación.\n\n\n\nKDE Espacial con diferentes tipos de Ancho de Banda.\n\n\n\n\n5.2.4 Kernel Density Estimation en delitos Violentos\nExiste una gama importante de métodos de interpolación como el Kriging, las superficies de tendencia, el inverso de la distancia y los modelos de regresión local, (Anselin, 1992; Clevelend at al. 1993, Venables & Ripley, 1997) los cuales requieren en su mayoría que los puntos de muestreo/entrada asuman valores heterogéneos diferentes de cero.\nConsiderando que los dato con que se trabajará son eventos delictivos, por ensde no se hace muetreo de la información, el universo está dado por la totalidad de los eventos registrados, adicionalmente cada punto representa un evento particular.\nComo no en toda la superficie de una zona de estudio han sucedido delitos, pero existe una probabilidad de que ocurran, la estimación de densidad de kernel sirve para calcular esa probabilidad (Smith & Bruce 2008, 60-64) de modo que la interpolación produce “superficies de riesgo”.\n\n\n\nSuma de funciones normales de Kernel de 5 Puntos\n\n\nFuente: Estimación de densidad de Kernel. Adaptado de Wilson, R. y Eck, J. (2005: 27).\nCargar Librerías\n\nlibrary(rgdal)\nlibrary(sf)\nlibrary(dplyr)\nlibrary(rgeos)\nlibrary(raster)\nlibrary(spatstat)\nlibrary(spdep)\nlibrary(mapview)\nlibrary(viridis)\nlibrary(ggplot2)\n\nLectura de casos violencia (Las Condes, anonimizados)\n\nviolencia_df &lt;- readRDS(file = \"data/delitos/casos_violencia.rds\")\nhead(violencia_df)\n\n     id        x       y\n4423  1 351501.2 6301276\n4836  2 359214.9 6303245\n4837  3 351866.6 6301303\n4844  4 351303.1 6301359\n4916  5 351536.6 6301306\n5125  6 357105.9 6301723\n\n\nTransformar a Objeto Espacial\n\nviolencia &lt;-  st_as_sf(x = violencia_df, \n                          coords = c(\"x\", \"y\"), crs = 32719)\n\nggplot() +\n  geom_sf(data = violencia,  color =  \"red\", \n          alpha=0.8,  size= 0.1)+\n  ggtitle(\"Delitos Violentos en Las Condes\") +\n  theme_bw() +\n  theme(panel.grid.major = element_line(colour = \"gray80\"), \n        panel.grid.minor = element_line(colour = \"gray80\"))\n\n\n\n\nKDE con Raster\nCalcular KDE con Función cuartica o esférica (quartic)\nSupone una distribución relativamente uniforme que al llegar a cierto umbral decae sin suavidad:\n\n\n\nKernel cuártica o esférica\n\n\nDefinir Parámetros\n\nlibrary(SpatialKDE)\n\n#Definirán Parámemetros de Estudio\ncell_size &lt;- 100 # Tamaño de Celda\nband_width &lt;- 500 #  Parámetro de Suavisado (denominada ventana o h)\n\nCrear Raster Vacío\n\nraster_violencia &lt;- violencia %&gt;% \n  create_raster(cell_size = cell_size, side_offset = band_width)\n\nCrear Kernel raster\n\nkde_raster &lt;- violencia %&gt;% \n  kde(band_width = band_width, kernel = \"quartic\", grid = raster_violencia)\n\n\nDone: [--------------------------------------------------------------------] .\nDone: [=====---------------------------------------------------------------] .\nDone: [======--------------------------------------------------------------] .\nDone: [=======-------------------------------------------------------------] .\nDone: [========------------------------------------------------------------] .\nDone: [=========-----------------------------------------------------------] .\nDone: [==========----------------------------------------------------------] .\nDone: [===========---------------------------------------------------------] .\nDone: [============--------------------------------------------------------] .\nDone: [=============-------------------------------------------------------] .\nDone: [==============------------------------------------------------------] .\nDone: [===============-----------------------------------------------------] .\nDone: [================----------------------------------------------------] .\nDone: [=================---------------------------------------------------] .\nDone: [==================--------------------------------------------------] .\nDone: [===================-------------------------------------------------] .\nDone: [====================------------------------------------------------] .\nDone: [=====================-----------------------------------------------] .\nDone: [======================----------------------------------------------] .\nDone: [=======================---------------------------------------------] .\nDone: [========================--------------------------------------------] .\nDone: [=========================-------------------------------------------] .\nDone: [==========================------------------------------------------] .\nDone: [===========================-----------------------------------------] .\nDone: [============================----------------------------------------] .\nDone: [=============================---------------------------------------] .\nDone: [==============================--------------------------------------] .\nDone: [===============================-------------------------------------] .\nDone: [================================------------------------------------] .\nDone: [=================================-----------------------------------] .\nDone: [==================================----------------------------------] .\nDone: [===================================---------------------------------] .\nDone: [====================================--------------------------------] .\nDone: [=====================================-------------------------------] .\nDone: [======================================------------------------------] .\nDone: [=======================================-----------------------------] .\nDone: [========================================----------------------------] .\nDone: [=========================================---------------------------] .\nDone: [==========================================--------------------------] .\nDone: [===========================================-------------------------] .\nDone: [============================================------------------------] .\nDone: [=============================================-----------------------] .\nDone: [==============================================----------------------] .\nDone: [===============================================---------------------] .\nDone: [================================================--------------------] .\nDone: [=================================================-------------------] .\nDone: [==================================================------------------] .\nDone: [===================================================-----------------] .\nDone: [====================================================----------------] .\nDone: [=====================================================---------------] .\nDone: [======================================================--------------] .\nDone: [=======================================================-------------] .\nDone: [========================================================------------] .\nDone: [=========================================================-----------] .\nDone: [==========================================================----------] .\nDone: [===========================================================---------] .\nDone: [============================================================--------] .\nDone: [=============================================================-------] .\nDone: [==============================================================------] .\nDone: [===============================================================-----] .\nDone: [================================================================----] .\nDone: [=================================================================---] .\nDone: [==================================================================--] .\nDone: [===================================================================-] .\nDone: [====================================================================] .\n                                                                              \n\n\nHistograma de valores de Densidad\n\nhist(kde_raster, col=\"springgreen4\", main=\"Histograma KDE\",\n  ylab=\"Número de Pixeles\", xlab=\"valor KDE\")\n\n\n\n# writeRaster(kde_raster, \"data/delitos/kde_delvio_LC.tif\")\n\nVisualizar Raster KDE con ggplot\n\n# rastero to df (na omit)\nkde_raster_df &lt;- raster::as.data.frame(kde_raster, xy = TRUE) %&gt;% na.omit()\n\numbral &lt;- 1\nkde_raster_df &lt;- kde_raster_df %&gt;% \n  mutate(layer = ifelse(layer &lt; umbral, NA, layer))\n\n\nggplot() +\n  geom_raster(data = kde_raster_df %&gt;% na.omit() , \n             aes(x = x, y = y, \n                  fill = layer)) + \n  scale_fill_gradientn(name = \"KDE\", \n                       colors = (viridis::magma(100)), na.value = NA)+\n  coord_fixed()+\n  ggtitle(paste0(\"KDE Raster de Delitos\") ) +\n  theme_bw() +\n  theme(panel.grid.major = element_line(colour = \"gray80\"), \n        panel.grid.minor = element_line(colour = \"gray80\"))\n\n\n\n\nFunción Para filtrar Raster (solo para tener en cuenta)\n\nna_menor &lt;- function(x){\n  x[x &lt; 10] &lt;- NA\n  return(x)\n}\nkde_raster2 &lt;- calc(kde_raster, fun = na_menor)\n\nKDE a Indicador Territorial\nLeer manzanas del Censo\n\nmi_comuna &lt;-  \"LAS CONDES\"\nmz_comuna &lt;- readRDS(\"data/censo/manzanas.rds\") %&gt;% \n  filter(NOM_COM == mi_comuna) %&gt;% \n  st_transform(32719)\n\nCálculo de Indicador de Delitos Violentos\n\nlibrary(exactextractr)\n\nmz_comuna  &lt;- mz_comuna %&gt;% \n  mutate(idelv = exact_extract(kde_raster,y = ., 'mean', \n                               progress = FALSE))\n\n# saveRDS(mz_comuna, \"data/delitos/idel_violentos_LC.rds\")\n\nVisualización del Indicador\n\n# pal_idelv&lt;- colorRampPalette(c(\"white\",  \"red\"))( 100 )\nggplot() +\n  geom_sf(data = mz_comuna, aes(fill = idelv), color =\"gray80\", \n          alpha=0.8,  size= 0.1)+\n  # scale_fill_gradientn(colors = pal_idelv)+\n  scale_fill_distiller(palette= \"Reds\", direction = 1)+\n  ggtitle(\"Indicador de Delitos Violentos\") +\n  theme_bw() +\n  theme(panel.grid.major = element_line(colour = \"gray80\"), \n        panel.grid.minor = element_line(colour = \"gray80\"))"
  },
  {
    "objectID": "inferencia.html#interpolación-inverso-a-distancia-ponderada-idw",
    "href": "inferencia.html#interpolación-inverso-a-distancia-ponderada-idw",
    "title": "5  Inferencia Espacial",
    "section": "5.3 Interpolación Inverso a Distancia Ponderada IDW",
    "text": "5.3 Interpolación Inverso a Distancia Ponderada IDW\n\n5.3.1 Definiciones\nEste tipo de interpolación, determina los valores de celda a través de una combinación ponderada linealmente de un conjunto de datos de puntos de muestra. Esto significa que los puntos de muestreo se ponderan de tal manera que la influencia de un punto frente a otro, disminuye con la distancia.\nCuanto más cerca está un punto del centro de la celda que se está estimando, más influencia o peso tendrá en el proceso de cálculo del promedio.\n\n\n\nEstimación de valores por interpolación de inverso a la distancia\n\n\nlos puntos rojos tienen valores de elevación conocidos. Los otros puntos serán interpolados. Si desea medir el punto púrpura, puede configurar su interpolación para que tome un número fijo o variable de puntos. En este ejemplo, utiliza un número fijo de 3 puntos de 3 y utiliza los tres puntos más cercanos.\n\n\n\nDescripción gráfica de los resultados de interpolación\n\n\nDado que la IDW es un promedio de distancia ponderada, el promedio no puede ser mayor que la entrada máxima o inferior que la entrada mínima. Por lo tanto, no puede crear crestas o valles si estos extremos aún no se han muestreado (Watson y Philip 1985).\n\n\n5.3.2 Usos prácticos\nPasos\n\nDefinición de Área de Estudio\nInterpolación de información Comercio y Oficina\nCrear Indicador de Atractor de Comercios y Oficina\n\nDesarrollo\nDefinición de Área de Estudio\nPara efectos de este ejemplo práctico se utilizará el área urbana de la comuna de Las Condes.\n\nmi_comuna &lt;-  \"LAS CONDES\"\nzonas &lt;-  readRDS(\"data/censo/zonas_urb_consolidadas.rds\")\ncomuna &lt;-  zonas %&gt;% filter(NOM_COMUNA == mi_comuna)\n\nVisualizaciíon de Área de Estudio\n\nggplot() +\n  geom_sf(data = comuna, aes(fill = ESC_JH), color =NA, \n          alpha=0.8,  size= 0.1)+\n  scale_fill_distiller(palette= \"YlGnBu\", direction = 1)+\n  ggtitle(\"Población Zonas Censales - Urbano\" ) +\n  theme_bw() +\n  theme(panel.grid.major = element_line(colour = \"gray80\"), \n        panel.grid.minor = element_line(colour = \"gray80\"))\n\n\n\n\nObtener el Borde comunal\n\ncomuna_border &lt;- comuna %&gt;% st_union()\n\n\nggplot() +\n  geom_sf(data = comuna_border, fill = \"gray90\", color =\"gray30\", \n          alpha=0.8,  size= 0.8)+\n  ggtitle(\"Borde Zonas Censales - Urbano\" ) +\n  theme_bw() +\n  theme(panel.grid.major = element_line(colour = \"gray80\"), \n        panel.grid.minor = element_line(colour = \"gray80\"))\n\n\n\n\nImputar información SII a zonas censales\nLectura de datos de SII (puntos)\n\nsii_ptos &lt;- st_read(\"data/sii/urbes.shp\", quiet = T)\n\nSelección de Comuna\n\ncomuna_sii &lt;-  sii_ptos %&gt;% filter(n_com == mi_comuna) %&gt;% \n  st_transform(32719)\n# comuna_sii\n\nVisualización de los Puntos del SII\n\nggplot() +\n  geom_sf(data = comuna_sii,  color =\"orange\", \n          alpha=0.8,  size= 0.5)+\n  ggtitle(\"Predios SII - Urbano\" ) +\n  theme_bw() +\n  theme(panel.grid.major = element_line(colour = \"gray80\"), \n        panel.grid.minor = element_line(colour = \"gray80\"))\n\n\n\n\nInterpolación de Inverso a la Distancia ponderada por Atractores (SII)\nDefinción ventana de trabajo\n\ncrs_utm &lt;- \"+proj=utm +zone=19 +south +datum=WGS84 +units=m +no_defs\" # 32719\nsuppressMessages(library(raster))\n# grilla desde mancha comuna\nurbano_utm &lt;- st_transform(comuna, crs_utm)\nurbano_sp &lt;- as(urbano_utm, \"Spatial\")\next &lt;- raster::extent(urbano_sp)\nx_min &lt;- ext[1] - 100\nx_max &lt;- ext[2] + 100\ny_min &lt;- ext[3] - 100\ny_max &lt;- ext[4] + 100\n\nDefinción grilla de interpolación**\n\n## Definir espaciado de interpolacion\ngrd=expand.grid(x = seq(from = x_min,to = x_max, by=100),\n                y = seq(from = y_min,to = y_max, by=100))\ncoordinates(grd)=~x+y\ngridded(grd)=T\nproj4string(grd)= \"+proj=utm +zone=19 +south +datum=WGS84 +units=m +no_defs\" # 32719\nplot(grd)\n\n\n\n\n\n\n\n\nCálculo de Interpolación de Inverso a la Distancia\n\n# Decsar Valores NA\nsii_sp &lt;- comuna_sii%&gt;%\n  st_transform(crs_utm) %&gt;% \n  filter(!is.na(atractor))%&gt;%\n  as(\"Spatial\")\n\n\ninterp_sii=gstat::idw(formula = sii_sp@data$atractor ~ 1, \n                 locations = sii_sp, \n                 newdata = grd, idp = 1,\n                 na.action = na.omit, nmax = 4)\n\n[inverse distance weighted interpolation]\n\n\nAjustes del Resultado\n\nAsiganar CRS\nTranformar valores NA a 0\nTransformar raster y cortar por contorno urbano\n\n\nproj4string(interp_sii) = proj4string(sii_sp) # Asignar crs\ninterp_sii@data[is.na(interp_sii@data)] = 0 # trasnformar los valores 0 en NA\ninterp_sii &lt;- mask(raster(interp_sii, values = T), urbano_sp) # cortar por borde comunal\n\nVisualización\n\ninterp_sii_df &lt;- raster::as.data.frame(interp_sii, xy = TRUE) %&gt;% na.omit()\n\nggplot() +\n  geom_raster(data = interp_sii_df , \n             aes(x = x, y = y, \n                  fill = var1.pred)) + \n  scale_fill_gradientn(name = \"IDW\", \n                       colors = (viridis::viridis(100)), na.value = NA)+\n  coord_fixed()+\n  ggtitle(paste0(\"IDW Atractores de Comercio y Oficina\") ) +\n  theme_bw() +\n  theme(panel.grid.major = element_line(colour = \"gray80\"), \n        panel.grid.minor = element_line(colour = \"gray80\"))\n\n\n\n\nCálculo de Indicador de Atractor IDW\n\nmz_comuna  &lt;- mz_comuna %&gt;% \n  mutate(atractor_sii = exact_extract(interp_sii,y = ., 'mean', \n                               progress = FALSE))\n\nVisualización del Indicador atractor_sii\n\nggplot() +\n  geom_sf(data = mz_comuna, aes(fill = atractor_sii), color =NA, \n          alpha=0.8,  size= 0.1)+\n  scale_fill_viridis_c()+\n  ggtitle(\"Indicador de Atractor de Comercio y Oficinas\") +\n  theme_bw() +\n  theme(panel.grid.major = element_line(colour = \"gray80\"), \n        panel.grid.minor = element_line(colour = \"gray80\"))"
  },
  {
    "objectID": "inferencia.html#referencias",
    "href": "inferencia.html#referencias",
    "title": "5  Inferencia Espacial",
    "section": "5.4 Referencias",
    "text": "5.4 Referencias\n\nAjuste de distribuciones con kernel density estimation y Python\nRole of Big Data in the Development of Smart City by Analyzing the Density of Residents in Shanghai\nHow Is the Confidentiality of Crime Locations Affected by Parameters in Kernel Density Estimation?\nIDW (Spatial Analyst)\nIMPORTANCIA DE LOS ESPACIOS COMUNES: UNA ADAPTACIÓN DE LA TÉCNICA DE INTERPOLACIÓN ESPACIAL INVERSE DISTANCE WEIGHTED (IDW) EN LA PREDICCIÓN DE DATOS SOCIOECONÓMICOS AUSENTES"
  },
  {
    "objectID": "autocorrelacion.html#objetivos-del-módulo",
    "href": "autocorrelacion.html#objetivos-del-módulo",
    "title": "6  Autocorrelación Espacial",
    "section": "6.1 Objetivos del Módulo",
    "text": "6.1 Objetivos del Módulo\n\n\n\nObjetivos del Módulo\n\n\n\nConceptos Generales de Autocorrelación Espacial\nDefinición de Matrices de vecindad\nCálculo de índice de Moran (global y local)"
  },
  {
    "objectID": "autocorrelacion.html#conceptos-generales-de-autocorrelación-espacial",
    "href": "autocorrelacion.html#conceptos-generales-de-autocorrelación-espacial",
    "title": "6  Autocorrelación Espacial",
    "section": "6.2 Conceptos Generales de Autocorrelación Espacial",
    "text": "6.2 Conceptos Generales de Autocorrelación Espacial\n\n6.2.1 Introducción\nLa primera ley de la geografía de Tobler: “Todo está relacionado con todo lo demás, pero las cosas cercanas están más relacionadas que las lejanas” no se cumple de siempre de forma absoluta. Es y ha sido siempre una simplificación excesiva, que encubre posibles problemas subyacentes de entitación, apoyo y otros errores de especificación. ¿Son las unidades de observación apropiadas para la escala del proceso espacial subyacente? ¿Podría explicarse el patrón espacial de la variable de interés para la entitación elegida mediante otra variable?\nTeniendo lo anterior como contexto, existe un test estadístico que nos permite estimar bajo ciertas condiciones evidencia la autoproducción espacial llamado I de Moran es posiblemente el indicador más utilizado de autocorrelación espacial global y para ampliamente utilizado para en temáticas segregación o clusterización social. Fue sugerido inicialmente por P. Moran (1948) y popularizado a través del trabajo clásico sobre autocorrelación espacial de Cliff and Ord (1972).\nA continuación se realizará un análisis teórico y práctico de las diferentes técnicas de autocorrelación espacial usado en ciencias sociales, en particular haciendo usos de Índice de Moran y todos los tratamientos previos. Se tratará evidenciar estadísticamente si existe agrupamiento o segregación por nivel Socieconómico en la una comuna de Chile, haciendo uso del nivel de años de estudio de jefe de hogar, más aún, identificar espacialmente donde se ubican estas concentraciones tanto de ingresos alto como bajos.\nPasos:\n\nPreparación de Datos\nMatriz de Vecindad\nIndicador de Global Moran\nIndicador de Local Moran"
  },
  {
    "objectID": "autocorrelacion.html#prepararación-de-datos",
    "href": "autocorrelacion.html#prepararación-de-datos",
    "title": "6  Autocorrelación Espacial",
    "section": "6.3 Prepararación de Datos",
    "text": "6.3 Prepararación de Datos\nCargar Librerías\n\nlibrary(dplyr)\nlibrary(sf)\nlibrary(ggplot2)\nlibrary(raster)\nlibrary(mapview)\nlibrary(spdep)\nlibrary(spatstat)\n\nLectura de Manzanas Censales\nSe procede a leer las manzanas censales y se filtra la comuna objeto de estudio, para efecto de este documento se seleccionará la comuna de LAS CONDES.\n\nmi_comuna &lt;-  \"LAS CONDES\"\nmz_comuna &lt;- readRDS(\"data/censo/manzanas.rds\") %&gt;% \n  filter(NOM_COM == mi_comuna) %&gt;% \n  st_transform(32719)\n\nEliminar valores Nulos\nEs procedimiento es clave para realizar los cálculos posteriores, por lo cual se debe eliminar las manzanas sin registros de población y por ende sin registro de escolaridad del jefe de hogar.\n\nmz_comuna &lt;-  mz_comuna %&gt;% \n  mutate(nived = JH_ESC_P) %&gt;% # Usaremos variable auxiliar de nivel educacional\n  filter(!is.na(nived))\n\nVisualización del Escolaridad del Jefe de Hogar\n\nggplot() +\n  geom_sf(data = mz_comuna, aes(fill = nived), color =\"gray80\", \n          alpha=1,  size= 0.1)+\n  scale_fill_distiller(palette= \"YlGnBu\", direction = 1)+\n  ggtitle(\"Nivel Educacional del Jefe de Hogar\") +\n  theme_bw() +\n  theme(plot.title = element_text(size=12))+\n  theme(panel.grid.major = element_line(colour = \"gray80\"), \n        panel.grid.minor = element_line(colour = \"gray80\"))"
  },
  {
    "objectID": "autocorrelacion.html#construcción-de-la-matriz-de-vecindad",
    "href": "autocorrelacion.html#construcción-de-la-matriz-de-vecindad",
    "title": "6  Autocorrelación Espacial",
    "section": "6.4 Construcción de la Matriz de Vecindad",
    "text": "6.4 Construcción de la Matriz de Vecindad\nLa matriz de vecindad W_{ij} es un elemento central de la estadística y el análisis espacial es la cercanía y la distancia, a partir de la cual definimos que elementos cercanos, o vecinos.\nMatemáticamente se puede expresar si ciertos elementos son continuos:\nW=(w_{ij}:i,j=1,...,n)\nDonde los el valor de w_ij expresa la relación de vecindad entre los elementos i y j:\nw_{ij} = \\begin{cases}1 \\space vecino \\\\\n0 \\space no \\space vecino\n\\end{cases}\nComo ilustración, si tuviéramos 3 observaciones y una matriz de la siguiente forma:\nW=\\begin{pmatrix}\nw_{11} & w_{12} & w_{13} \\\\\nw_{21} & w_{22} & w_{23} \\\\\nw_{31} & w_{32} & w_{33}\n\\end{pmatrix}=\\begin{pmatrix}\n1 &  0 & 0 \\\\\n1 &  1 & 0 \\\\\n1 &  0 & 0\n\\end{pmatrix}\nPolígonos a puntos\n\nptos_comuna &lt;- mz_comuna%&gt;%\n  st_geometry() %&gt;%\n  st_centroid()\n\nggplot() +\n  geom_sf(data = ptos_comuna,  color =\"#525252\", alpha=1,  size= 0.5)+\n  ggtitle(\"Puntos Centroides de Manzanas\") +\n  theme_bw() +\n  theme(plot.title = element_text(size=12))+\n  theme(panel.grid.major = element_line(colour = \"gray80\"), \n        panel.grid.minor = element_line(colour = \"gray80\"))\n\n\n\n\nCálculo de K Vecinos\nAunque existen muchas de construir una matriz de vecindad, para los efectos prácticos usaremos el algoritmo K Vecinos más Cercanos conocido de knn (K Nearest Neightbours).\nPara definir la vecindad se calcula la distancia desde un origen una centroide de manzana cualquiera respecto a todas las demás, quedando con las k distancias mas cortas.\nDistancia Euclidiana:  Para calcular la separación entre dos puntos la distancia Euclidiana es la más utilizada y se define matemáticamente con la siguiente ecuación (Equation 6.1):\nd_{ij}= \\sqrt{(x_i-x_j)^2+(y_i-y_j)^2} \\tag{6.1}\nEs la distancia “ordinaria” entre dos puntos de un espacio euclídeo, la cual se deduce a partir del teorema de Pitágoras.\n\n\n\nRepresentación gráfica de la Distancia Euclediana\n\n\nDistancia Great Circle: El el tipo de distancia que utiliza cuando las objetos espaciales se encuentran coordenadas geográfica ya que considera la curvatura de la tierra.\n\n\n\nDistancia Great Circle\n\n\nCalcular Vecinos Cercanos (k)\n\n# vecinos mas cercanos (neighbours)\nk &lt;- 8 # numero de vecinos a buscar\nnb_mzs &lt;- knearneigh(ptos_comuna, k = k) %&gt;%  # por punto calcula K vecinos\n  knn2nb() # Knn a matriz de vecindad\n\nVisualización de la relaciones por cada Centroide\n\n# matri&lt; de vecindad a lines solo oara visualizaciñon\nneighbors_sf &lt;- as(nb2lines(nb_mzs, coords = st_geometry(ptos_comuna)), 'sf')\n\np_mv &lt;- ggplot() +\n  geom_sf(data = mz_comuna, fill = NA, color =\"gray60\", alpha=1,  size= 0.3)+\n  geom_sf(data = neighbors_sf,  color = \"red\", alpha=0.5,  size= 0.5)+\n  geom_sf(data = ptos_comuna,  color =\"#525252\", alpha=1,  size= 1)+\n  ggtitle(\"Relaciones de Vecindad por cada manzana (k = 8)\") +\n  theme_bw() +\n  theme(plot.title = element_text(size=12))+\n  theme(panel.grid.major = element_line(colour = \"gray80\"), \n        panel.grid.minor = element_line(colour = \"gray80\"))\n\np_mv\n\n\n\n\nRevisión de la Matriz\nSolo para ver la estructura de relaciones, correspondiente una matriz simétrica n \\times n donde la diagonal es 0. El valor 0 representa no relación y 1 relación o conexión.\n\n# relaciones entre 10 primeros elementos\nmatriz_vec &lt;- listw2mat(nb2listw(nb_mzs, style = \"B\"))\ndim(matriz_vec)\n\n[1] 1474 1474\n\n# rowSums(matriz_vec) %&gt;% max()\n\n\n\n\nEstrucutura de una Matriz de Distancia\n\n\n\nmatriz_vec[1:10,1:10]\n\n   [,1] [,2] [,3] [,4] [,5] [,6] [,7] [,8] [,9] [,10]\n1     0    1    1    1    1    0    0    1    0     1\n2     1    0    1    1    1    0    0    1    0     1\n3     1    1    0    0    1    0    0    1    0     1\n4     1    0    0    0    1    1    1    1    0     1\n5     1    1    0    1    0    1    0    1    0     1\n6     1    0    0    1    1    0    1    1    0     0\n7     0    0    0    1    1    1    0    1    0     0\n8     1    1    1    0    1    0    0    0    0     1\n9     0    0    0    0    1    0    0    1    0     1\n10    1    0    1    0    1    0    0    1    1     0\n\n\nAsignar Pesos por Población\nAhora a la matriz de vecindad le vamos a convertir en una matriz de pesos y para nuestro caso vamos asignar los pesos por población, asumiendo que la influencia por cercanía espacial sería proporcional a la cantidad de personas.\n\nnb &lt;-nb2listw(nb_mzs)\nmz_comuna$id &lt;- 1:nrow(mz_comuna)\n\n# Estado actual (todos los vecinos pesan lo mismo)\nnb$weights %&gt;% head(5)\n\n[[1]]\n[1] 0.125 0.125 0.125 0.125 0.125 0.125 0.125 0.125\n\n[[2]]\n[1] 0.125 0.125 0.125 0.125 0.125 0.125 0.125 0.125\n\n[[3]]\n[1] 0.125 0.125 0.125 0.125 0.125 0.125 0.125 0.125\n\n[[4]]\n[1] 0.125 0.125 0.125 0.125 0.125 0.125 0.125 0.125\n\n[[5]]\n[1] 0.125 0.125 0.125 0.125 0.125 0.125 0.125 0.125\n\n\nEl siguiente bloque de código a través de un proceso iterativo identifica el id de cada uno de los 8 vecinos, captura la población y le asigna la proporción respecto a la suma de personas de las manzanas de los 8 vecinos.\n\nnb$weights = lapply(1:nrow(mz_comuna), function(i)\n  mz_comuna$POBLACION[mz_comuna$id %in% nb$neighbours[[i]]] / \n    sum(mz_comuna$POBLACION[mz_comuna$id %in% nb$neighbours[[i]]]))\n\nnb$weights %&gt;% head(5)\n\n[[1]]\n[1] 0.06053812 0.28699552 0.11210762 0.21973094 0.11883408 0.05381166 0.06950673\n[8] 0.07847534\n\n[[2]]\n[1] 0.41724618 0.17802503 0.06954103 0.13630042 0.07371349 0.03337969 0.04311544\n[8] 0.04867872\n\n[[3]]\n[1] 0.48231511 0.04340836 0.15755627 0.08520900 0.03858521 0.04983923 0.08681672\n[8] 0.05627010\n\n[[4]]\n[1] 0.38119441 0.12452351 0.21092757 0.10165184 0.06734435 0.03049555 0.03939009\n[8] 0.04447268\n\n[[5]]\n[1] 0.43731778 0.03935860 0.07288630 0.24198251 0.07725948 0.03498542 0.04518950\n[8] 0.05102041\n\n\nVolvamos a revisar la matriz de distancia pero ponderada por población.\n\n# relaciones entre 10 primeros elementos\nmatriz_vec_pond &lt;- listw2mat(nb)\ndim(matriz_vec_pond)\n\n[1] 1474 1474\n\n# rowSums(matriz_vec_pond)\n\nmatriz_vec_pond[1:10,1:10]\n\n        [,1]       [,2]      [,3]       [,4]      [,5]      [,6]      [,7]\n1  0.0000000 0.06053812 0.2869955 0.11210762 0.2197309 0.0000000 0.0000000\n2  0.4172462 0.00000000 0.1780250 0.06954103 0.1363004 0.0000000 0.0000000\n3  0.4823151 0.04340836 0.0000000 0.00000000 0.1575563 0.0000000 0.0000000\n4  0.3811944 0.00000000 0.0000000 0.00000000 0.1245235 0.2109276 0.1016518\n5  0.4373178 0.03935860 0.0000000 0.07288630 0.0000000 0.2419825 0.0000000\n6  0.4267425 0.00000000 0.0000000 0.07112376 0.1394026 0.0000000 0.1137980\n7  0.0000000 0.00000000 0.0000000 0.09727626 0.1906615 0.3229572 0.0000000\n8  0.4304161 0.03873745 0.1836442 0.00000000 0.1406026 0.0000000 0.0000000\n9  0.0000000 0.00000000 0.0000000 0.00000000 0.0798696 0.0000000 0.0000000\n10 0.3521127 0.00000000 0.1502347 0.00000000 0.1150235 0.0000000 0.0000000\n         [,8]      [,9]      [,10]\n1  0.11883408 0.0000000 0.05381166\n2  0.07371349 0.0000000 0.03337969\n3  0.08520900 0.0000000 0.03858521\n4  0.06734435 0.0000000 0.03049555\n5  0.07725948 0.0000000 0.03498542\n6  0.07539118 0.0000000 0.00000000\n7  0.10311284 0.0000000 0.00000000\n8  0.00000000 0.0000000 0.03443329\n9  0.04319478 0.0000000 0.01955990\n10 0.06220657 0.1795775 0.00000000"
  },
  {
    "objectID": "autocorrelacion.html#cálculo-de-índice-de-morán-global-y-local",
    "href": "autocorrelacion.html#cálculo-de-índice-de-morán-global-y-local",
    "title": "6  Autocorrelación Espacial",
    "section": "6.5 Cálculo de índice de Morán (global y local)",
    "text": "6.5 Cálculo de índice de Morán (global y local)\n\n6.5.1 Índice de Moran\nPara efectos del presente curso el indicador se utilizará como test para evidenciar la segregación que pueda existir en el territorio, entendiéndose por segregación la agrupación de individuos de características similares en el espacio, resultando en cierta homogeneidad de la población.\nEl índice de Moran en esencia, se trata de un estadístico de producto cruzado entre una variable y su retardo espacial, con la variable expresada en desviaciones de su media.\nI= \\frac{n}{S_0 }\\frac{\\sum_{i=1}^n  \\sum_{j=1}^n W_{ij} Z_iZ_j}{ \\sum_{i=1}^n Z_i^2} \\tag{6.2}\nDonde:\n\nzi = valor de la desviación de la media de la variable de interés, es decir z_i=x_i-\\bar{x}.\nS_o= \\sum_{i=1}^n \\sum_{j=1}^n W_{ij}\nW_{ij} = Matriz de Vecindad\n\nLa inferencia de I de Moran se basa en una hipótesis nula de aleatoriedad espacial. La distribución del estadístico bajo la hipótesis nula puede derivarse utilizando un supuesto de normalidad (variantes aleatorias normales independientes), o la llamada aleatoriedad (es decir, cada valor tiene la misma probabilidad de ocurrir en cualquier lugar).\nPara efectos prácticos de evaluación de la autocorrelación espacial se buscará usar el promedio de educación del jefe de hogar como un indicador del nivel socioeconómico del hogar. El promedio de estos a nivel de manzana, nos indicará a grandes rasgos las características de la población a este nivel desagregado.\nAplicación de Moran Test (global) (Equation 6.2)\n\n## Test de Moran de autocorrelacion global\nspdep::moran.test(x = mz_comuna$nived,  listw = nb)\n\n\n    Moran I test under randomisation\n\ndata:  mz_comuna$nived  \nweights: nb    \n\nMoran I statistic standard deviate = 53.93, p-value &lt; 2.2e-16\nalternative hypothesis: greater\nsample estimates:\nMoran I statistic       Expectation          Variance \n     0.7887762573     -0.0006788866      0.0002142838 \n\n\nEl p-value es menor que 0.05 se rechaza la hipótesis nula, por ende podemos descartar un patrón aleatorio en los datos de muestra.\n**Gráfico de Moran*\n\nmoran.plot(x = mz_comuna$nived,  listw = nb, \n           labels=as.character(mz_comuna$id))\n\n\n\n\nEn este gráfico se se divide el espacio en cuadrantes de Valores Altos rodeados de Valores Altos (hotspots), Bajos rodeados de Bajos (Coldspot) y los intermedios.\n\n\n6.5.2 Local Moran\nEl Índice de Moran (global) fue diseñado para rechazar la hipótesis nula de aleatoriedad espacial a favor de una alternativa de agrupación. Dicha agrupación es una característica del patrón espacial completo y no proporciona una indicación de la ubicación de las agrupaciones.\nEl estadístico Moran local fue sugerido por(Anselin 1995) Acomo una forma de identificar los clusters locales y los valores atípicos espaciales locales.\nPara nuestro caso práctico este test permite identificar la significancia de los cluster y poder clasificar las observaciones (manzanas) e identificar denominadas “Hight Hight” y “Low Low” en coherencia de los cuadrantes diagonales del gráfico de Moran antes visualizado.\nCon las ponderaciones estandarizadas por filas, S_0=\\sum_i\\sum_jw_{ij} la suma de todas las ponderaciones es igual al número de observaciones, n. Como resultado, del gráfico de dispersión de Moran, el estadístico I de Moran se simplifica a:\nI=\\frac{\\sum_i\\sum_jw_{ij}Z_iZj}{{\\sum_i z_i^2},}\nEl correspondiente estadístico local de Moran consistiría en el componente de la suma doble que corresponde a cada observación i, o:\nI_i= \\frac{\\sum_{j}w_{ij}Z_iZj}{\\sum_i z_i^2},\nEn esta expresión, el denominador es fijo y, por lo tanto, se puede ignorar. Para simplificar la notación, lo sustituimos por c de modo que la expresión de Moran local se convierte en la expresión:\nI_i= c.Z_i\\sum_jw_{ij}Z_j Se podría demostrar (Matemáticamente) que la suma de las estadísticas locales es proporcional a la I de Moran global o, alternativamente, que la I de Moran global se corresponde con la media de las estadísticas locales (para más detalles, (Anselin 1995).\nPara realizar estos cálculos en R haremos uso de la función localmoran\n\n# moran local\nlmoran &lt;-\n  localmoran(mz_comuna$nived,\n             listw = nb) %&gt;%\n  as_tibble() # llevar a tabla para facilitar trabajo\n\nHaciendo uso del test de local Moran podemos identificar los cluster haciendo uso de los resultados significancia estadística:\n\n# resultados\nmzs_cluster &lt;-\n  mz_comuna %&gt;%\n  mutate(\n    z_i = as.numeric(scale(mz_comuna$nived)), # var estandarizada\n    z_j = lag.listw(nb, z_i) # promedio vecinos\n    ) %&gt;%\n  mutate(\n    P = as.numeric(lmoran$`Pr(z != E(Ii))`) # significancia\n  )\n\n\nLas puntuaciones z y los valores p son medidas de significancia estadística que indican si se rechazará la hipótesis nula, entidad por entidad. En efecto, indican si la aparente similitud (un clustering espacial de valores altos o bajos) o la falta de similitud (un valor atípico espacial) es más marcada de lo que se espera en una distribución aleatoria\nUna puntuación z positiva alta para una entidad indica que las entidades circundantes tienen valores similares (ya sea valores altos o bajos). La salida será Alto/alto para un clúster de valores altos estadísticamente significativo y Bajo/bajo para un clúster de valores bajos estadísticamente significativo.\nUna puntuación z negativa baja para una entidad indica un valor atípico de datos espacial estadísticamente significativo. La salida indicará si la entidad tiene un valor alto y está rodeada por entidades con valores bajos (Alto/bajo) o si la entidad tiene un valor bajo y está rodeada por entidades con valores altos (Bajo/alto).\n\n\nmzs_cluster &lt;- mzs_cluster%&gt;%\n  mutate(\n    clusterM = # clasificar cluster\n      case_when(\n        (P &lt;= 0.05) & (z_i &gt;  0) & (z_j &gt;  0) ~ \"HH\",\n        (P &lt;= 0.05) & (z_i &lt;= 0) & (z_j &gt;  0) ~ \"LH\",\n        (P &lt;= 0.05) & (z_i &gt;  0) & (z_j &lt;= 0) ~ \"HL\",\n        (P &lt;= 0.05) & (z_i &lt;= 0) & (z_j &lt;= 0) ~ \"LL\",\n        TRUE ~ \"NS\"\n        )\n  )\n\n# st_write(mzs_cluster, \"data/shape/clusters_LC.shp\")\n\nEl campo clusterM indicará siempre clusters y valores atípicos estadísticamente significativos para un nivel de confianza del 95 por ciento.\n\n# resultados clusters\ntable(mzs_cluster$clusterM)\n\n\n  HH   HL   LH   LL   NS \n  40    4    2  133 1295 \n\n\nVisualización de cluster HH y LL\n\nmzs_cluster_segr &lt;- mzs_cluster %&gt;% filter(clusterM %in% c( \"HH\", \"LL\"))\n\nggplot() +\n  geom_sf(data = mz_comuna, fill =NA,  color =\"gray80\", \n          alpha=1,  size= 0.1)+\n  geom_sf(data = mzs_cluster_segr, aes(fill = clusterM),\n          color =NA, alpha=0.8,  size= 0.1)+\n  scale_fill_manual(values = c(\"#08519c\", \"#e31a1c\"))+\n  ggtitle(\"Segregación en la comuna de Las Condes\") +\n  theme_bw() +\n  theme(plot.title = element_text(size=12))+\n  theme(panel.grid.major = element_line(colour = \"gray80\"), \n        panel.grid.minor = element_line(colour = \"gray80\"))\n\n\n\n# mapview(mzs_cluster_segr, zcol = \"clusterM\")\n\n\nkde_raster &lt;-  raster(\"data/delitos/kde_delvio_LC.tif\")\n\nmapview(kde_raster)+\n    mapview(mzs_cluster_segr, zcol = \"clusterM\", layer.name =  \"clusterM\")"
  },
  {
    "objectID": "autocorrelacion.html#actividades",
    "href": "autocorrelacion.html#actividades",
    "title": "6  Autocorrelación Espacial",
    "section": "6.6 Actividades:",
    "text": "6.6 Actividades:\n\nCalcular local Moran para la variable de Atractor comercial de la Base del SII\nCalcular local Moran cualquier otra variable de la base comunal.\nCalcular local Moran cualquier otra variable en otra comuna."
  },
  {
    "objectID": "autocorrelacion.html#referencias-del-capítulo",
    "href": "autocorrelacion.html#referencias-del-capítulo",
    "title": "6  Autocorrelación Espacial",
    "section": "6.7 Referencias del Capítulo",
    "text": "6.7 Referencias del Capítulo\n\nhttp://www.scielo.org.co/pdf/rcdg/v28n1/2256-5442-rcdg-28-01-1.pdf\nDistance-Band Spatial Weights - Luc Anselin\nGlobal Spatial Autocorrelation - Luc Anselin\nLocal Spatial Autocorrelation - Luc Anselin\nAnalizaR Datos Políticos- Mapas y datos espaciales\n\n\n\n\n\nAnselin, Luc. 1995. “Local Indicators of Spatial Association—LISA.” Geographical Analysis 27 (2): 93–115. https://doi.org/10.1111/j.1538-4632.1995.tb00338.x.\n\n\nCliff, Andrew, and Keith Ord. 1972. “Testing for Spatial Autocorrelation Among Regression Residuals.” Geographical Analysis 4 (3): 267–84. https://doi.org/10.1111/j.1538-4632.1972.tb00475.x.\n\n\nP. Moran, P. a. 1948. “The Interpretation of Statistical Maps.” Journal of the Royal Statistical Society: Series B (Methodological) 10 (2): 243–51. https://doi.org/10.1111/j.2517-6161.1948.tb00012.x."
  },
  {
    "objectID": "regresion_espacial.html#objetivos",
    "href": "regresion_espacial.html#objetivos",
    "title": "7  Regresión Espacial",
    "section": "7.1 Objetivos",
    "text": "7.1 Objetivos\n\n\n\nObjetivos"
  },
  {
    "objectID": "regresion_espacial.html#fundamentos-teóricos-de-regresión-espacial",
    "href": "regresion_espacial.html#fundamentos-teóricos-de-regresión-espacial",
    "title": "7  Regresión Espacial",
    "section": "7.2 Fundamentos Teóricos de Regresión Espacial",
    "text": "7.2 Fundamentos Teóricos de Regresión Espacial\n\n7.2.1 Introducción\nEl análisis de regresión le permite modelar, examinar y explorar relaciones espaciales y puede ayudar a explicar los factores detrás de los patrones espaciales observados. Sin embargo, hay una motivación adicional importante: incorporar explícitamente la dependencia espacial en el modelo. Hay dos tipos comunes de regresión espacial: el modelo de error espacial (SEM) y el modelo de retraso espacial (SLM).\n\n\n7.2.2 Tipos de Regresión\nModelo de error espacial: \n\n\n\nExplicación Modelo de Error Espacial\n\n\nLa principal razón para aplicar un modelo de error espacial es controlar la autocorrelación espacial general. Queremos hacerlo porque la autocorrelación espacial rompe el importante supuesto de que nuestros errores de regresión no están correlacionados.\nModelo de retraso (lag) espacial:\n\n\n\nExplicación Modelo de lag Espacial\n\n\nLa principal razón para ejecutar un modelo de retraso espacial es modelar formalmente el contagio espacial. Estamos modelando el impacto de los resultados de nuestros vecinos en nuestro propio resultado."
  },
  {
    "objectID": "regresion_espacial.html#cálculo-de-regresión-espacial",
    "href": "regresion_espacial.html#cálculo-de-regresión-espacial",
    "title": "7  Regresión Espacial",
    "section": "7.3 Cálculo de Regresión Espacial",
    "text": "7.3 Cálculo de Regresión Espacial\nA continuación se realizarán dos modelos de regresión espacial, el primero con error espacial y la variable a explicar es el nivel socioecómico. En segundo caso la variable a explicar será el indicador de delitos violentos en la comuna de Las Condes, y se aplicará modelo error y lag espacial, además del un modelo que combina ambos llamado sacsar.\n\n7.3.1 Pasos de Regresion Espacial\n\nSelección de Área de Estudio\nCrear Matriz de Vecindad\nAnalizar la Autorrelación Espacial de y\nEstimar un modelo de regresión ordinario (OLS)\nSeleccionar tipo de Regresión Espacial\nEstimar Modelo de Regresión Espacial\n\n\n\n7.3.2 Selección de Área de Estudio\nCargar Librerías\n\n\n\nSelección de Área de Estudio\n\nmi_comuna &lt;-  \"LAS CONDES\"\n# ine\nmz_comuna &lt;- readRDS(\"data/censo/manzanas.rds\") %&gt;% \n  filter(NOM_COM == mi_comuna) %&gt;% \n  st_transform(32719)\n\n\n# socioeconomicos\nsoc &lt;-  st_read(\"data/socioeconomicos/resultados/R13_ind_socioeconomicos.shp\") %&gt;% \n  st_drop_geometry() %&gt;%\n  dplyr::select(ID_MANZ, ID_MANZCIT, IEJ, IEM, IPJ, IRH, IVI, ISV) \n\nReading layer `R13_ind_socioeconomicos' from data source \n  `/Users/denisberroeta/Library/CloudStorage/OneDrive-UniversidadAdolfoIbanez/Goblab/BDPP_Geoanalisis/geoanalisis_book/data/socioeconomicos/resultados/R13_ind_socioeconomicos.shp' \n  using driver `ESRI Shapefile'\nSimple feature collection with 55754 features and 20 fields\nGeometry type: POLYGON\nDimension:     XY\nBounding box:  xmin: 249067.9 ymin: 6205212 xmax: 428360.8 ymax: 6356031\nProjected CRS: WGS 84 / UTM zone 19S\n\nmz_comuna &lt;-  mz_comuna %&gt;% \n  mutate(CODINE017 = as.character(CODINE017)) %&gt;% \n  left_join(soc,by = c(\"CODINE017\" = \"ID_MANZ\"))\n# head(mz_comuna)\n\nAgregar Variable de Densidad Poblacional\nCalcula la densidad poblacional por hetárea\n\nmz_comuna &lt;- mz_comuna %&gt;% \n  mutate(densidad_hec = round(as.numeric(POBLACION/(st_area(.)/10000))))\n\nEliminar Valores Nulos\nPrimero se cfrea una variable que se prentende explicar\n\nmz_comuna &lt;-  mz_comuna %&gt;% \n  mutate(nived = JH_ESC_P) %&gt;% # Usaremos variable auxiliar de nivel educacional\n  filter(!is.na(nived))\n\n\nggplot() +\n  geom_sf(data = mz_comuna, aes(fill = nived), color =\"gray80\", \n          alpha=1,  size= 0.1)+\n  scale_fill_distiller(palette= \"YlGnBu\", direction = 1)+\n  ggtitle(\"Nivel Educacional del Jefe de Hogar\") +\n  theme_bw() +\n  theme(plot.title = element_text(size=12))+\n  theme(panel.grid.major = element_line(colour = \"gray80\"), \n        panel.grid.minor = element_line(colour = \"gray80\"))\n\n\n\n\n\n\n7.3.3 Crear Matriz de Vecindad\nDefinir un criterio de vecidad, para el caso de estudio es la distancia y asignar pesos espciales\nPolígonos a puntos\n\nptos_comuna &lt;- mz_comuna%&gt;%\n  st_geometry() %&gt;%\n  st_centroid()\n\nCalcular Vecinos Cercanos (k)\n\n# vecinos mas cercanos (neighbours)\nk &lt;- 8 # numero de vecinos a buscar\nnb_mzs &lt;- knearneigh(ptos_comuna, k = k) %&gt;%  # por punto calcula K vecinos\n  knn2nb() # Knn a matriz de vecindad\n\nVisualización de la relaciones por cada Centroide\n\n# matri&lt; de vecindad a lines solo oara visualizaciñon\nneighbors_sf &lt;- as(nb2lines(nb_mzs, coords = st_geometry(ptos_comuna)), 'sf')\n\np_mv &lt;- ggplot() +\n  geom_sf(data = mz_comuna, fill = NA, color =\"gray60\", alpha=1,  size= 0.3)+\n  geom_sf(data = neighbors_sf,  color = \"red\", alpha=0.5,  size= 0.5)+\n  geom_sf(data = ptos_comuna,  color =\"#525252\", alpha=1,  size= 1)+\n  ggtitle(\"Relaciones de Vecindad por cada manzana (k = 8)\") +\n  theme_bw() +\n  theme(plot.title = element_text(size=12))+\n  theme(panel.grid.major = element_line(colour = \"gray80\"), \n        panel.grid.minor = element_line(colour = \"gray80\"))\n\np_mv\n\n\n\n\nAsignar Pesos Espaciales por población\n\nnb &lt;-nb2listw(nb_mzs)\nmz_comuna$id &lt;- 1:nrow(mz_comuna)\nnb$weights = lapply(1:nrow(mz_comuna), function(i)\n  mz_comuna$POBLACION[mz_comuna$id %in% nb$neighbours[[i]]] / \n    sum(mz_comuna$POBLACION[mz_comuna$id %in% nb$neighbours[[i]]]))\n\n\n\n7.3.4 Analizar la Autorrelación Espacial de y\nA través del test estadítico índice de Moran analizar la autocorrelación espacial de la variable dependiente que se pretende explicar.\n\n## Test de Moran\nmoran.test(mz_comuna$nived,listw=nb)\n\n\n    Moran I test under randomisation\n\ndata:  mz_comuna$nived  \nweights: nb    \n\nMoran I statistic standard deviate = 54.42, p-value &lt; 2.2e-16\nalternative hypothesis: greater\nsample estimates:\nMoran I statistic       Expectation          Variance \n     0.7884021415     -0.0006635700      0.0002102337 \n\n\n\n\n7.3.5 Estimar un modelo de regresión ordinario (OLS)\nTransformación de Variables\nRevisión de la distribución de Variables\n\nhist(mz_comuna$densidad_hec, breaks=100)\n\n\n\nhist(log(mz_comuna$densidad_hec), breaks=100)\n\n\n\n\n\ncolnames &lt;- c(\"nived\",\"densidad_hec\",\"ISV\",\"IVI\",\"IRH\", \"IEM\")\n\n# Ciclo para graficos agrupados\npar(mfrow=c(3, 3))\nfor (v in colnames) {\n    hist(mz_comuna %&gt;% st_drop_geometry() %&gt;% pull(!!v), breaks=100, main=v, probability=TRUE, col=\"gray\")\n}\n\n\n\n\nTransformaciones de Datos en modelos\nSe pueden transformar los datos para obtener mejor linealidad entre sus relaciones entre las variables respuesta y predictivas. Las transformaciones más utilizadas son:\n\nlog(y) frente a x para relaciones exponenciales\nlog(y) contra log(x) para funciones de potencia;\nexp(y) contra x para relaciones logarítmicas;\n1/y contra 1/x para las relaciones asintóticas;\nlog(p/(1 - p)) contra x para datos de proporción.\n\n\nmz_comuna &lt;- mz_comuna %&gt;% \n  mutate(\n    l_nived = nived^3,\n    l_densidad_hec = log(densidad_hec),\n    l_ISV = log(ISV),\n    l_IVI = log(IVI),\n    l_IRH = log(IRH),\n    l_IEM = log(IEM)\n  )\n\n\ncolnames &lt;- c(\"l_nived\",\"l_densidad_hec\",\"l_ISV\",\"l_IVI\",\"l_IRH\", \"l_IEM\")\n\n\n# Ciclo para graficos agrupados\npar(mfrow=c(3, 3))\ncom &lt;- mz_comuna %&gt;% st_drop_geometry() \nfor (v in colnames) {\n    hist(com %&gt;% pull(!!v), breaks=100, main=v, probability=TRUE, col=\"gray\")\n}\n\npar(mfrow=c(1, 1))\n\n\n\n\nModelo OLS\nModelo estadístico que relaciona funcionalmente dos variables de forma lineal (una recta o, en su versión generalizada, un plano o un hiperplano). El caso más simple contiene una variable respuesta (Y; i.e. lo que se quiere explicar o predecir), y una variable explicativa o predictor (X; i.e., variables que se usan para explicar o predecir Y). A veces estas variables también son llamadas dependiente e independiente.\nQue exista una relación funcional significativa entre ambas variables no implica una causalidad, pero la puede sugerir.\ny = b_0 + b_1*x_1 + b-_2*x_2 + b_3*x_3 + … + b_n*x_n+\\varepsilon\n\nmod_nived = lm(l_nived ~ l_densidad_hec + l_ISV + l_IVI + l_IRH + l_IEM,\n               data = mz_comuna)\nsummary(mod_nived)\n\n\nCall:\nlm(formula = l_nived ~ l_densidad_hec + l_ISV + l_IVI + l_IRH + \n    l_IEM, data = mz_comuna)\n\nResiduals:\n    Min      1Q  Median      3Q     Max \n-4019.5  -400.6   156.5   669.5  4062.1 \n\nCoefficients:\n               Estimate Std. Error t value Pr(&gt;|t|)    \n(Intercept)     5151.28     151.42  34.020  &lt; 2e-16 ***\nl_densidad_hec  -184.79      33.92  -5.448 5.94e-08 ***\nl_ISV          21437.26    3120.22   6.870 9.35e-12 ***\nl_IVI           9103.21     794.40  11.459  &lt; 2e-16 ***\nl_IRH            899.25     270.00   3.331 0.000888 ***\nl_IEM           5105.64     779.96   6.546 8.09e-11 ***\n---\nSignif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1\n\nResidual standard error: 1012 on 1502 degrees of freedom\nMultiple R-squared:  0.2021,    Adjusted R-squared:  0.1995 \nF-statistic:  76.1 on 5 and 1502 DF,  p-value: &lt; 2.2e-16\n\n# plot(mod_nived)\n\nOutput Modelo de Regresión\n\n\n\nOutput de modelos de regesión\n\n\nP - Valor p-value\np-value Probabilidad de que el la H0 sea verdad. P-valores significativos, ej., bajo alpha = 0.05, lleva a interpretar la probabilidad de que el modelo de regresión no explique una porción significativa de la varianza de Y es baja.\n\nH_0: El modelo NO explica la varianza de los datos Y\nH_1: El modelo SI explica la varianza de los datos Y\n\nCoeficiente de determinación (R^2)\nEl coeficiente de determinación (o el cuadrado de la correlación de Pearson) es una de las métricas más utilizadas. Si bien esta es muy útil, pueden haber ocasiones donde valores altos de R² se obtienen cuando la dispersión o error de las predicciones es alta. Los valores van entre 0 y 1. Es una medida de ajuste relativa (porcentual), por lo que puede ser usada para comparar modelos entre sí.\nDistribución F de Fisher\nComparar si hay diferencias significativas entre dos varianzas. En caso de las regresiones proporciona esencialmente una medida de la cantidad de variación que explica el modelo frente a la cantidad de variación no explicada (por grados de libertad restantes).\nValores de F altos significa que su modelo explica mucho más de la variación por parámetro que el error por grado de libertad restante.\nResiduos\nLos residuos son la diferencia entre los valores observados y los predichos (obs - pred). Los residuos se utilizan mucho en post-hoc tests (o tests para analizar los resultados de los modelos). Los residuos, por un lado, dan estimaciones de posibles sesgos del modelo.\nEs muy importante que los residuos se distribuyan de manera aleatoria en el modelo.\n\n\n\nVisualización de los residuos\n\n\nAnálisis de Residuos\nPara verificar que la relación a estudiar no genera residuos que se encuentren correlacionados espacialmente, extraemos los errores del modelo OLS y aplicamos el contraste de hipótesis usual, usando el estadístico de Moran (ó Moran’s I):\n\nresiduals_mod_nived&lt;-residuals(mod_nived)\nmoran.test(residuals_mod_nived, listw = nb,  randomisation = TRUE)\n\n\n    Moran I test under randomisation\n\ndata:  residuals_mod_nived  \nweights: nb    \n\nMoran I statistic standard deviate = 37.878, p-value &lt; 2.2e-16\nalternative hypothesis: greater\nsample estimates:\nMoran I statistic       Expectation          Variance \n     0.5491099106     -0.0006635700      0.0002106614 \n\n\n\nmoran_res &lt;-moran.mc(residuals_mod_nived, nb, nsim=599)\nplot(moran_res)\n\n\n\n\n\n\n7.3.6 Seleccionar tipo de Regresión Espacial\n\n## Test Moran residuos\nlm.morantest(mod_nived,nb,alternative=\"greater\")\n\n\n    Global Moran I for regression residuals\n\ndata:  \nmodel: lm(formula = l_nived ~ l_densidad_hec + l_ISV + l_IVI + l_IRH +\nl_IEM, data = mz_comuna)\nweights: nb\n\nMoran I statistic standard deviate = 38.006, p-value &lt; 2.2e-16\nalternative hypothesis: greater\nsample estimates:\nObserved Moran I      Expectation         Variance \n    0.5491099106    -0.0013513898     0.0002097729 \n\n\n\n## Tipo de dependencia\nlm.LMtests(mod_nived,nb,test=\"all\")\n\n\n    Lagrange multiplier diagnostics for spatial dependence\n\ndata:  \nmodel: lm(formula = l_nived ~ l_densidad_hec + l_ISV + l_IVI + l_IRH +\nl_IEM, data = mz_comuna)\nweights: nb\n\nLMerr = 1422.7, df = 1, p-value &lt; 2.2e-16\n\n\n    Lagrange multiplier diagnostics for spatial dependence\n\ndata:  \nmodel: lm(formula = l_nived ~ l_densidad_hec + l_ISV + l_IVI + l_IRH +\nl_IEM, data = mz_comuna)\nweights: nb\n\nLMlag = 1791.5, df = 1, p-value &lt; 2.2e-16\n\n\n    Lagrange multiplier diagnostics for spatial dependence\n\ndata:  \nmodel: lm(formula = l_nived ~ l_densidad_hec + l_ISV + l_IVI + l_IRH +\nl_IEM, data = mz_comuna)\nweights: nb\n\nRLMerr = 0.47975, df = 1, p-value = 0.4885\n\n\n    Lagrange multiplier diagnostics for spatial dependence\n\ndata:  \nmodel: lm(formula = l_nived ~ l_densidad_hec + l_ISV + l_IVI + l_IRH +\nl_IEM, data = mz_comuna)\nweights: nb\n\nRLMlag = 369.26, df = 1, p-value &lt; 2.2e-16\n\n\n    Lagrange multiplier diagnostics for spatial dependence\n\ndata:  \nmodel: lm(formula = l_nived ~ l_densidad_hec + l_ISV + l_IVI + l_IRH +\nl_IEM, data = mz_comuna)\nweights: nb\n\nSARMA = 1791.9, df = 2, p-value &lt; 2.2e-16\n\n\n\n\n7.3.7 Modelo de error Espacial\nA pesar de que nuestro modelo goza de las características ideales asociadas a un modelo de regresión líneal estándar, hemos comprobado que los residuos de la regresión presentan autocorrelación espacial. Por tanto, para reconocer la existencia de esta estructura espacial en los errores, usamos el Modelo del Error Espacial. Este modelo se define como:\ny=\\beta_0+X\\beta+\\varepsilon\n\\varepsilon= \\lambda W \\varepsilon+ \\xi\nDonde X son las variables predictoras, mientras que W es la matriz de peso espacial. El parámetro \\lambda es el indicador que mide la fuerza espacial de los residuos y los residuos de los vecinos.\nEn R, estimamos el modelo vía Maximum Likelihood (máxima verosimilitud) de la siguiente forma:\n\n## SDEM Spatial Durbin Error Model\nfit.err = spatialreg::errorsarlm(\n  l_nived ~ l_densidad_hec + l_ISV + l_IVI + l_IRH + l_IEM,\n  data = mz_comuna,\n  listw = spdep::nb2listw(nb_mzs),\n  etype = \"error\",\n  method = \"eigen\"\n)\n\n\n# saveRDS(fit.err, \"data/models/fit.err_nived.rds\")\nfit.err &lt;- readRDS(\"data/models/fit.err_nived.rds\")\n\n\nsummary(fit.err, Nagelkerke=T)\n\n\nCall:spatialreg::errorsarlm(formula = l_nived ~ l_densidad_hec + l_ISV + \n    l_IVI + l_IRH + l_IEM, data = mz_comuna, listw = spdep::nb2listw(nb_mzs), \n    etype = \"error\", method = \"eigen\")\n\nResiduals:\n       Min         1Q     Median         3Q        Max \n-4017.0145  -355.0942     4.1932   358.5864  2618.4853 \n\nType: error \nCoefficients: (asymptotic standard errors) \n               Estimate Std. Error z value  Pr(&gt;|z|)\n(Intercept)    3871.718    149.503 25.8972 &lt; 2.2e-16\nl_densidad_hec   45.085     24.008  1.8779 0.0603881\nl_ISV          2399.207   2113.385  1.1352 0.2562731\nl_IVI          1617.466    472.923  3.4201 0.0006259\nl_IRH           657.582    159.916  4.1120 3.922e-05\nl_IEM           785.253    462.932  1.6963 0.0898370\n\nLambda: 0.85764, LR test value: 1349.6, p-value: &lt; 2.22e-16\nAsymptotic standard error: 0.014983\n    z-value: 57.241, p-value: &lt; 2.22e-16\nWald statistic: 3276.5, p-value: &lt; 2.22e-16\n\nLog likelihood: -11897.29 for error model\nML residual variance (sigma squared): 363320, (sigma: 602.76)\nNagelkerke pseudo-R-squared: 0.67397 \nNumber of observations: 1508 \nNumber of parameters estimated: 8 \nAIC: 23811, (AIC for lm: 25158)\n\n\nEn este modelo, las variables l_densidad_hec, l_ISV dejaron de ser significativa. Mientras que \\lambda nos indica que el modelo tiene una fuerte correlación espacial en los residuos.\n\n## Test Moran residuos\nres.err=fit.err$residuals\nmoran.test(res.err,nb)\n\n\n    Moran I test under randomisation\n\ndata:  res.err  \nweights: nb    \n\nMoran I statistic standard deviate = -2.1177, p-value = 0.9829\nalternative hypothesis: greater\nsample estimates:\nMoran I statistic       Expectation          Variance \n    -0.0313896508     -0.0006635700      0.0002105203 \n\n\n\n\n7.3.8 Modelo de Lag Espacial\nConsolidar Base Inicial\nINE\n\nmi_comuna &lt;-  \"LAS CONDES\"\n# ine\nmz_comuna &lt;- readRDS(\"data/censo/manzanas.rds\") %&gt;% \n  filter(NOM_COM == mi_comuna) %&gt;% \n  st_transform(32719)\n\nsocioeconomicos\n\nsoc &lt;-  st_read(\"data/socioeconomicos/resultados/R13_ind_socioeconomicos.shp\") %&gt;% \n  st_drop_geometry() %&gt;%\n  dplyr::select(ID_MANZ, ID_MANZCIT, IEJ, IEM, IPJ, IRH, IVI, ISV)\n\nReading layer `R13_ind_socioeconomicos' from data source \n  `/Users/denisberroeta/Library/CloudStorage/OneDrive-UniversidadAdolfoIbanez/Goblab/BDPP_Geoanalisis/geoanalisis_book/data/socioeconomicos/resultados/R13_ind_socioeconomicos.shp' \n  using driver `ESRI Shapefile'\nSimple feature collection with 55754 features and 20 fields\nGeometry type: POLYGON\nDimension:     XY\nBounding box:  xmin: 249067.9 ymin: 6205212 xmax: 428360.8 ymax: 6356031\nProjected CRS: WGS 84 / UTM zone 19S\n\n\nSii\n\nsii &lt;-  st_read(\"data/sii/urbes.shp\") %&gt;% \n  filter(n_com == mi_comuna) %&gt;% \n  st_set_crs(4326) %&gt;% \n  st_transform(32719)\n\nReading layer `urbes' from data source \n  `/Users/denisberroeta/Library/CloudStorage/OneDrive-UniversidadAdolfoIbanez/Goblab/BDPP_Geoanalisis/geoanalisis_book/data/sii/urbes.shp' \n  using driver `ESRI Shapefile'\nSimple feature collection with 210662 features and 11 fields\nGeometry type: POINT\nDimension:     XY\nBounding box:  xmin: -75.72058 ymin: -54.48149 xmax: -68.02319 ymax: -17.98338\nGeodetic CRS:  GCS_unknown\n\nsii_com &lt;- st_intersection(sii, mz_comuna %&gt;% \n                             dplyr::select(CODINE017)) %&gt;% \n  dplyr::select(CODINE017,oficinas: atractor) %&gt;% \n  mutate(CODINE017 = as.character(CODINE017)) %&gt;% \n  st_drop_geometry()\n\n\n# mapview(sii, zcol =\"atractor\", cex=2)\n\ndelitos\n\nidel_violentos_LC &lt;- readRDS(\"data/delitos/idel_violentos_LC.rds\") %&gt;% \n  dplyr::select(CODINE017, idelv) %&gt;% \n  mutate(CODINE017 = as.character(CODINE017)) %&gt;% \n  st_drop_geometry()\n\nConsolidación\n\nmz_estudio &lt;-  mz_comuna %&gt;% \n  mutate(CODINE017 = as.character(CODINE017)) %&gt;% \n  left_join(soc,by = c(\"CODINE017\" = \"ID_MANZ\")) %&gt;% \n  left_join(sii_com,by = \"CODINE017\") %&gt;% \n  left_join(idel_violentos_LC,by = \"CODINE017\") %&gt;% drop_na()\n\nSelección de variables\n\nmz_estudio &lt;- mz_estudio%&gt;% \n  dplyr::select(CODINE017, POBLACION, IEJ,IEM,IPJ, IRH, IVI, ISV,\n                vivienda, atractor,idelv) %&gt;% \n  mutate(densidad_hec = round(as.numeric(POBLACION/(st_area(.)/10000))))\n\n\n7.3.8.1 Transformaciones\n\ncolnames &lt;- c(\"idelv\", \"IEJ\",\"IEM\",\"IPJ\", \"IRH\", \"IVI\", \"ISV\",\n                \"vivienda\", \"atractor\",\"densidad_hec\")\n\n# Ciclo para graficos agrupados\npar(mfrow=c(3, 3))\nfor (v in colnames) {\n    hist(mz_estudio %&gt;% st_drop_geometry() %&gt;% pull(!!v), breaks=100, main=v, probability=TRUE, col=\"gray\")\n}\n\n\n\npar(mfrow=c(1, 1))\n\n\n\n\n\nmz_estudio &lt;- mz_estudio %&gt;% \n  mutate(\n    rc_idelv = idelv^(1/3),\n    c_IEJ = IEJ **3,\n    c_IEM = IEM **3,\n    c_IPJ = IPJ **3,\n    c_IRH = IRH **3,\n    l_vivienda= log(ifelse(vivienda==0, 0.001, vivienda)),\n    l_atractor= log(ifelse(atractor==0, 0.001, atractor)),\n    densidad_hec= log(ifelse(densidad_hec==0, 0.001, densidad_hec))\n  )\n\n\ncolnames &lt;- c(\"rc_idelv\",\"c_IEJ\",\"c_IEM\",\"c_IPJ\",\"c_IRH\", \n              \"l_vivienda\", \"l_atractor\", \"densidad_hec\")\n\n\n# Ciclo para graficos agrupados\npar(mfrow=c(3, 3))\nfor (v in colnames) {\n    hist(mz_estudio %&gt;% st_drop_geometry() %&gt;% pull(!!v), breaks=100, main=v, probability=TRUE, col=\"gray\")\n}\n\npar(mfrow=c(1, 1))\n\n\n\n\nModelo OLS\n\nmod_idelv = lm(rc_idelv ~ c_IEJ + c_IEM + c_IPJ + c_IRH+\n               IVI+ ISV+l_vivienda+l_atractor+densidad_hec, \n               data = mz_estudio)\nsummary(mod_idelv)\n\n\nCall:\nlm(formula = rc_idelv ~ c_IEJ + c_IEM + c_IPJ + c_IRH + IVI + \n    ISV + l_vivienda + l_atractor + densidad_hec, data = mz_estudio)\n\nResiduals:\n     Min       1Q   Median       3Q      Max \n-2.40034 -0.39452  0.01851  0.42548  2.29776 \n\nCoefficients:\n               Estimate Std. Error t value Pr(&gt;|t|)    \n(Intercept)   7.760e+00  1.163e+00   6.674 3.11e-11 ***\nc_IEJ        -4.257e-04  1.496e-05 -28.453  &lt; 2e-16 ***\nc_IEM        -3.587e-01  1.893e-01  -1.895  0.05818 .  \nc_IPJ        -3.641e-01  8.328e-02  -4.372 1.29e-05 ***\nc_IRH         8.847e-01  8.526e-02  10.377  &lt; 2e-16 ***\nIVI           1.340e+00  4.486e-01   2.986  0.00286 ** \nISV          -5.726e+00  1.060e+00  -5.399 7.39e-08 ***\nl_vivienda   -1.216e-02  2.814e-03  -4.321 1.62e-05 ***\nl_atractor    3.604e-02  1.934e-03  18.634  &lt; 2e-16 ***\ndensidad_hec  4.177e-01  1.746e-02  23.923  &lt; 2e-16 ***\n---\nSignif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1\n\nResidual standard error: 0.6542 on 2265 degrees of freedom\nMultiple R-squared:  0.5603,    Adjusted R-squared:  0.5585 \nF-statistic: 320.7 on 9 and 2265 DF,  p-value: &lt; 2.2e-16\n\n\n\nresiduals_idelv &lt;-residuals(mod_idelv)\nmoran.test(residuals_idelv, listw = spdep::nb2listw(nb_mzs),  randomisation = TRUE)\n\n\n\n7.3.8.2 Autocorrelación Espacial\n\nptos_comuna &lt;- mz_estudio%&gt;%\n  st_geometry() %&gt;%\n  st_centroid()\n\n# vecinos mas cercanos (neighbours)\nk &lt;- 8 # numero de vecinos a buscar\nnb_mzs &lt;- knearneigh(ptos_comuna, k = k) %&gt;%  # por punto calcula K vecinos\n  knn2nb() # Knn a matriz de vecindad\n\nnb &lt;-nb2listw(nb_mzs)\nmz_estudio$id &lt;- 1:nrow(mz_estudio)\nnb$weights = lapply(1:nrow(mz_estudio), function(i)\n  mz_estudio$POBLACION[mz_estudio$id %in% nb$neighbours[[i]]] / \n    sum(mz_estudio$POBLACION[mz_estudio$id %in% nb$neighbours[[i]]]))\n\n## Test de Moran\n\n\nmoran.test(mz_estudio$rc_idelv,listw=nb)\n\n\n    Moran I test under randomisation\n\ndata:  mz_estudio$rc_idelv  \nweights: nb    \n\nMoran I statistic standard deviate = 85.276, p-value &lt; 2.2e-16\nalternative hypothesis: greater\nsample estimates:\nMoran I statistic       Expectation          Variance \n     0.9486463950     -0.0004397537      0.0001238681 \n\n\nError espacial\n\n## SDEM Spatial Durbin Error Model\nfit.errdurb_del=errorsarlm(rc_idelv ~ c_IEJ + c_IEM + c_IPJ + c_IRH+\n               IVI+ ISV+l_vivienda+l_atractor+densidad_hec, \n               data = mz_estudio,\n               listw=spdep::nb2listw(nb_mzs),\n               etype=\"error\",method=\"eigen\")\n\n\n\n\n\nsummary(fit.errdurb_del, Nagelkerke=T)\n\n\nCall:errorsarlm(formula = rc_idelv ~ c_IEJ + c_IEM + c_IPJ + c_IRH + \n    IVI + ISV + l_vivienda + l_atractor + densidad_hec, data = mz_estudio, \n    listw = spdep::nb2listw(nb_mzs), etype = \"error\", method = \"eigen\")\n\nResiduals:\n      Min        1Q    Median        3Q       Max \n-2.137774 -0.086091  0.010694  0.093117  0.703214 \n\nType: error \nCoefficients: (asymptotic standard errors) \n                Estimate  Std. Error z value  Pr(&gt;|z|)\n(Intercept)   4.7399e+00  7.0494e-01  6.7238 1.770e-11\nc_IEJ        -2.4073e-05  9.0324e-06 -2.6652  0.007695\nc_IEM        -2.3783e-02  6.2797e-02 -0.3787  0.704889\nc_IPJ        -1.4801e-02  3.0862e-02 -0.4796  0.631528\nc_IRH        -2.4129e-02  3.2158e-02 -0.7503  0.453051\nIVI           9.2301e-03  1.6717e-01  0.0552  0.955967\nISV          -1.6196e+00  6.7003e-01 -2.4171  0.015643\nl_vivienda   -1.0158e-03  9.0700e-04 -1.1200  0.262729\nl_atractor    1.3705e-03  7.8268e-04  1.7510  0.079946\ndensidad_hec  4.0797e-02  8.1071e-03  5.0322 4.849e-07\n\nLambda: 0.96574, LR test value: 4744, p-value: &lt; 2.22e-16\nAsymptotic standard error: 0.0026757\n    z-value: 360.92, p-value: &lt; 2.22e-16\nWald statistic: 130270, p-value: &lt; 2.22e-16\n\nLog likelihood: 114.3006 for error model\nML residual variance (sigma squared): 0.041559, (sigma: 0.20386)\nNagelkerke pseudo-R-squared: 0.94535 \nNumber of observations: 2275 \nNumber of parameters estimated: 12 \nAIC: -204.6, (AIC for lm: 4537.4)\n\n## Test Moran residuos\nres.err=fit.errdurb_del$residuals\nmoran.test(res.err,nb)\n\n\n    Moran I test under randomisation\n\ndata:  res.err  \nweights: nb    \n\nMoran I statistic standard deviate = 9.9861, p-value &lt; 2.2e-16\nalternative hypothesis: greater\nsample estimates:\nMoran I statistic       Expectation          Variance \n     0.1104488178     -0.0004397537      0.0001233061 \n\n\nLag espacial\n\n## SDM Spatial Durbin Lag Model\nfit.durb=lagsarlm(rc_idelv ~ c_IEJ + c_IEM + c_IPJ + c_IRH+\n               IVI+ ISV+l_vivienda+l_atractor+densidad_hec, \n               data = mz_estudio,\n               listw=spdep::nb2listw(nb_mzs),\n               type=\"lag\",method=\"eigen\")\n\n\n\n\n\nsummary(fit.durb, Nagelkerke=T)\n\n\nCall:sacsarlm(formula = rc_idelv ~ c_IEJ + c_IEM + c_IPJ + c_IRH + \n    IVI + ISV + l_vivienda + l_atractor + densidad_hec, data = mz_estudio, \n    listw = spdep::nb2listw(nb_mzs), type = \"sac\", method = \"eigen\")\n\nResiduals:\n      Min        1Q    Median        3Q       Max \n-2.078202 -0.076293  0.002771  0.085556  0.736343 \n\nType: sac \nCoefficients: (asymptotic standard errors) \n                Estimate  Std. Error z value  Pr(&gt;|z|)\n(Intercept)   1.9442e+00  5.9304e-01  3.2784  0.001044\nc_IEJ        -3.7680e-05  7.6257e-06 -4.9413 7.762e-07\nc_IEM        -3.4337e-02  6.1710e-02 -0.5564  0.577925\nc_IPJ        -3.8772e-02  2.9724e-02 -1.3044  0.192092\nc_IRH        -2.6951e-03  3.1001e-02 -0.0869  0.930724\nIVI          -8.9824e-03  1.6229e-01 -0.0553  0.955860\nISV          -1.5024e+00  5.5041e-01 -2.7296  0.006341\nl_vivienda   -1.3060e-03  9.0092e-04 -1.4496  0.147162\nl_atractor    2.3484e-03  7.3308e-04  3.2035  0.001358\ndensidad_hec  4.7751e-02  7.3658e-03  6.4828 9.006e-11\n\nRho: 0.86956\nAsymptotic standard error: 0.019016\n    z-value: 45.729, p-value: &lt; 2.22e-16\nLambda: 0.59768\nAsymptotic standard error: 0.052188\n    z-value: 11.452, p-value: &lt; 2.22e-16\n\nLR test value: 5011, p-value: &lt; 2.22e-16\n\nLog likelihood: 247.8068 for sac model\nML residual variance (sigma squared): 0.038922, (sigma: 0.19729)\nNagelkerke pseudo-R-squared: 0.95141 \nNumber of observations: 2275 \nNumber of parameters estimated: 13 \nAIC: -469.61, (AIC for lm: 4537.4)\n\n## Test Moran residuos\nres.lag=fit.durb$residuals\nmoran.test(res.lag,nb)\n\n\n    Moran I test under randomisation\n\ndata:  res.lag  \nweights: nb    \n\nMoran I statistic standard deviate = 3.1971, p-value = 0.0006942\nalternative hypothesis: greater\nsample estimates:\nMoran I statistic       Expectation          Variance \n     0.0350557130     -0.0004397537      0.0001232666 \n\n\nError y Lag espacial\n\n## SAC Spatial Autocorrelation Model\nfit.sac=sacsarlm(rc_idelv ~ c_IEJ + c_IEM + c_IPJ + c_IRH+\n               IVI+ ISV+l_vivienda+l_atractor+densidad_hec, \n               data = mz_estudio,\n               listw=spdep::nb2listw(nb_mzs),\n               type=\"sac\",method=\"eigen\")\n\n\n\n\n\nsummary(fit.sac, Nagelkerke=T)\n\n\nCall:sacsarlm(formula = rc_idelv ~ c_IEJ + c_IEM + c_IPJ + c_IRH + \n    IVI + ISV + l_vivienda + l_atractor + densidad_hec, data = mz_estudio, \n    listw = spdep::nb2listw(nb_mzs), type = \"sac\", method = \"eigen\")\n\nResiduals:\n      Min        1Q    Median        3Q       Max \n-2.078202 -0.076293  0.002771  0.085556  0.736343 \n\nType: sac \nCoefficients: (asymptotic standard errors) \n                Estimate  Std. Error z value  Pr(&gt;|z|)\n(Intercept)   1.9442e+00  5.9304e-01  3.2784  0.001044\nc_IEJ        -3.7680e-05  7.6257e-06 -4.9413 7.762e-07\nc_IEM        -3.4337e-02  6.1710e-02 -0.5564  0.577925\nc_IPJ        -3.8772e-02  2.9724e-02 -1.3044  0.192092\nc_IRH        -2.6951e-03  3.1001e-02 -0.0869  0.930724\nIVI          -8.9824e-03  1.6229e-01 -0.0553  0.955860\nISV          -1.5024e+00  5.5041e-01 -2.7296  0.006341\nl_vivienda   -1.3060e-03  9.0092e-04 -1.4496  0.147162\nl_atractor    2.3484e-03  7.3308e-04  3.2035  0.001358\ndensidad_hec  4.7751e-02  7.3658e-03  6.4828 9.006e-11\n\nRho: 0.86956\nAsymptotic standard error: 0.019016\n    z-value: 45.729, p-value: &lt; 2.22e-16\nLambda: 0.59768\nAsymptotic standard error: 0.052188\n    z-value: 11.452, p-value: &lt; 2.22e-16\n\nLR test value: 5011, p-value: &lt; 2.22e-16\n\nLog likelihood: 247.8068 for sac model\nML residual variance (sigma squared): 0.038922, (sigma: 0.19729)\nNagelkerke pseudo-R-squared: 0.95141 \nNumber of observations: 2275 \nNumber of parameters estimated: 13 \nAIC: -469.61, (AIC for lm: 4537.4)\n\n## Test Moran residuos\nres.sac=fit.sac$residuals\nmoran.test(res.sac,nb)\n\n\n    Moran I test under randomisation\n\ndata:  res.sac  \nweights: nb    \n\nMoran I statistic standard deviate = 3.1971, p-value = 0.0006942\nalternative hypothesis: greater\nsample estimates:\nMoran I statistic       Expectation          Variance \n     0.0350557130     -0.0004397537      0.0001232666"
  },
  {
    "objectID": "regresion_espacial.html#referencias-de-capítulo",
    "href": "regresion_espacial.html#referencias-de-capítulo",
    "title": "7  Regresión Espacial",
    "section": "7.4 Referencias de Capítulo:",
    "text": "7.4 Referencias de Capítulo:\n\nGEO 200CN: Quantitative Geography\nSpatial Regression 10. Specification Tests\nSpatial Regression Analysis in R A Workbook - Luc Anselin"
  },
  {
    "objectID": "tarea_1.html#antecedentes",
    "href": "tarea_1.html#antecedentes",
    "title": "Tarea 1",
    "section": "Antecedentes",
    "text": "Antecedentes\n\nFecha de entrega: 05 de Novimbre 2022\nFormato: Informe (pdf, html) + Código\nIntegrantes: 3 o 4"
  },
  {
    "objectID": "tarea_1.html#instrucciones",
    "href": "tarea_1.html#instrucciones",
    "title": "Tarea 1",
    "section": "Instrucciones",
    "text": "Instrucciones\n\nParte 1: Indicadores Socioeconómicos\n\nCalcular los 6 Indicadores Socioenómicos en una Región de su área de estudio (1 pt) Section 3.4\nSeleccione una Provincia y un indicador socioeconómico que consideren que evidencia una nencesidad prioritaria en la provincia. Defina un valor de indicador como umbral crítico (ej: menor a 0.25) y genere una tabla resumen (usar función group_by()) donde se contabilice la cantidad de personas que están bajo el umbral crítico y promedio del indicador por comuna en la provincia seleccionada. (1 pt)\nDe la tabla anterior, seleccione una comuna, ya sea por la mayor cantidad de personas (bajo el umbral) o por valor promedio del indicador más bajo (justifique la selección de comuna). Realicé representación cartográfica del valor del indicador a nivel de manzana censal e identifique visualmente si existen concentraciones de valores de indicadores altos y/o bajos y haga una descripción del sector basándose en su conocimiento en terreno, experiencia general o valores de indicadores. (1 pt)\n\n\n\nParte 2: Indicadores Ambientales\n\nSeleccionar una Comuna de la Región metropolitana (no Las Condes) Section 4.3.3 y calcular NDVI usando la función vista en clases Section 4.4.1 . (1pt)\nCalcular Vegentación que existe en la comuna seleccionada, filtrando y dejando solo los pixeles sobre un valor de umbral que ustedes determinen. Section 4.4.2 (1pt)\nCalcule el indicador de cobertura vegetal para la manzanas urbanas de la comuna seleccionada. Section 4.4.2 (1 pt)"
  },
  {
    "objectID": "tarea_2.html#antecedentes",
    "href": "tarea_2.html#antecedentes",
    "title": "Tarea 2",
    "section": "Antecedentes",
    "text": "Antecedentes\n\nFecha de entrega: 28 de Noviembre 2023\nFormato: Informe (pdf o html) + Código (.r o .rmd)\nIntegrantes: Individual o Grupal (máximo 4)"
  },
  {
    "objectID": "tarea_2.html#instrucciones",
    "href": "tarea_2.html#instrucciones",
    "title": "Tarea 2",
    "section": "Instrucciones",
    "text": "Instrucciones\n\nParte 1: Interpolación de Inverso a la Distancia Poderada.\n\n\n\nDescripción gráfica de los resultados de interpolación de inverso a la distancia ponderada\n\n\n\nDefina un área de estudio Urbana (no la comunas vistas en clases)\nRealice 3 calculos de interpolación de Inverso a al Distancia (IDW) con los datos del SII correspodiente a comercio, oficina y atractor. (1.5 pt)\nCalcule un indicador de territorial por cada uno de los resultados de las IDW del punto anterior y visualice los los resultados. (1.5 pt)\n\n\n\nParte 2: Autocorrelación espacial.\n\nDefina un área de estudio Urbana (no la comunas vistas en clases) y visualice una variable que usted decida evaluar su autocorrelación espacial (Ej: Nivel Educacional). Justifique la selección de variable a modo de hipótesis breve. (1 pt)\nGenere una Matriz de Vecidad ponderada por la variable que usted encuentre idónea (Ej: Población) (1 pt)\nCálculo de índice de Moran (global) y visualice sus resultados en gráfico de cuadrantes. Interprete los resultados de forma general. (1 pt)\nCálculo de índice de local Moran e identifique los grupos o cluster haciendo uso de los resultados significancia estadística, visualice los resultados en un Mapa e Interprete los resultados de forma general. (1 pt)\n\n\n\n\nAutocorrelación Espacial"
  },
  {
    "objectID": "espacial_r.html#introducción",
    "href": "espacial_r.html#introducción",
    "title": "Objetos Espaciales en R",
    "section": "Introducción",
    "text": "Introducción\nLos objetos espaciales en R representan datos georreferenciados, lo que significa que están vinculados a una ubicación en el mundo real. Los objetos espaciales se pueden representar en mapas y gráficos, y se pueden analizar para identificar patrones y tendencias en los datos.\nEl análisis espacial se utiliza en diversas áreas, como la geografía, la ecología, la planificación urbana y el análisis de datos de negocios, entre otros. La visualización y análisis de objetos espaciales puede proporcionar información valiosa para la toma de decisiones basada en datos."
  },
  {
    "objectID": "espacial_r.html#lectura-de-insumos-espaciales",
    "href": "espacial_r.html#lectura-de-insumos-espaciales",
    "title": "Objetos Espaciales en R",
    "section": "Lectura de Insumos Espaciales",
    "text": "Lectura de Insumos Espaciales\n\n# install.packages(\"sf\")\nlibrary(sf)\ncrs_ll &lt;- \"+proj=longlat +datum=WGS84 +no_defs\"\ncrs_utm &lt;- \"+proj=utm +zone=19 +south +datum=WGS84 +units=m +no_defs +ellps=WGS84 +towgs84=0,0,0\"\ncenso &lt;-  readRDS(\"data/censo/zonas_urb_consolidadas.rds\")"
  },
  {
    "objectID": "espacial_r.html#transformar-a-objeto-sf-simple-features",
    "href": "espacial_r.html#transformar-a-objeto-sf-simple-features",
    "title": "Objetos Espaciales en R",
    "section": "Transformar a objeto sf (simple features)",
    "text": "Transformar a objeto sf (simple features)\n\n# transformar a objeto sf (simple features)\ncenso_sf &lt;- st_as_sf(censo)\n# head(censo_sf)\nnames(censo_sf)\n\n [1] \"REGION\"     \"NOM_REGION\" \"PROVINCIA\"  \"NOM_PROVIN\" \"COMUNA\"    \n [6] \"NOM_COMUNA\" \"URBANO\"     \"DISTRITO\"   \"LOC_ZON\"    \"GEOCODIGO\" \n[11] \"AREA\"       \"COD_INE_15\" \"COD_INE_16\" \"VALIDO\"     \"KM2\"       \n[16] \"ESC_JH\"     \"PERS\"       \"M2_O\"       \"M2_C\"       \"DENS_HAB\"  \n[21] \"DENS_OF\"    \"DENS_COM\"   \"geometry\""
  },
  {
    "objectID": "espacial_r.html#filtros-espaciales-por-data",
    "href": "espacial_r.html#filtros-espaciales-por-data",
    "title": "Objetos Espaciales en R",
    "section": "Filtros espaciales por data",
    "text": "Filtros espaciales por data\n\nlibrary(dplyr)\nmi_communa &lt;-  \"LAS CONDES\"\n\nzonas_com &lt;-  censo_sf %&gt;% \n  filter(NOM_COMUNA == mi_communa)\n\nzonas_com %&gt;% head()\n\nSimple feature collection with 6 features and 22 fields\nGeometry type: MULTIPOLYGON\nDimension:     XY\nBounding box:  xmin: -70.56629 ymin: -33.41713 xmax: -70.47884 ymax: -33.36421\nGeodetic CRS:  +proj=longlat +datum=WGS84 +ellps=WGS84 +towgs84=0,0,0\n  REGION                       NOM_REGION PROVINCIA NOM_PROVIN COMUNA\n1     13 REGIÓN METROPOLITANA DE SANTIAGO       131   SANTIAGO  13114\n2     13 REGIÓN METROPOLITANA DE SANTIAGO       131   SANTIAGO  13114\n3     13 REGIÓN METROPOLITANA DE SANTIAGO       131   SANTIAGO  13114\n4     13 REGIÓN METROPOLITANA DE SANTIAGO       131   SANTIAGO  13114\n5     13 REGIÓN METROPOLITANA DE SANTIAGO       131   SANTIAGO  13114\n6     13 REGIÓN METROPOLITANA DE SANTIAGO       131   SANTIAGO  13114\n  NOM_COMUNA     URBANO DISTRITO LOC_ZON   GEOCODIGO      AREA  COD_INE_15\n1 LAS CONDES LAS CONDES        5       1 13114051001  346506.4 13114051001\n2 LAS CONDES LAS CONDES        4       1 13114041001 2797019.6 13114041001\n3 LAS CONDES LAS CONDES        4       3 13114041003 2530681.2 13114041003\n4 LAS CONDES LAS CONDES       16       2 13114161002 1497554.8 13114161002\n5 LAS CONDES LAS CONDES       15       3 13114151003  855603.3 13114151003\n6 LAS CONDES LAS CONDES        2       2 13114021002  594053.2 13114021002\n   COD_INE_16 VALIDO       KM2   ESC_JH PERS       M2_O      M2_C  DENS_HAB\n1 13114051001   TRUE 0.3465064 16.08958 4173  10910.000  18578.00 12043.068\n2 13114041001   TRUE 2.7970196 16.34331 4788   5820.806  48723.11  1711.822\n3 13114041003   TRUE 2.5306812 16.19528 6315 125513.194  84384.89  2495.376\n4 13114161002   TRUE 1.4975548 16.75400 2250    738.000     72.00  1502.449\n5 13114151003   TRUE 0.8556033 16.84848 4675   1130.005  51982.94  5463.981\n6 13114021002   TRUE 0.5940532 15.85904 3987  24382.000 298226.00  6711.520\n     DENS_OF     DENS_COM                       geometry\n1 31485.7121  53615.17494 MULTIPOLYGON (((-70.56008 -...\n2  2081.0745  17419.65356 MULTIPOLYGON (((-70.47951 -...\n3 49596.6041  33344.73221 MULTIPOLYGON (((-70.5267 -3...\n4   492.8033     48.07838 MULTIPOLYGON (((-70.50789 -...\n5  1320.7117  60755.89536 MULTIPOLYGON (((-70.51477 -...\n6 41043.4616 502019.00493 MULTIPOLYGON (((-70.53606 -..."
  },
  {
    "objectID": "espacial_r.html#visualización-cartográficas",
    "href": "espacial_r.html#visualización-cartográficas",
    "title": "Objetos Espaciales en R",
    "section": "Visualización Cartográficas",
    "text": "Visualización Cartográficas\n\nVisualización estática Simple\n\n## Visualizar\n# Consideración el plot se realiza sobre la columna geometry\n\nnombre_plot &lt;-  paste0(\"COMUNA DE \", mi_communa)\nplot(zonas_com$geometry, main = nombre_plot,col =\"orange\")\n\n\n\n\n\n\n\n\n\n\nVisualización estática con ggplot2\n\nlibrary(ggplot2)\n\n# Visualización ggplot y sf\nggplot() +\n  geom_sf(data = zonas_com, fill = \"orange\", alpha=0.5)+\n  ggtitle(nombre_plot) +\n  theme_bw() +\n  theme(legend.position=\"none\")+\n  theme(panel.grid.major = element_line(colour = \"gray80\"),\n        panel.grid.minor = element_line(colour = \"gray80\"))\n\n\n\n\n\n\n\n\n\n\nVisualización Dinámica con mapview\n\n# install.packages(\"mapview\")\nlibrary(mapview)\nm &lt;- mapview(zonas_com, alpha = 0.5,\n        col.regions = \"orange\", color=\"gray80\",\n        legend =FALSE, cex = 3)\nm"
  },
  {
    "objectID": "espacial_r.html#referencias",
    "href": "espacial_r.html#referencias",
    "title": "Objetos Espaciales en R",
    "section": "Referencias:",
    "text": "Referencias:\n\nSimple Features for R"
  },
  {
    "objectID": "luces_nocturnas.html#objetivos",
    "href": "luces_nocturnas.html#objetivos",
    "title": "Luces Nocturnas con GEE",
    "section": "Objetivos",
    "text": "Objetivos\nConstruir un indicador territorial que represente la luminosidad nocturna, cuya unidad mínima sea manzana urbana y entidad rural, a nivel país que se denominará “Indicador de Iluminosidad Nocturna (ILN)."
  },
  {
    "objectID": "luces_nocturnas.html#metodología",
    "href": "luces_nocturnas.html#metodología",
    "title": "Luces Nocturnas con GEE",
    "section": "Metodología",
    "text": "Metodología\nDe forma general se utilizará como base producto satelital llamado VIIRS Stray Light Corrected Nighttime Day/Night Band Composites Version 1, que entrega valores de radiancia media mensual del infrarojo visible, utilizando la plataflorma de GEE para su adquisición y procesamiento.\nSe definirá una región de estudio, paral el caso práctico de cálculo es la área urbana de las comunas de Valparaíso y Viña del Mar en la V Región, se le aplicará un buffer de 1000 metros y se cortará imagen tipo raster obtendida del producto satelital antes mecionado.\nFinalmente se procederá extraer el valor de indicador por unidad territorial mínima, manzana urbana y entidad censal, mediante el cáculo del promedio de los valores de pixeles que contiene en su interior, y este valor será el del indicador ILN. Para tener control de flujo de este proceso se rezarará mediante un ciclo interativo por Distrito censal, en caso de caerse la conexión con GEE, se puede continuar en el distrito correcto, sin perder lo avanzado."
  },
  {
    "objectID": "luces_nocturnas.html#producto-satelital",
    "href": "luces_nocturnas.html#producto-satelital",
    "title": "Luces Nocturnas con GEE",
    "section": "Producto Satelital",
    "text": "Producto Satelital\n\nNombre:\n\nVIIRS Stray Light Corrected Nighttime Day/Night Band Composites Version 1\n\nDescripción:\n\nImágenes compuestas de radiancia media mensual utilizando datos nocturnos del Visible Infrared Imaging Radiometer Suite (VIIRS) Day/Night Band (DNB).\nComo estos datos se componen mensualmente, hay muchas zonas del planeta en las que es imposible obtener una cobertura de datos de buena calidad para ese mes. Esto puede deberse a la nubosidad, especialmente en las regiones tropicales, o a la iluminación solar, como ocurre hacia los polos en sus respectivos meses de verano. Por lo tanto, se recomienda que los usuarios de estos datos utilicen la banda ‘cf_cvg’ y no asuman que un valor de cero en la imagen de radiancia media significa que no se observaron luces.\nLa cobertura de nubes se determina utilizando el producto VIIRS Cloud Mask (VCM). Además, los datos cercanos a los bordes de la franja no se incluyen en los compuestos (zonas de agregación 29-32). La versión 1 NO ha sido filtrada para separar las luces de la aurora, los incendios, los barcos y otras luces temporales. Esta separación está en desarrollo y se incluirá en una versión posterior de esta serie temporal. También está en desarrollo un método para separar las luces de los valores de fondo (no luces).\nEste producto es una configuración alternativa del DNB de VIIRS que utiliza un procedimiento para corregir la luz parásita. El procedimiento de corrección extiende las áreas visibles más cerca de los polos y mejora el rango dinámico. Hay que tener en cuenta que se introducen algunos artefactos debido al procedimiento utilizado en las regiones crepusculares; véase el documento de referencia para más detalles. Este producto excluye los datos afectados por la nubosidad.\n\nBandas:\n\nResolution: 463.83 meters\n\n\n\nInformación de Producto Satelital\n\n\nName\nUnits\nMin\nMax\nDescription\n\n\n\n\navg_rad\nnanoWatts/cm2/sr\n-1.5*\n193565*\nAverage DNB radiance values.\n\n\ncf_cvg\nNA\n0*\n84*\nCloud-free coverages; the total number of observations that went into each pixel. This band can be used to identify areas with low numbers of observations where the quality is reduced.\n\n\n\n\n\n\n\n\n\n\nEstimated min or max value"
  },
  {
    "objectID": "luces_nocturnas.html#cálculo",
    "href": "luces_nocturnas.html#cálculo",
    "title": "Luces Nocturnas con GEE",
    "section": "Cálculo",
    "text": "Cálculo\nA continuación se define el flujo de trabajo para calcular el indicador de ILN.\n\nCargar Librerías\n\nlibrary(dplyr)\nlibrary(sf)\nlibrary(mapview)\nlibrary(ggplot2)\nlibrary(viridis)\nlibrary(rgee)\nee_Initialize()\n\n── rgee 1.1.7 ─────────────────────────────────────── earthengine-api 0.1.374 ── \n ✔ user: not_defined \n ✔ Initializing Google Earth Engine:\n ✔ Initializing Google Earth Engine:  DONE!\n\n ✔ Earth Engine account: users/denisberroeta \n\n ✔ Python Path: /opt/homebrew/Caskroom/miniforge/base/envs/gee/bin/python \n──────────────────────────────────────────────────────────────────────────────── \n\n\n\n\nDefinición de Área de Estudio\nPara este ejemplo se definirá como área de estudio las zonas urbanas del gran Valparaíso. Para esto tenemos un archivo tipo llamado Zonas_Censales_2017_Nacional.rds tipo polígonos espaciales, que corresponden a zonas censales (INE) que son urbanas únicamente. Estas geometrías se utilizarán únicamente para definir la región de estudio.\n\nzonas_ine &lt;- readRDS(\"data/censo/zonas_urb_consolidadas.rds\")\n\nA continuación utilizaremos las zonas censales, para definir una región de estudio general, filtrando las comuna de nuestro interés en este caso las comunas de Valparaíso y Viña del Mar.Debemos tener especial cuidado en el Sistema de Referencias de Coordenadas (CRS), ya que necesitamos que en coordenadas geográfica EPSG(4326), si está en algún otro CRS, se puede transformar utilizando la función st_transform(). Posterriormente se ibuja una geometría única que toma solamente el contorno de las zonas censales filtradas utilizando la función st_union. Finalmente a esta geometría única se le aplicarà un buffer (st_buffer()) de 1000 metros, a fin de asegurarnos que no queden partes de polígonos sin curbrir con el raster.\n\nmis_comunas &lt;- c(\"VALPARAÍSO\", \"VIÑA DEL MAR\")\nae &lt;- zonas_ine %&gt;%\n  st_as_sf() %&gt;%\n  filter(NOM_COMUNA %in% mis_comunas) %&gt;%\n  st_transform(4326) %&gt;%\n  st_union() %&gt;%\n  st_buffer(1000)\n\nA continuación se visualiza el área de\n\nmapview(ae)\n\n\n\n\n\nTrannsformar a formato soportado por google earth Engine\n\nae_ee &lt;- ae %&gt;% sf_as_ee()\n\n\n\nLectura de Producto Satelital\n\ndataset &lt;-  ee$ImageCollection('NOAA/VIIRS/DNB/MONTHLY_V1/VCMSLCFG')$\n  filterDate('2020-01-01', '2020-12-01')$\n  select(\"avg_rad\")$\n  median()\n\nimagen &lt;- dataset$clip(ae_ee)\n\n\nvis &lt;- list(min = 0, max = 60,\n            palette = c('0602ff', '235cb1', '307ef3', '269db1', '30c8e2',\n                        '32d3ef', '3ae237','b5e22e', 'd6e21f', 'fff705',\n                        'ffd611', 'ffb613', 'ff8b13', 'ff6e08', 'ff500d',\n                        'ff0000', 'de0101', 'c21301'))\n\n\nregion &lt;- ae_ee$bounds()\n\nVisualización del producto satelital\n\nMap$centerObject(region, zoom = 11)\nMap$addLayer(imagen, vis, name = \"Nighttime\")\n\n\n\n\n\n\n\nCálculo de Indicador\n\nmz_comuna &lt;- readRDS(\"data/censo/manzanas.rds\") %&gt;% \n  filter(NOM_COM %in% mis_comunas) %&gt;%\n  mutate(DISTRITO = substr(COD_ZON, 5, 7)) %&gt;% \n  st_transform(4326)\n# mapview(valpo_mz, zcol = \"PERSONAS\")\n\nEs un proceso costoso computacionalmente, lo que toma un tiempo cercano a 3 minutos, es recomendable iterar por Distrito Censalcon objetivo si se cae la conexión con GEE en medio del cálculo, podriamos recomenzar eventualmente en el distrito censal donde se paro la instrucción.\n\nmz_lum &lt;- NULL\nfor(distrito in unique(mz_comuna$DISTRITO)){\n  print(paste0(\"Procesando DISTRITO censal \", distrito))\n  mz_filtrada &lt;- mz_comuna %&gt;%\n    filter(DISTRITO == distrito)\n  # calculando  la luminosidad\n  mz_luminocidad &lt;- ee_extract(x = imagen, y = mz_filtrada,\n                               sf = T,scale = 500,\n                               fun =ee$Reducer$mean())\n  mz_lum &lt;- rbind(mz_lum, mz_luminocidad)\n}\n\nGuardar los resultados del objeto espacial generado en formato rds\n\nsaveRDS(mz_lum, \"data/shape/luces_noc_gran_valpo.rds\")\n\n\n\n\n\n# mapview::mapview(mz_lum, zcol = \"avg_rad\")\n\n# vislauzación cartografica\nind_LN &lt;- ggplot() + \n  geom_sf(data = mz_lum, aes(fill = avg_rad), color=NA) + \n  scale_fill_viridis()+ theme_bw()+\n  # xlab( \"longitud\") + ylab(\"latitud\")+\n  labs(title = \"ILN: Indicador de Luces Nocturnas\", \n       subtitle = \"Utilizando Google Earth Engine\",\n       fill = \"ILN\")+\n  theme(panel.grid.major = element_line(colour = \"gray94\"), \n      panel.grid.minor = element_line(colour = \"gray94\"), \n      plot.title = element_text(hjust = 0.5, size = rel(0.9)), \n      plot.subtitle = element_text(hjust = 0.5, size = rel(0.7)),\n      legend.title = element_text(size = rel(0.7)),\n      panel.background = element_rect(fill = \"gray100\"),\n      axis.text.x = element_text(color = \"grey20\", size = rel(0.7)),\n      axis.text.y = element_text(color = \"grey20\", size = rel(0.7))) \nind_LN"
  },
  {
    "objectID": "john_snow.html#historia",
    "href": "john_snow.html#historia",
    "title": "Mapa de Cólera",
    "section": "Historia",
    "text": "Historia\nEn el siglo XIX, un médico inglés llamado John Snow dejó una huella indeleble en la historia de la epidemiología, convirtiéndose en el padre de esta disciplina. Aunque sus contribuciones al campo de la anestesia son notables, es su trabajo pionero en el análisis de datos y la visualización lo que lo hace memorable. Su hazaña más destacada: el mapa de las muertes en el Soho durante el brote de cólera de 1854. Este brote, que causó estragos en la población de Londres, se atribuyó en su mayoría al comercio de la marina mercante, al hacinamiento y a la insalubridad de las calles de una ciudad cuya población superaba los dos millones de habitantes. Sin embargo, John Snow se destacó por desafiar la creencia común de su época, sosteniendo que el cólera se transmitía a través de fuentes de agua contaminadas en lugar de la propagación por el aire.\nExploraremos la increíble odisea de John Snow mientras trataba de probar su teoría, demostrando la verdadera causa del brote de cólera de 1854 en Soho. Su famoso mapa, que trazaba las defunciones, reveló un patrón sorprendente: la mayoría de las muertes se concentraban en las cercanías de una bomba de agua pública. Este episodio no solo marcó un hito en la historia de la epidemiología, sino que también ilustra las complejidades y desafíos de superar el sesgo de confirmación arraigado en la teoría predominante de la transmisión del cólera por miasmas1.\nEn el libro “The Ghost Map”, de Steven Johnson, se relata la actuación de Snow en la identificación del origen del brote de cólera del Soho de 1854, destaca el ingenio y la perseverancia de John Snow en la búsqueda de la verdad científica, trascendiendo las barreras de la creencia convencional. Esta es la historia de un médico que no solo cambió la forma en que entendemos las enfermedades, sino también la importancia del análisis espacial y la visualización de datos en la ciencia."
  },
  {
    "objectID": "john_snow.html#importancia-del-mapa",
    "href": "john_snow.html#importancia-del-mapa",
    "title": "Mapa de Cólera",
    "section": "Importancia del Mapa",
    "text": "Importancia del Mapa\nA principios de septiembre de 1854, un pequeño sector de Londres llamado Golden Square fue escenario de un brote epidémico de cólera de inusual intensidad, costando la vida a cerca de 500 personas en tan sólo 10 días. Snow planteó que el severo brote de cólera en Golden Square se debía a la ingestión de aguas contaminadas provenientes de esta bomba y se propuso, firmemente, demostrarlo. (L and C 2007).\nJohn Snow venía utilizando desde hacía tiempo mapas en sus artículos y exposiciones como ayuda a la hora de argumentar sus hipótesis, por lo que aprovechó para comprar un mapa del barrio y, ayudado del párroco local Henry Whitehead, ir anotando en él las muertes que se habían producido por cólera en el mes de septiembre. Para ello recurrió al trabajo de campo, visitando uno por uno los edificios del área afectada, y ayudándose de los registros del hospital de Middlesex, a donde se trasladaban muchas de las víctimas.\n\n\n\nMapa en el cual Jonh Snow fue registrando las muertes por cólera en Septiembre de 1984\n\n\nEl mapa recogía las defunciones con unas finas líneas de color negro que se iban apilando unas sobre las otras a medida que el número de decesos aumentaba. Con esta simple representación el mapa de John Snow trasmitía un claro mensaje visual al conectar incidencia con concentración. El resultado fue clarificador: la mayor parte de las muertes se habían producido en las proximidades de Broad Street. De igual manera Snow georreferenció sobre el mapa los pozos de agua, viéndose claramente como una gran cantidad de víctimas se concentraban en torno a la bomba de agua de Broad Street (L and C 2007).\nComo vecino del área, Snow sabía que la mayoría de los residentes del sector extraían el agua a partir de una bomba de uso público ubicada en Broad Street. Prontamente, confirmó que la mayoría de los moradores se abastecían de agua extraída de la bomba de Broad Street. Calculó la distancia entre la residencia de cada difunto y la bomba de agua más cercana, observando que en 73 de 83 casos era la bomba de Broad Street y que 61 de 83 difuntos bebían de sus aguas contaminadas en forma constante u ocasional.\nEntusiasmado por los hallazgos de su investigación, presentó los resultados ante la autoridad sanitaria local, quien decidió inhabilitar la bomba de Broad Street mediante la remoción de su palanca. La inhabilitación de la bomba de agua fue una medida altamente impopular entre los habitantes del sector, quienes no comprendían el sentido de la misma. Si la incidencia de casos de cólera disminuía, su teoría quedaría finalmente demostrad\nEn su planteamiento, no hacía sentido la ausencia de muertes entre los trabajadores de Lion Brewery -una cervecería aledaña a la bomba de agua- al igual que el escaso número de defunciones ocurrido en una hospedería para gente pobre, también cercana a la fuente y en la que solamente fallecieron cinco de sus 500 huéspedes. Snow averiguó que los trabajadores de la cervecería, temerosos de beber del agua de la bomba, únicamente bebían cerveza. De igual forma, la hospedería contaba con un arroyo privado para el suministro de agua potable, no necesitando del agua de la bomba. Finalmente, Snow logró recabar antecedentes de algunas personas que abandonaron el sector al inicio de la epidemia y que posteriormente fallecieron en otros puntos de la ciudad libres de cólera, demostrando que habían bebido agua extraída de la bomba de Broad Street días antes de morir."
  },
  {
    "objectID": "john_snow.html#conclusiones",
    "href": "john_snow.html#conclusiones",
    "title": "Mapa de Cólera",
    "section": "Conclusiones",
    "text": "Conclusiones\n\n\n\nRéplica de la bomba de agua situada muy cerca de la ubicación original, en Broadwick Street (la moderna Broad Street). Fue erigida en 1992 en memoria de John Snow\n\n\nTras la inhabilitación de la polémica bomba, se observó una reducción en la incidencia y mortalidad por cólera, sin embargo, esto no fue suficiente para controlar el brote epidémico. Lamentablemente, la incredulidad de las autoridades sanitarias -quienes apoyaban la teoría miasmática- y la presión popular fue más fuerte, habilitándose nuevamente su uso. Snow intentó hasta su muerte en 1858 convencer a la comunidad médica que el cólera se transmitía mediante la ingestión de una “materia mórbida” presente en las aguas contaminadas del río Támesis, pero sus esfuerzos fueron infructuosos. Su teoría debió esperar la cuarta epidemia de cólera de Londres, ocurrida en 1866, para ser finalmente aceptada. Al poco tiempo, experimentos realizados por Louis Pasteur demostraron que son microorganismos presentes en el ambiente (y no “miasmas”) los causantes de las enfermedades transmisibles. Casi tres décadas después de la muerte de Snow, Robert Koch aisló y cultivó el Vibrio cholerae, la “materia mórbida” a la cual recurrentemente se refería Snow, dándole total crédito a su hipótesis(L and C 2007).\nEn Londres, hoy en día es posible encontrar una réplica de la bomba de agua de Broad Street (actualmente Broadwick Street). Anualmente, la John Snow Society (Ramsay 2006) rinde un homenaje a su persona, retirando y reposicionando la palanca de la bomba de agua, como una forma de recordar los múltiples desafíos que enfrenta continuamente la Salud Pública alrededor del mundo.\nSin disponer de un cuerpo de conocimientos microbiológicos y epidemiológicos como el existente hoy en día, Snow apeló a sus mejores virtudes -un agudo sentido de observación, razonamiento lógico y perseverancia- para caracterizar un problema de salud, desafiando a la comunidad médica y a la autoridad sanitaria, pensando únicamente en el bienestar de la comunidad. Con justa razón John Snow es considerado el padre de la epidemiología moderna, ejemplo del espíritu que todo médico investigador debe poseer (L and C 2007)."
  },
  {
    "objectID": "john_snow.html#replicar-estudio",
    "href": "john_snow.html#replicar-estudio",
    "title": "Mapa de Cólera",
    "section": "Replicar Estudio",
    "text": "Replicar Estudio\nEn un intento de rendir homenaje a la obra de John Snow y aplicar sus principios en la era de la Ciencia de Datos, se busca replicar la icónica investigación de Snow, pero con un enfoque moderno y la técnica de estimación de densidad mediante kernels (KDE).\nUtilizando los datos muertes de Cólera de esta época se buscará determinar las concentraciones espaciales y hacer una relación de proximidad con las fuentes de agua pública, a modo de determinar origen del brode Cólera de 1854.\nEste enfoque actualizado busca demostrat cómo la ciencia de datos y la programación pueden continuar el legado de Snow en la exploración de problemas de salud pública y epidemiología a través de análisis espacial y visualización de datos avanzados.\n\nLectura de inusmos y librerías\n\n# install.packages(\"HistData\")\nlibrary(HistData)\nlibrary(dplyr)\nlibrary(sf)\nlibrary(mapview)\nlibrary(ggplot2)\nlibrary(raster)\nlibrary(ggspatial) # get basemaps\nlibrary(SpatialKDE)\n\n\nsnow_deaths &lt;- st_read(\"data/SnowGIS_SHP/Cholera_Deaths.shp\")\n\nReading layer `Cholera_Deaths' from data source \n  `/Users/denisberroeta/Library/CloudStorage/OneDrive-UniversidadAdolfoIbanez/Goblab/BDPP_Geoanalisis/geoanalisis_book/data/SnowGIS_SHP/Cholera_Deaths.shp' \n  using driver `ESRI Shapefile'\nSimple feature collection with 250 features and 2 fields\nGeometry type: POINT\nDimension:     XY\nBounding box:  xmin: 529160.3 ymin: 180857.9 xmax: 529655.9 ymax: 181306.2\nProjected CRS: OSGB36 / British National Grid\n\nsnow_pumps &lt;- st_read(\"data/SnowGIS_SHP/Pumps.shp\")\n\nReading layer `Pumps' from data source \n  `/Users/denisberroeta/Library/CloudStorage/OneDrive-UniversidadAdolfoIbanez/Goblab/BDPP_Geoanalisis/geoanalisis_book/data/SnowGIS_SHP/Pumps.shp' \n  using driver `ESRI Shapefile'\nSimple feature collection with 8 features and 1 field\nGeometry type: POINT\nDimension:     XY\nBounding box:  xmin: 529183.7 ymin: 180660.5 xmax: 529748.9 ymax: 181193.7\nProjected CRS: OSGB36 / British National Grid\n\n# epsg:27700\n# mapview(snow_deaths)+ mapview(snow_pumps, col.region = \"red\")\n\n\n\nVisualización del muertes por Cólera 1854\n\nlibrary(viridis)\ncolors = c('#f768a1','#dd3497','#7a0177','#49006a')\npal_death&lt;- colorRampPalette(colors)( max(snow_deaths$Count) )\n\nmap_snow &lt;-  ggplot(snow_deaths) +\n    annotation_map_tile(zoom = 17, \"cartolight\") +\n    geom_sf(aes(color =  Count), \n          alpha=0.5,  size= 2.5,\n            show.legend = \"point\", inherit.aes = FALSE) +\n  scale_colour_gradientn(name = \"Count Death\", \n                         colours = pal_death)+\n  geom_sf(data = snow_pumps,  color =  \"#1d91c0\", \n          alpha=0.8,  size= 4)+\n  ggtitle(\"Muertes por Cólera 1854\") +\n    # coord_sf(datum = NA) +\n  theme_minimal()\nmap_snow\n\n\n\n\n\n\n\n\n\nCálculo de Kernel Density Estimation de Muertes\nRegión de Estudio\n\nroi &lt;- st_convex_hull(st_union(snow_deaths))  %&gt;% st_as_sf()\n# mapview(roi)+mapview(snow_deaths)\n\nParámetros de KDE\n\n#Definirán Parámemetros de Estudio\ncell_size &lt;- 10 # Tamaño de Celda\nband_width &lt;- 50\n\n# grilla vacía\nraster_death &lt;- roi %&gt;% \n  create_raster(cell_size = cell_size, side_offset = band_width)\n\nCálculo de KDE\n\nkde_raster &lt;- snow_deaths %&gt;% \n  kde(band_width = band_width, kernel = \"quartic\",\n      grid = raster_death, \n      weights = snow_deaths$Count,\n      quiet = T)\n\nFiltrar valores de baja densidad\nPrimeramente se realizará un histograma para tomar una decición informada sobre el umbral mínimo de densidad.\n\nhist(kde_raster, breaks = 30, \n     col=\"#f768a1\", \n     main=\"Histograma KDE\",\n     ylab=\"Número de Pixeles\", xlab=\"valor KDE\")\n\n\n\nkde_raster[kde_raster&lt;10] &lt;- NA\n\n\nmapview(snow_deaths, col.region = \"#cb181d\", hide = T)+ \n  mapview(snow_pumps, col.region = \"#1d91c0\")+\n  mapview(kde_raster)\n\n\n\nVisualización de Resultados\nSe observa claramente la fuente de agua sobre la mayor densidad de muertes por cólera, pudiendo hacer una relación espacial.\n\n# rastero to df (na omit)\nkde_df &lt;- raster::as.data.frame(kde_raster, xy = TRUE) %&gt;%\n  na.omit()\n\nmap_snow_kde &lt;-  ggplot() +\n  geom_tile(data = kde_df ,\n            aes(x = x, y = y,\n                fill = layer)) +\n  scale_fill_gradientn(name = \"Density Death\",\n                       colours = pal_death) +\n  geom_sf(\n    data = snow_pumps,\n    color =  \"#1d91c0\",\n    alpha = 0.8,\n    size = 4\n  ) +\n  ggtitle(label = \"Muertes por cólera en Broad Street (1984)\",\n          subtitle = \"Kernel Density Estimation\") +\n  theme_bw() +\n  theme(\n    panel.grid.major = element_line(colour = \"gray80\"),\n    panel.grid.minor = element_line(colour = \"gray80\")\n  )\n\nmap_snow_kde"
  },
  {
    "objectID": "john_snow.html#referencias",
    "href": "john_snow.html#referencias",
    "title": "Mapa de Cólera",
    "section": "Referencias",
    "text": "Referencias\n\nJohn Snow, la epidemia de cólera y el nacimiento de la epidemiología moderna\n(Mostly Clinical) Epidemiology with R\nFloursh: Masters series: John Snow’s cholera map\nJohn Snow 210th Birthday Map Competition\nHistData R Package\n\n\n\n\n\nL, Jaime Cerda, and Gonzalo Valdivia C. 2007. “John Snow, La Epidemia de cólera y El Nacimiento de La Epidemiologı́a Moderna.” Revista Chilena de Infectologı́a 24 (4). https://doi.org/10.4067/s0716-10182007000400014.\n\n\nRamsay, Michael A. E. 2006. “John Snow, MD: Anaesthetist to the Queen of England and Pioneer Epidemiologist.” Baylor University Medical Center Proceedings 19 (1): 24–28. https://doi.org/10.1080/08998280.2006.11928120."
  },
  {
    "objectID": "john_snow.html#footnotes",
    "href": "john_snow.html#footnotes",
    "title": "Mapa de Cólera",
    "section": "",
    "text": "Según creencias o teorías antiguas el miasma es la sustancia fétida y perjudicial que emana de los cuerpos de seres enfermos o en estado de descomposición.↩︎"
  },
  {
    "objectID": "references.html",
    "href": "references.html",
    "title": "References",
    "section": "",
    "text": "Anselin, Luc. 1995. “Local Indicators of\nSpatial Association—LISA.”\nGeographical Analysis 27 (2): 93–115. https://doi.org/10.1111/j.1538-4632.1995.tb00338.x.\n\n\nCliff, Andrew, and Keith Ord. 1972. “Testing for Spatial\nAutocorrelation Among Regression Residuals.” Geographical\nAnalysis 4 (3): 267–84. https://doi.org/10.1111/j.1538-4632.1972.tb00475.x.\n\n\nL, Jaime Cerda, and Gonzalo Valdivia C. 2007. “John Snow, La\nEpidemia de cólera y El Nacimiento de La\nEpidemiologı́a Moderna.” Revista Chilena de\nInfectologı́a 24 (4). https://doi.org/10.4067/s0716-10182007000400014.\n\n\nLefebvre, Henri. 1974. “La Production de\nlespace.” L Homme Et La\nSociété 31 (1): 15–32. https://doi.org/10.3406/homso.1974.1855.\n\n\nP. Moran, P. a. 1948. “The Interpretation of\nStatistical Maps.” Journal of the Royal\nStatistical Society: Series B (Methodological) 10 (2): 243–51. https://doi.org/10.1111/j.2517-6161.1948.tb00012.x.\n\n\nRamsay, Michael A. E. 2006. “John Snow, MD:\nAnaesthetist to the Queen of England and Pioneer Epidemiologist.”\nBaylor University Medical Center Proceedings 19 (1): 24–28. https://doi.org/10.1080/08998280.2006.11928120.\n\n\nTobler, W. R. 1970. “A Computer Movie Simulating Urban Growth in\nthe Detroit Region.” Economic Geography 46 (June): 234.\nhttps://doi.org/10.2307/143141."
  }
]