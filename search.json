[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Curso: Geoanálisis",
    "section": "",
    "text": "Este libro corresponde al material de estudio del curso de Geoanálisis del Diplomado en Ciencia de Datos para Políticas Públicas 2022, dictado por Escuela de Gobierno de la Universidad Adolfo Ibáñez.\n\n\nEste curso se enfoca en entregar a los alumnos conocimientos teóricos y herramientas técnicas para realizar análisis espacial de variables territoriales en diferentes campos de aplicación, con énfasis en afrontar desafíos relacionado a las políticas públicas, haciendo uso de lenguaje de programación R Project, para uso de metodologías de alto nivel y de forma automatizada.\n\n\n\nEl objetivo general es proporcionar a los estudiantes los fundamentos, técnicas y aspectos básicos para analizar, modelar y representar información espacial, para apoyar la toma de decisiones con evidencia territorial robusta.\nLos objetivos específicos son:\n\nConocer los conceptos básicos del geoanálisis.\nManipular datos espaciales en R.\nConocer técnicas de inferencia, autocorrelación y regresión espacial.\nAplicar las técnicas a problemas de interés público.\n\n\n\n\n\n\n\nModulos\n\n\n\nIntroducción a la Estadística Espacial y a Datos Espaciales\nManejo y Representación de datos vectoriales, construcción de indicadores\nManejo y Representación de datos raster, construcción de indicadores\nInferencia Espacial: Interpolación y mapas de calor\nRelaciones de Vecindad y autocorrelación espacial\nModelos de Regresión Espacial\n\n\n\n\n\nProfesor:\n\nDenis Berroeta González (denis.berroeta@uai.cl)\n\n\n\nCoordinador de Investigación Centro de Inteligencia Territorial UAI\nMagister en Inteligencia Artificial FIC-UAI\nMaster of Data Science FIC-UAI (cursando)\nIngeniero en Prevención en Riesgos\n\n\nAyudante:\n\nLeonardo Rojas (leonardo.rojas@uai.cl)\n\n\n\nAnalista Centro de Inteligencia Territorial UAI\nEconomista\nMaster of Data Science FIC-UAI (cursando)"
  },
  {
    "objectID": "intro_estad_esp.html",
    "href": "intro_estad_esp.html",
    "title": "1  Introducción Estadística Espacial",
    "section": "",
    "text": "Objetivos\n\n\n\nConocer teóricos fundamentales de la estadística espacial."
  },
  {
    "objectID": "intro_estad_esp.html#origen-de-la-estadística",
    "href": "intro_estad_esp.html#origen-de-la-estadística",
    "title": "1  Introducción Estadística Espacial",
    "section": "1.2 Origen de la Estadística",
    "text": "1.2 Origen de la Estadística\nEstadística deriva del italiano statista (hombre de Estado) y se desarrolla desde la antigüedad para facilitar la gestión tributaria y estimar la capacidad bélica de un reino. Ej: censos egipcios desde el 3050 a.C.\nDurante la expansión de los imperios coloniales (siglos XVI - XIX) se desarrolla la estadística en estrecha relación con la cartografía, principalmente para la administración y dominio de territorios.\n\n\n\nOrigen de la Estadística"
  },
  {
    "objectID": "intro_estad_esp.html#estadística-vs-estadística-espacial",
    "href": "intro_estad_esp.html#estadística-vs-estadística-espacial",
    "title": "1  Introducción Estadística Espacial",
    "section": "1.3 Estadística vs Estadística Espacial",
    "text": "1.3 Estadística vs Estadística Espacial\nEstadística:\n\nAnálisis de la estructura de datos representativos de una población (en áreas arbitrarias)\nSe basa en matemáticas relativamente complejas\n\n Geoestadística\n\nAnálisis de relaciones de dependencia espacial entre datos georreferenciados\nComplejidad de cálculo que hacía inviable su uso masivo\n\n\n\n\nDependencia espacial en geoestadística"
  },
  {
    "objectID": "intro_estad_esp.html#condideraciones-generales",
    "href": "intro_estad_esp.html#condideraciones-generales",
    "title": "1  Introducción Estadística Espacial",
    "section": "1.4 Condideraciones generales",
    "text": "1.4 Condideraciones generales\nLa inferencia estadística convencional se basa en dos supuestos fundamentales\n\nLos valores de una variable se distribuyen de forma aleatoria\nLos valores de una variable son independientes unos de otros\n\nPero ninguno de estos dos supuestos se cumple al utilizar datos espaciales, ya que:\n\nLos fenómenos más próximos en el espacio están más estrechamente relacionados entre sí (Ley de Tobler, 1970) *La historia, el espacio y la sociedad se co-producen, por lo que el espacio tiene un rol activo en la reproducción y acumulación de fenómenos sociales (Lefebvre, 1974)\n\nPara resolver esta limitación existen dos enfoques principales\n\nLa econometría espacial, que trata el efecto espacial como un error y lo elimina para generar estimaciones sin sesgo\nLa geoestadística, que identifica y cuantifica el efecto que el espacio genera en la estructura de la información"
  },
  {
    "objectID": "intro_estad_esp.html#ejemplos-de-correlación-espacial",
    "href": "intro_estad_esp.html#ejemplos-de-correlación-espacial",
    "title": "1  Introducción Estadística Espacial",
    "section": "1.5 Ejemplos de Correlación Espacial",
    "text": "1.5 Ejemplos de Correlación Espacial\n\n1.5.1 Autoproducción: Tráfico de Drogas\n\n\n\nAutoproducción Espacial en tráfico de Drogas\n\n\n\n\n1.5.2 Co-producción: Mercado inmobiliario local\n\n\n\nCo-producción Espacial en Mercado inmobiliario local\n\n\n\n\n1.5.3 Segregación y delincuencia\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nSegregación y delincuencia\n\n\n\n\n1.5.4 Valores de Vivienda\n\n\n\nValores de Vivienda"
  },
  {
    "objectID": "intro_estad_esp.html#inconsistencia-estadística-de-datos-espaciales-agregados-maup",
    "href": "intro_estad_esp.html#inconsistencia-estadística-de-datos-espaciales-agregados-maup",
    "title": "1  Introducción Estadística Espacial",
    "section": "1.6 Inconsistencia estadística de datos espaciales agregados: MAUP",
    "text": "1.6 Inconsistencia estadística de datos espaciales agregados: MAUP\nModifiable Areal Unit Problem: inconsistencia de indicadores estadísticos al modificar los perímetros de agregación (Gehlke & Biehl 1934, Openshaw & Taylor 1979)\n\n\n\nModifiable Areal Unit Problem\n\n\nEn general, es recomendable trabajar con datos a la menor escala posible, o agregarlos en zonas homogéneas"
  },
  {
    "objectID": "datos_espaciales.html",
    "href": "datos_espaciales.html",
    "title": "2  Introducción a Datos Espaciales",
    "section": "",
    "text": "La presente Sesión tiene como objetivo principal introducir conceptos generales y manipulación básica de datos de tipo vectorial (punto, lineas, polígonos) y Raster, ambos con casos prácticos."
  },
  {
    "objectID": "datos_espaciales.html#definición-general-de-datos-espaciales",
    "href": "datos_espaciales.html#definición-general-de-datos-espaciales",
    "title": "2  Introducción a Datos Espaciales",
    "section": "2.2 Definición General de Datos Espaciales",
    "text": "2.2 Definición General de Datos Espaciales\nLa representación de un territorio requiere datos geográficos compuestos por información espacial (geometrías asociadas a una ubicación real en el mundo) e información de atributos (características y variables asociadas a estas geometrías). Los tipos de datos espaciales principalmente los vectores y raster.\n\n\n\nCapas de datos espaciales"
  },
  {
    "objectID": "datos_espaciales.html#datos-vectoriales",
    "href": "datos_espaciales.html#datos-vectoriales",
    "title": "2  Introducción a Datos Espaciales",
    "section": "2.3 Datos Vectoriales",
    "text": "2.3 Datos Vectoriales\n\nDatos Vectoriales\n\nRepresentación mediante coordenadas que se pueden unir espacialmente o no. Corresponde a 3 tipos de geometrías: puntos, líneas y polígonos.\n\n\n\nFuente: https://r-spatial.github.io/sf/articles/sf1.html\n\nPuntos\n\nTiene un par de coordenadas “x” e “y”. Es utilizado para información de tipo puntual, como por ejemplo equipamiento urbano, postes, árboles, entre otros.\n\n\n\n\n\nObjeto vectorial tipo punto\n\n\nCargar librerías\n\n# install.packages(\"sf\") \nlibrary(sf) # manipulación de datos vectoriales\nlibrary(mapview) # visualización de mapas dinámicos\nlibrary(ggplot2) # gráficos\nlibrary(RColorBrewer) #paleta de colores\n\n\n2.3.1 Lectura de archivos tipo puntos\n\nsii_LC <- st_read(\"data/sii/sii_urbe_LC.shp\")\n\nReading layer `sii_urbe_LC' from data source \n  `/Users/denisberroeta/Library/CloudStorage/OneDrive-UniversidadAdolfoIbanez/Goblab/BDPP_2022/geoanalisis_book/data/sii/sii_urbe_LC.shp' \n  using driver `ESRI Shapefile'\nSimple feature collection with 2310 features and 11 fields\nGeometry type: POINT\nDimension:     XY\nBounding box:  xmin: -70.60645 ymin: -33.44471 xmax: -70.47083 ymax: -33.36548\nGeodetic CRS:  GCS_unknown\n\n\n\n\n2.3.2 Visualización de los puntos\n\n# Visualización ggplot y sf\nggplot() +\n  geom_sf(data = sii_LC, col = \"orange\", alpha=0.8,  size= 0.5)+\n  ggtitle(\"Datos del SII en Las Condes\" ) +\n  theme_bw() +\n  theme(legend.position=\"none\")+\n  theme(panel.grid.major = element_line(colour = \"gray80\"), \n        panel.grid.minor = element_line(colour = \"gray80\"))\n\n\n\n# mapview(sii_LC, zcol = \"atractor\", cex =2)\n\n\nLíneas\n\nTiene tantas coordenadas como vértices. La información que representa es de tipo lineal, como por ejemplo calles, ríos, redes energéticas, entre otros. Existen las líneas cerradas, las cuales se pueden entender como el perímetro de una superficie (sin relleno).\n\n\n\n\n\nObjeto vectorial tipo Línea\n\n\n\n\n2.3.3 Lectura de líneas\n\nlas_condes_red <- readRDS(\"data/redes/RED_LAS_CONDES.rds\") \n# las_condes_red\n\n\n\n2.3.4 visualización Líneas\n\nggplot() +\n  geom_sf(data = las_condes_red, col = \"gray70\", alpha=0.8,  size= 0.5)+\n  ggtitle(\"Red víal de la comuna Las Condes\" ) +\n  theme_bw() +\n  theme(legend.position=\"none\")+\n  theme(panel.grid.major = element_line(colour = \"gray80\"), \n        panel.grid.minor = element_line(colour = \"gray80\"))\n\n\n\n# mapview(las_condes_red)\n\n\nPolígonos\n\nTiene tantas coordenadas como vértices. La información que representa es de tipo área, como por ejemplo división política administrativa, manzanas, construcciones, entre otras.\n\n\n\n\n\nObjeto vectorial tipo polígono\n\n\n\n\n2.3.5 Lectura de polígonos\n\nlas_condes_mz <- st_read(\"data/shape/icv_las_condes.shp\", quiet=T) \n# las_condes_ptos\n\n\n\n2.3.6 Visualización polígonos\n\nggplot() +\n  geom_sf(data = las_condes_mz, aes(fill = veg_cob), color =\"gray80\", \n          alpha=0.8,  size= 0.1)+\n  scale_fill_distiller(palette=\"Greens\", direction = 1)+\n  ggtitle(\"Cobertura Vegetal de la comuna Las Condes\" ) +\n  theme_bw() +\n  theme(panel.grid.major = element_line(colour = \"gray80\"), \n        panel.grid.minor = element_line(colour = \"gray80\"))\n\n\n\n# mapview(las_condes_mz, zcol = \"veg_cob\")\n\nTabla General de tipo de Datos Vectoriales\n\n\n\n\n\n\n\ntype\ndescription\n\n\n\n\nPOINT\nzero-dimensional geometry containing a single point\n\n\nLINESTRING\nsequence of points connected by straight, non-self intersecting line pieces; one-dimensional geometry\n\n\nPOLYGON\ngeometry with a positive area (two-dimensional); sequence of points form a closed, non-self intersecting ring; the first ring denotes the exterior ring, zero or more subsequent rings denote holes in this exterior ring\n\n\nMULTIPOINT\nset of points; a MULTIPOINT is simple if no two Points in the MULTIPOINT are equal\n\n\nMULTILINESTRING\nset of linestrings\n\n\nMULTIPOLYGON\nset of polygons\n\n\nGEOMETRYCOLLECTION\nset of geometries of any type except GEOMETRYCOLLECTION\n\n\n\n\n\n\nCapas de datos tipos raster y vectores"
  },
  {
    "objectID": "datos_espaciales.html#datos-raster",
    "href": "datos_espaciales.html#datos-raster",
    "title": "2  Introducción a Datos Espaciales",
    "section": "2.4 Datos Raster",
    "text": "2.4 Datos Raster\n\nRaster\n\nRepresentación del espacio mediante una matriz de celdas organizada en filas y columnas, donde cada celda tiene un valor que representa información.\n\n\n\n\n\nRepresentación Raster\n\n\n\n\n\nResolución Raster\n\n\nPara ejemplificar el uso y ver características de Raster vamos a utilizar una imágenes satelital del Satelite Landsat 8.\n\n\n\nImágenes Satelitales\n\n\nEste tipos de imágenes satelitales generalmente contiene una series de de bandas que corresponden a capas de información tipos raster conformando una especie de brick de raster.\n\n\n\nConfiguración de Bandas\n\n\nPara este ejemplo de visualización necesitamos conocer las bandas satelitales que componen nuestra imagen satelital.\n\n\n\nBandas de Landsat 8\n\n\n\n2.4.1 lectura de imagen Raster.\n\nlibrary(raster)\nlas_condes_raster <- brick(\"data/raster/OLI_LC.tif\")\nnames(las_condes_raster) <- c(\"aerosol\", \"blue\", \"green\", \"red\" , \"nir\", \"swir1\", \"swir2\", \"tirs1\")\nlas_condes_raster\n\nclass      : RasterBrick \ndimensions : 449, 562, 252338, 8  (nrow, ncol, ncell, nlayers)\nresolution : 30, 30  (x, y)\nextent     : 350505, 367365, 6293905, 6307375  (xmin, xmax, ymin, ymax)\ncrs        : +proj=utm +zone=19 +south +datum=WGS84 +units=m +no_defs \nsource     : OLI_LC.tif \nnames      : aerosol,  blue, green,   red,   nir, swir1, swir2, tirs1 \nmin values :    8465,  7604,  6500,  5924,  5520,  5191,  5197,  5002 \nmax values :   19119, 20517, 21248, 23237, 29344, 30012, 31166,  5512 \n\n\n\n\n2.4.2 Visualización Raster\n\n# Visualización de imagen recortada de Las Condes en Color Natural\nplotRGB(las_condes_raster, r = 4, g = 3, b = 2, stretch = \"lin\")\n\n\n\n# viewRGB(las_condes_raster, r = 4, g = 3, b = 2)"
  },
  {
    "objectID": "datos_espaciales.html#sistema-de-referencias-de-coordenadas",
    "href": "datos_espaciales.html#sistema-de-referencias-de-coordenadas",
    "title": "2  Introducción a Datos Espaciales",
    "section": "2.5 Sistema de Referencias de Coordenadas",
    "text": "2.5 Sistema de Referencias de Coordenadas\n\n\n\nSistema de Referencias de Coordenadas\n\n\nLos sistemas de coordenadas forman la base de cálculo para describir la posición de un punto a partir de mediciones geodésicas: distancias, proporciones de distancias (sin escala) y ángulos. Las coordenadas nunca pueden medirse, solamente se calculan con referencia un sistema de coordenadas bien definido. Los tipos de sistemas de coordenadas principales que existen son:\n\nCoordenadas elipsoidales\n\nson la representación de las coordenadas sobre la superficie de un elipsoide determinado, se representan por [φ, λ, h] siendo respectivamente, la latitud, longitud y altura elipsoidal.\n\n\n\n\n\nCoordenadas Geodésicas. Fuente: (Drewes & Sánchez, 2011)\n\n\n\nCoordenadas proyectadas o cartográficas\n\nSegún la proyección empleada las coordenadas elipsoidales pueden representarse en un plano, en el caso de Chile continental, se emplea la proyección Universal Transversal de Mercator (UTM), huso 19 y huso 18.\n\n\n\n\n\nproyección Universal Transversal Mercator (UTM) Fuente: (Drewes & Sánchez, 2011)\n\n\nPara hacer reproyecciones en R, se le tiene que asignar el Sistema de Referencia de Coordenadas de dos formas, uno como cadena de texto (\"+proj=longlat +datum=WGS84 +no_defs\") o como número que corresponde a EPSG (EPSG es el acrónimo de European Petroleum Survey Group) que representan sistema de referencia de coordenadas también.\nPara el caso de Chile usamos dos sistemas de referencias de coordenadas:\n\nCoordenadas elipsoidales (geodésicas):\n\n4326 o \"+proj=longlat +datum=WGS84 +no_defs\"\n\nCoordenadas proyectadas (métricas):\n\n32719 o \"+proj=utm +zone=19 +south +datum=WGS84 +units=m +no_defs\"\n\n\n\n2.5.1 Reproyectar Vectores\n\nLC_mz_32719 <- las_condes_mz %>% st_transform(32719)\nst_crs(LC_mz_32719)\n\nCoordinate Reference System:\n  User input: EPSG:32719 \n  wkt:\nPROJCRS[\"WGS 84 / UTM zone 19S\",\n    BASEGEOGCRS[\"WGS 84\",\n        ENSEMBLE[\"World Geodetic System 1984 ensemble\",\n            MEMBER[\"World Geodetic System 1984 (Transit)\"],\n            MEMBER[\"World Geodetic System 1984 (G730)\"],\n            MEMBER[\"World Geodetic System 1984 (G873)\"],\n            MEMBER[\"World Geodetic System 1984 (G1150)\"],\n            MEMBER[\"World Geodetic System 1984 (G1674)\"],\n            MEMBER[\"World Geodetic System 1984 (G1762)\"],\n            MEMBER[\"World Geodetic System 1984 (G2139)\"],\n            ELLIPSOID[\"WGS 84\",6378137,298.257223563,\n                LENGTHUNIT[\"metre\",1]],\n            ENSEMBLEACCURACY[2.0]],\n        PRIMEM[\"Greenwich\",0,\n            ANGLEUNIT[\"degree\",0.0174532925199433]],\n        ID[\"EPSG\",4326]],\n    CONVERSION[\"UTM zone 19S\",\n        METHOD[\"Transverse Mercator\",\n            ID[\"EPSG\",9807]],\n        PARAMETER[\"Latitude of natural origin\",0,\n            ANGLEUNIT[\"degree\",0.0174532925199433],\n            ID[\"EPSG\",8801]],\n        PARAMETER[\"Longitude of natural origin\",-69,\n            ANGLEUNIT[\"degree\",0.0174532925199433],\n            ID[\"EPSG\",8802]],\n        PARAMETER[\"Scale factor at natural origin\",0.9996,\n            SCALEUNIT[\"unity\",1],\n            ID[\"EPSG\",8805]],\n        PARAMETER[\"False easting\",500000,\n            LENGTHUNIT[\"metre\",1],\n            ID[\"EPSG\",8806]],\n        PARAMETER[\"False northing\",10000000,\n            LENGTHUNIT[\"metre\",1],\n            ID[\"EPSG\",8807]]],\n    CS[Cartesian,2],\n        AXIS[\"(E)\",east,\n            ORDER[1],\n            LENGTHUNIT[\"metre\",1]],\n        AXIS[\"(N)\",north,\n            ORDER[2],\n            LENGTHUNIT[\"metre\",1]],\n    USAGE[\n        SCOPE[\"Engineering survey, topographic mapping.\"],\n        AREA[\"Between 72°W and 66°W, southern hemisphere between 80°S and equator, onshore and offshore. Argentina. Bolivia. Brazil. Chile. Colombia. Peru.\"],\n        BBOX[-80,-72,0,-66]],\n    ID[\"EPSG\",32719]]\n\n\n\n\n2.5.2 Reproyectar Raster\n\nlas_condes_raster\n\nclass      : RasterBrick \ndimensions : 449, 562, 252338, 8  (nrow, ncol, ncell, nlayers)\nresolution : 30, 30  (x, y)\nextent     : 350505, 367365, 6293905, 6307375  (xmin, xmax, ymin, ymax)\ncrs        : +proj=utm +zone=19 +south +datum=WGS84 +units=m +no_defs \nsource     : OLI_LC.tif \nnames      : aerosol,  blue, green,   red,   nir, swir1, swir2, tirs1 \nmin values :    8465,  7604,  6500,  5924,  5520,  5191,  5197,  5002 \nmax values :   19119, 20517, 21248, 23237, 29344, 30012, 31166,  5512 \n\ncrs_latlon <- \"+proj=longlat +datum=WGS84 +no_defs\"# geográficas o elipsoidales\ncrs_utm <- \"+proj=utm +zone=19 +south +datum=WGS84 +units=m +no_defs\" # UTM o cartográficas\nlas_condes_raster2 <- projectRaster(las_condes_raster, crs = crs_latlon)\nlas_condes_raster2\n\nclass      : RasterBrick \ndimensions : 470, 578, 271660, 8  (nrow, ncol, ncell, nlayers)\nresolution : 0.000323, 0.00027  (x, y)\nextent     : -70.61069, -70.424, -33.48775, -33.36085  (xmin, xmax, ymin, ymax)\ncrs        : +proj=longlat +datum=WGS84 +no_defs \nsource     : memory\nnames      :  aerosol,     blue,    green,      red,      nir,    swir1,    swir2,    tirs1 \nmin values : 8592.067, 7778.388, 6806.291, 6280.802, 5729.628, 5316.893, 5303.627, 5005.409 \nmax values : 18590.84, 19485.05, 20596.61, 22406.07, 28732.09, 26707.17, 26787.15,  5495.00"
  },
  {
    "objectID": "datos_espaciales.html#actividades-prácticas",
    "href": "datos_espaciales.html#actividades-prácticas",
    "title": "2  Introducción a Datos Espaciales",
    "section": "2.6 Actividades Prácticas",
    "text": "2.6 Actividades Prácticas\n\nSeleccione una comuna de las manzanas del INE, visualiza con ggplot. Además genere una tabla resumen de suma de personas, hombres, mujeres viviendas por Zona Censal.\n\n\n\n\n\n\n\nTip\n\n\n\nLeer Archivo:\n\nmz_ine <- readRDS(\"../data/censo/manz_INE_2017_sf.rds\")\n\nSeleccionar Comuna con dplyr::filter()\nEliminar geometrías sf::st_drop_geometry() ya que no es necesaria para realizar tabla resumen.\n\n\n\nVisualización de Combinación de Bandas Satelitales\n\n\n\n\n\n\n\nTip\n\n\n\n Referencias: https://mappinggis.com/2019/05/combinaciones-de-bandas-en-imagenes-de-satelite-landsat-y-sentinel/\n\nplotRGB(las_condes_raster, r = 7, g = 6, b = 4, stretch = \"lin\")"
  },
  {
    "objectID": "datos_espaciales.html#referencias",
    "href": "datos_espaciales.html#referencias",
    "title": "2  Introducción a Datos Espaciales",
    "section": "2.7 Referencias",
    "text": "2.7 Referencias\nGeodesia en Chile, teoría y aplicación del Sistema de Referencia Geocéntrico para las Américas (SIRGAS) - 2018\nSimple Features for R"
  },
  {
    "objectID": "datos_vectoriales.html",
    "href": "datos_vectoriales.html",
    "title": "3  Datos Vectoriales",
    "section": "",
    "text": "Objetivos"
  },
  {
    "objectID": "datos_vectoriales.html#objetivos-del-módulo",
    "href": "datos_vectoriales.html#objetivos-del-módulo",
    "title": "3  Datos Vectoriales",
    "section": "3.1 Objetivos del Módulo",
    "text": "3.1 Objetivos del Módulo\n\nManipulación de Datos Vectoriales\nDefinición de Indicadores Territoriales\nConstrucción de Indicadores Socioeconómicos"
  },
  {
    "objectID": "datos_vectoriales.html#manipulación-de-datos-vectoriales",
    "href": "datos_vectoriales.html#manipulación-de-datos-vectoriales",
    "title": "3  Datos Vectoriales",
    "section": "3.2 Manipulación de Datos Vectoriales",
    "text": "3.2 Manipulación de Datos Vectoriales\n\nLectura de Insumos\nFiltros y selección\nResumen Estadísticos\nJoining\nBuffer Espacial\n\n\n3.2.1 Lectura de Insumos\nPara los efectos prácticos de esta etapa se utilizará la base de datos del censo a nivel zonal a nivel nacional.\n\nzonas_censales <-  readRDS(\"data/censo/zonas_urb_consolidadas.rds\")\n\n\n\n\n\nTable 3.1:  Registros de Zonas Censales del Censo 2017 \n \n  \n    REGION \n    NOM_REGION \n    PROVINCIA \n    NOM_PROVIN \n    COMUNA \n    NOM_COMUNA \n    URBANO \n    DISTRITO \n    LOC_ZON \n    GEOCODIGO \n    AREA \n    COD_INE_15 \n    COD_INE_16 \n    VALIDO \n    KM2 \n    ESC_JH \n    PERS \n    M2_O \n    M2_C \n    DENS_HAB \n    DENS_OF \n    DENS_COM \n    geometry \n  \n \n\n  \n    1 \n    REGIÓN DE TARAPACÁ \n    14 \n    TAMARUGAL \n    1405 \n    PICA \n    PICA \n    1 \n    1 \n    1405011001 \n    9336400.3 \n    1405011001 \n    1405011001 \n    TRUE \n    9.3364003 \n    10.817377 \n    3876 \n    0.0000 \n    0.0000 \n    415.1493 \n    0.0000 \n    0.00000 \n    MULTIPOLYGON (((-69.31192 -... \n  \n  \n    1 \n    REGIÓN DE TARAPACÁ \n    14 \n    TAMARUGAL \n    1401 \n    POZO ALMONTE \n    POZO ALMONTE \n    1 \n    1 \n    1401011001 \n    1941994.2 \n    1401011001 \n    1401011001 \n    TRUE \n    1.9419942 \n    10.224880 \n    2771 \n    1476.0000 \n    4093.0000 \n    1426.8838 \n    760.0435 \n    2107.62731 \n    MULTIPOLYGON (((-69.78591 -... \n  \n  \n    1 \n    REGIÓN DE TARAPACÁ \n    14 \n    TAMARUGAL \n    1401 \n    POZO ALMONTE \n    POZO ALMONTE \n    1 \n    2 \n    1401011002 \n    3572254.9 \n    1401011002 \n    1401011002 \n    TRUE \n    3.5722549 \n    10.253158 \n    6506 \n    1905.0000 \n    9696.0000 \n    1821.2586 \n    533.2766 \n    2714.25201 \n    MULTIPOLYGON (((-69.76215 -... \n  \n  \n    1 \n    REGIÓN DE TARAPACÁ \n    14 \n    TAMARUGAL \n    1404 \n    HUARA \n    HUARA \n    1 \n    1 \n    1404011001 \n    603314.2 \n    1404011001 \n    1404011001 \n    TRUE \n    0.6033142 \n    9.523220 \n    1082 \n    0.0000 \n    0.0000 \n    1793.4270 \n    0.0000 \n    0.00000 \n    MULTIPOLYGON (((-69.7696 -1... \n  \n  \n    1 \n    REGIÓN DE TARAPACÁ \n    11 \n    IQUIQUE \n    1107 \n    ALTO HOSPICIO \n    ALTO HOSPICIO \n    1 \n    2 \n    1107011002 \n    2272129.2 \n    1107011002 \n    1107011002 \n    TRUE \n    2.2721292 \n    9.747321 \n    4360 \n    475.0686 \n    180.6789 \n    1918.9050 \n    209.0852 \n    79.51965 \n    MULTIPOLYGON (((-70.09246 -... \n  \n  \n    1 \n    REGIÓN DE TARAPACÁ \n    11 \n    IQUIQUE \n    1107 \n    ALTO HOSPICIO \n    ALTO HOSPICIO \n    3 \n    2 \n    1107031002 \n    5820325.8 \n    1107031002 \n    1107031002 \n    TRUE \n    5.8203258 \n    9.397516 \n    7099 \n    4003.6214 \n    1008.7833 \n    1219.6912 \n    687.8690 \n    173.32076 \n    MULTIPOLYGON (((-70.05305 -... \n  \n\n\n\n\n\n\n\n\n3.2.2 Filtros y selección de columnas\nPara efectos de practicar la manipulación de datos espaciales se creará un subset de la base de zonas censales de alguna provincia de Chile y se realizarán cálculos sencillos de densidad.\nFiltrar\n\n # zonas_censales$NOM_PROVIN %>% unique() %>% sort()\nzonas <-  zonas_censales %>% \n  filter(NOM_PROVIN == \"VALPARAÍSO\") %>% \n  filter(URBANO %in% c(\"VIÑA DEL MAR\", \"VALPARAÍSO\") )\n\n# mapview::mapview(zonas, zcol = \"PERS\")\n\n\nggplot() +\n  geom_sf(data = zonas, aes(fill = PERS), color =NA, \n          alpha=0.8,  size= 0.1)+\n  scale_fill_distiller(palette= \"YlGnBu\", direction = 1)+\n  ggtitle(\"Población Zonas Censales - Urbano\" ) +\n  theme_bw() +\n  theme(panel.grid.major = element_line(colour = \"gray80\"), \n        panel.grid.minor = element_line(colour = \"gray80\"))\n\n\n\n\nFigure 3.1: Zonas Censales de comunas de Valparaíso y Viña del Mar - Urbano\n\n\n\n\nSelección de columnas\n\nzonas <-  zonas %>% \n  dplyr::select(GEOCODIGO,NOM_REGION, NOM_PROVIN, NOM_COMUNA, PERS, URBANO, ESC_JH)\n\n\n\n3.2.3 Operaciones Espaciales\nCálculo de superficie por polígono\n\nzonas <- zonas %>% \n  mutate(AREA = as.numeric(st_area(.))) %>% # en metros cuadrados\n  mutate(AREA = AREA/10000) %>% # en hectárea cuadrada\n  mutate(DENS_PERS= round(PERS/AREA, 1))\n\nzonas\n\nSimple feature collection with 270 features and 9 fields\nGeometry type: MULTIPOLYGON\nDimension:     XY\nBounding box:  xmin: -71.66215 ymin: -33.10497 xmax: -71.44276 ymax: -32.94484\nCRS:           +proj=longlat +datum=WGS84 +ellps=WGS84 +towgs84=0,0,0\nFirst 10 features:\n    GEOCODIGO           NOM_REGION NOM_PROVIN   NOM_COMUNA PERS       URBANO\n1  5109041011 REGIÓN DE VALPARAÍSO VALPARAÍSO VIÑA DEL MAR 1099 VIÑA DEL MAR\n2  5109041001 REGIÓN DE VALPARAÍSO VALPARAÍSO VIÑA DEL MAR 2019 VIÑA DEL MAR\n3  5109041008 REGIÓN DE VALPARAÍSO VALPARAÍSO VIÑA DEL MAR 2909 VIÑA DEL MAR\n4  5109171001 REGIÓN DE VALPARAÍSO VALPARAÍSO VIÑA DEL MAR 4112 VIÑA DEL MAR\n5  5109041003 REGIÓN DE VALPARAÍSO VALPARAÍSO VIÑA DEL MAR 3848 VIÑA DEL MAR\n6  5109041009 REGIÓN DE VALPARAÍSO VALPARAÍSO VIÑA DEL MAR 1644 VIÑA DEL MAR\n7  5109041002 REGIÓN DE VALPARAÍSO VALPARAÍSO VIÑA DEL MAR 2622 VIÑA DEL MAR\n8  5109041004 REGIÓN DE VALPARAÍSO VALPARAÍSO VIÑA DEL MAR 4388 VIÑA DEL MAR\n9  5109171002 REGIÓN DE VALPARAÍSO VALPARAÍSO VIÑA DEL MAR 4370 VIÑA DEL MAR\n10 5109121002 REGIÓN DE VALPARAÍSO VALPARAÍSO VIÑA DEL MAR 3536 VIÑA DEL MAR\n      ESC_JH                       geometry      AREA DENS_PERS\n1  14.874739 MULTIPOLYGON (((-71.54403 -...  30.21474      36.4\n2  15.452073 MULTIPOLYGON (((-71.52892 -... 280.03089       7.2\n3  16.270210 MULTIPOLYGON (((-71.50958 -... 193.87803      15.0\n4  11.814570 MULTIPOLYGON (((-71.48 -32.... 359.81093      11.4\n5  14.875097 MULTIPOLYGON (((-71.51213 -... 438.40072       8.8\n6  15.539638 MULTIPOLYGON (((-71.53398 -...  38.79690      42.4\n7  14.691789 MULTIPOLYGON (((-71.52915 -...  47.69528      55.0\n8  16.590909 MULTIPOLYGON (((-71.5356 -3... 155.56770      28.2\n9   9.136792 MULTIPOLYGON (((-71.47489 -... 546.70960       8.0\n10 12.231474 MULTIPOLYGON (((-71.52137 -... 150.78167      23.5\n\n\n\nggplot() +\n  geom_sf(data = zonas, aes(fill = PERS), color =NA, \n          alpha=0.8,  size= 0.1)+\n  scale_fill_distiller(palette= \"YlGnBu\", direction = 1)+\n  ggtitle(\"Población Zonas Censales - Urbano\" ) +\n  theme_bw() +\n  theme(panel.grid.major = element_line(colour = \"gray80\"), \n        panel.grid.minor = element_line(colour = \"gray80\"))\nggplot() +\n  geom_sf(data = zonas, aes(fill = DENS_PERS), color =NA, \n          alpha=0.8,  size= 0.1)+\n  scale_fill_distiller(palette= \"YlGnBu\", direction = 1)+\n  ggtitle(\"Densidad de Población Zonas Censales - Urbano\" ) +\n  theme_bw() +\n  theme(panel.grid.major = element_line(colour = \"gray80\"), \n        panel.grid.minor = element_line(colour = \"gray80\"))\n\n\n\n\n\n\nFigure 3.2: Diferencias de un valor absoluto y densidad de Personas en Zonas Censales\n\n\n\n\n\n\n\nFigure 3.3: Diferencias de un valor absoluto y densidad de Personas en Zonas Censales\n\n\n\n\n\n\n\n\n3.2.4 Resumen Estadísticos\nEl objetivo de este punto es que con bases de datos espaciales también se pueden hacer resúmenes estadísticos, como se hacen normalmente con bases de datos. Ahora, se creará tabla con las poblaciones y promedio de años de estudio del Jefe de Hogar en todas las comunas de Chile.\nUn punto importante para generar esta tabla es eficiente eliminar la geometría para los cálculos ya que la salida será una tabla.\n\ntab_com <- zonas_censales %>% \n  st_drop_geometry() %>% # eliminar geometría.\n  group_by(NOM_COMUNA) %>% \n  summarise(POB_COM = sum(PERS),\n            ESC_JH_COM = round(mean(ESC_JH, na.rm= T), 1))\n\n\n\n\n\nTable 3.2:  Registros de Población y Escolaridad por Comuna \n \n  \n    NOM_COMUNA \n    POB_COM \n    ESC_JH_COM \n  \n \n\n  \n    ALGARROBO \n    10880 \n    12.1 \n  \n  \n    ALHUÉ \n    2706 \n    9.6 \n  \n  \n    ALTO HOSPICIO \n    105065 \n    10.4 \n  \n  \n    ANCUD \n    28162 \n    10.0 \n  \n  \n    ANDACOLLO \n    9989 \n    8.8 \n  \n  \n    ANGOL \n    48608 \n    10.1 \n  \n  \n    ANTOFAGASTA \n    349983 \n    12.2 \n  \n  \n    ANTUCO \n    2038 \n    9.2 \n  \n  \n    ARAUCO \n    27274 \n    9.8 \n  \n  \n    ARICA \n    203132 \n    11.5 \n  \n\n\n\n\n\n\n\n\n3.2.5 Joining\nEn este caso agregaremos a la tabla de resultados comunales antes creada, a la base de la comuna de Viña del Mar y Valparaíso, utilizaremos la función left_join.\n\nzonas <-  zonas %>% \n  left_join(tab_com, by = \"NOM_COMUNA\") %>% # Ojo con las veces que se hace esta operación\n  mutate(DIF_EJH_COM = round(( ESC_JH-ESC_JH_COM), 2))\n\n\nggplot() +\n  geom_sf(data = zonas, aes(fill = DIF_EJH_COM), color =NA, \n          alpha=0.8,  size= 0.1)+\n  scale_fill_distiller(palette= \"PRGn\", direction = 1)+\n  ggtitle(\"Diferencias Esc. Jefe Hogar Zona/Comuna - Urbano\" ) +\n  theme_bw() +\n  theme(panel.grid.major = element_line(colour = \"gray80\"), \n        panel.grid.minor = element_line(colour = \"gray80\"))\n\n\n\n\nFigure 3.4: Diferencias Esc. Jefe Hogar respecto comuna - Urbano\n\n\n\n\n\n\n3.2.6 Buffer\nPrimeramente se creará una geometría comunal basándose en las zonas censales\n\nvalpo_com <-  zonas %>% filter(NOM_COMUNA == \"VALPARAÍSO\") %>% \n  st_union()\n\n\nggplot() +\n  geom_sf(data = zonas, aes(fill = DIF_EJH_COM), color =NA, \n          alpha=0.3,  size= 0.1)+\n  scale_fill_distiller(palette= \"PRGn\", direction = 1)+\n  geom_sf(data = valpo_com,  color =\"magenta\", alpha=1,  size= 1, fill = NA)+\n  ggtitle(\"Resaltar la comuna de Valparaíso\" ) +\n  theme_bw() +\n  theme(panel.grid.major = element_line(colour = \"gray80\"), \n        panel.grid.minor = element_line(colour = \"gray80\"))\n\n\n\n\nFigure 3.5: Resaltar la comuna de Valparaíso\n\n\n\n\nAplicación de Buffer con la función de st_buffer.\n\nvalpo_com_buffer <-  valpo_com %>% \n  st_buffer(dist = 1000) # %>% st_simplify(dTolerance = 100) \n\n\nggplot() +\n  geom_sf(data = valpo_com_buffer,  color =\"orange\", alpha=1,  size= 1, fill = NA)+\n  geom_sf(data = valpo_com,  color =\"magenta\", alpha=0.3,  size= 1, fill = \"magenta\")+\n  ggtitle(\"Buffer de la comuna de Valparaíso - 1000 mts.\" ) +\n  theme_bw() +\n  theme(panel.grid.major = element_line(colour = \"gray80\"), \n        panel.grid.minor = element_line(colour = \"gray80\"))\n\n\n\n\nFigure 3.6: Buffer de la comuna de Valparaíso - 1000 mts."
  },
  {
    "objectID": "datos_vectoriales.html#indicadores-territoriales",
    "href": "datos_vectoriales.html#indicadores-territoriales",
    "title": "3  Datos Vectoriales",
    "section": "3.3 Indicadores Territoriales",
    "text": "3.3 Indicadores Territoriales\n\n3.3.1 Definición de Indicadores\n\n¿Qué es un Indicador?:\n\nUn indicador es un instrumento que provee información de una determinada condición, situación, actividad o resultado. Este instrumento nos permite definir un punto de comparación para establecer diferencias entre individuos o respecto a sí mismo en diferentes tiempos. Son construidos a través de análisis y operaciones técnicas y nos entregan una medida cuantitativa (valor) o una descripción cualitativa (caracterización) de la magnitud o criterio que se pretende medir u observar.\n\n\n\n\n3.3.2 Indicadores Territoriales\nEl Centro de Inteligencia Territorial de la Universidad Adolfo Ibáñez, bajo proyecto denominado Matriz de Bienestar Humano Territorial (MBHT) construyó una serie indicadores territoriales, que buscan comprender las condiciones de los entornos urbanos y rurales, para construir soluciones que impacten positivamente en el bienestar de las personas y su hábitat.\n\n\n\nFigure 3.7: Centro de Inteligencia Territorial - UAI\n\n\nEl sistema MBHT consiste en 18 indicadores territoriales agrupados en 4 dimensiones, que corresponde a las dimensiones de Accesibilidad, Ambiental, Seguridad y Socoeconómicas, siendo esta última a la se replicará.\n\n\n\n\n\n\n\nFigure 3.8: Dimensiones de la Matriz de Bienestar Humano Territorial"
  },
  {
    "objectID": "datos_vectoriales.html#sec-indsoc",
    "href": "datos_vectoriales.html#sec-indsoc",
    "title": "3  Datos Vectoriales",
    "section": "3.4 Construcción de Indicadores Socioconómicos",
    "text": "3.4 Construcción de Indicadores Socioconómicos\nLas ciudades de Chile presentan altos índices de segregación (Sabatini, 2002), que reflejan la separación espacial de distintos grupos sociales (Ruiz-Tagle, 2014). La intensidad de este fenómeno hace imperativo el considerar la condición social como una dimensión estructurante en la evaluación de Políticas Públicas.\n\n\n\n\n\n\n\nFigure 3.9: Indicadores Socioconómicos\n\n\n\n3.4.1 Insumos Censo 2017\nPara la construcción de los indicadores territoriales que componen la dimensión seocioeconómica, se utiliza íntegramente información del Censo 2017.\n¿Que es Censo 2017?:\nEl censo de población y vivienda es la operación estadística más importante que realiza el INE y en la cual participan todos los habitantes del país, ya que este es un insumo esencial para elaborar estimaciones y proyecciones de población tanto para el país, las regiones y las comunas.\nEl censo permite contar con información esencial para el adecuado diseño de políticas públicas y toma de decisiones privadas y públicas. El último censo de población y vivienda realizado fue en 2017. Sus resultados indican que la población efectivamente censada llegó a un total de 17.574.003 personas.\nDe ellas, 8.601.989 (48,9%) son hombres y 8.972.014 (51,1%), mujeres. El número de viviendas, en tanto, fue 6.499.355, de las cuales 6.486.533 (99,8%) corresponden a viviendas particulares y 12.822 (0,2%) a colectivas.\nPara estos fines, se utilizaremos información censal agregada a nivel de manzanas obtenidos del Censo 2017, a continuación se explorará los insumos utilizados.\n\n\n\n\n\n\n\nFigure 3.10: Censo 2017 - Instituto Nacional de Estadísticas de Chile\n\n\n\n\n3.4.2 Insumos del Censo\nPara los indicadores que se crearán a continuación se utilizará una base proveniente de la consolidación de las bases del censo, denominadas microdatos de Personas, Viviendas y Hogares provenientes de los resultados de la Encuesta del Censo 2017 del Instituto Nacional de Estadísticas, Chile.\n\nlibrary(sf)\nlibrary(dplyr)\n\n# ruta de insumos\npath_insumos <- \"data/socioeconomicos/insumos/\"\n\nLectura de Insumos y selección de región de estudio, en este caso seleccionará la Región de Coquimbo compuesta por las provincias de Elqui, Limarí y Choapa. Sus principales centros urbanos son la Conurbación La Serena-Coquimbo con 506 391 habitantes, seguida de Ovalle con 121.269 habitantes según el Censo chileno de 2017.\n\n# selección de región\nreg <-  \"R04\"\n\n# Lectura de insumo espacial\npath_file <- paste0(path_insumos, reg, \"_INSUMO_SOCIOECONOMICO.shp\")\ncenso <- st_read(path_file, quiet = T)\n\nVisualización de Tabla de Información head()\n\n\n\n\nTable 3.3:  Visualización de registros de insumos del Censo 2017 para indicadores socioeconómicos \n \n  \n    ID_MANZ \n    MANZ_EN \n    NOM_COM \n    COD_COM \n    NOM_REG \n    COD_REG \n    NOM_PROV \n    COD_PROV \n    ZONA \n    ID_MANZCIT \n    AREA \n    TOTAL_V \n    HOG_N \n    PERSONAS \n    E4A18 \n    E15A24 \n    ESCOLAR \n    P03A_4 \n    P03A_5 \n    P03A_6 \n    P03B_4 \n    P03B_6 \n    P03B_7 \n    P03C_4 \n    P03C_5 \n    NIV_HAC2 \n    NIV_HAC3 \n    HOMBRES \n    MUJERES \n    MONOPAR \n    P17_ACT \n    P17_4 \n    J_NINI \n    JH_HASTA_P \n    JH_HASTA_S \n    geometry \n  \n \n\n  \n    4101071001900 \n    URBANO \n    LA SERENA \n    4101 \n    REGIÓN DE COQUIMBO \n    4 \n    ELQUI \n    41 \n    4101071001 \n    4101071001900001 \n    2873.376 \n    0 \n    0 \n    0 \n    0 \n    0 \n    0 \n    0 \n    0 \n    0 \n    0 \n    0 \n    0 \n    0 \n    0 \n    0 \n    0 \n    0 \n    0 \n    0 \n    0 \n    0 \n    0 \n    0 \n    0 \n    POLYGON ((292811 6685815, 2... \n  \n  \n    4101071001900 \n    URBANO \n    LA SERENA \n    4101 \n    REGIÓN DE COQUIMBO \n    4 \n    ELQUI \n    41 \n    4101071001 \n    4101071001900002 \n    1256.480 \n    0 \n    0 \n    0 \n    0 \n    0 \n    0 \n    0 \n    0 \n    0 \n    0 \n    0 \n    0 \n    0 \n    0 \n    0 \n    0 \n    0 \n    0 \n    0 \n    0 \n    0 \n    0 \n    0 \n    0 \n    POLYGON ((293056 6685511, 2... \n  \n  \n    4102101001900 \n    URBANO \n    COQUIMBO \n    4102 \n    REGIÓN DE COQUIMBO \n    4 \n    ELQUI \n    41 \n    4102101001 \n    4102101001900001 \n    1230.344 \n    0 \n    0 \n    0 \n    0 \n    0 \n    0 \n    0 \n    0 \n    0 \n    0 \n    0 \n    0 \n    0 \n    0 \n    0 \n    0 \n    0 \n    0 \n    0 \n    0 \n    0 \n    0 \n    0 \n    0 \n    POLYGON ((285917.8 6664517,... \n  \n  \n    4102101001900 \n    URBANO \n    COQUIMBO \n    4102 \n    REGIÓN DE COQUIMBO \n    4 \n    ELQUI \n    41 \n    4102101001 \n    4102101001900002 \n    3877.142 \n    0 \n    0 \n    0 \n    0 \n    0 \n    0 \n    0 \n    0 \n    0 \n    0 \n    0 \n    0 \n    0 \n    0 \n    0 \n    0 \n    0 \n    0 \n    0 \n    0 \n    0 \n    0 \n    0 \n    0 \n    POLYGON ((286085 6664254, 2... \n  \n  \n    4102101001900 \n    URBANO \n    COQUIMBO \n    4102 \n    REGIÓN DE COQUIMBO \n    4 \n    ELQUI \n    41 \n    4102101001 \n    4102101001900003 \n    34392.873 \n    0 \n    0 \n    0 \n    0 \n    0 \n    0 \n    0 \n    0 \n    0 \n    0 \n    0 \n    0 \n    0 \n    0 \n    0 \n    0 \n    0 \n    0 \n    0 \n    0 \n    0 \n    0 \n    0 \n    0 \n    POLYGON ((286082.4 6663489,... \n  \n  \n    4106101001900 \n    URBANO \n    VICUÑA \n    4106 \n    REGIÓN DE COQUIMBO \n    4 \n    ELQUI \n    41 \n    4106101001 \n    4106101001900001 \n    4033.107 \n    0 \n    0 \n    0 \n    0 \n    0 \n    0 \n    0 \n    0 \n    0 \n    0 \n    0 \n    0 \n    0 \n    0 \n    0 \n    0 \n    0 \n    0 \n    0 \n    0 \n    0 \n    0 \n    0 \n    0 \n    POLYGON ((310231.6 6684580,..."
  },
  {
    "objectID": "datos_vectoriales.html#indicador-de-escolaridad-del-jefe-de-hogar-iej",
    "href": "datos_vectoriales.html#indicador-de-escolaridad-del-jefe-de-hogar-iej",
    "title": "3  Datos Vectoriales",
    "section": "3.5 Indicador de Escolaridad del jefe de hogar (IEJ)",
    "text": "3.5 Indicador de Escolaridad del jefe de hogar (IEJ)\nPara la construcción de este indicador se utilizó el promedio de años de estudio de jefes de hogar (EJH), que es una variable censal numérica (“ESCOLARIDAD”, en tabla de personas del censo 2017) que registra el nivel del curso más alto aprobado, medida en años sucesivos desde la enseñanza básica hasta estudios de postgrado.\nSe calcula el promedio de esta variable para todos los jefes de hogar en cada manzana. Esta variable es representativa del capital cultural de cada hogar y está altamente correlacionada con el nivel de ingresos en Chile (Agostini et al, 2016).\nCálculo Indicador de Escolaridad del jefe de hogar (IEJ)\n\ncenso <- censo %>% mutate( IEJ = ifelse(PERSONAS ==0, NA, ESCOLAR))\n\nPara efectos de visualización se enfocará los resultados en las zonas urbanas de la comuna de La Serena en todos los indicadores que se presentarán.\n\nla_serena_urb <- censo %>% filter(COD_COM == 4101 & MANZ_EN == \"URBANO\")\n\nVisualizar la Variable de IEJ comuna de La Serena URBANO:\n\nggplot() +\n  geom_sf(data = la_serena_urb, aes(fill = IEJ), color =NA, \n          alpha=0.8,  size= 0.1)+\n  scale_fill_distiller(palette= \"YlGnBu\", direction = 1)+\n  ggtitle(\"Indicador de Escolaridad del jefe de hogar (IEJ) - Urbano\" ) +\n  theme_bw() +\n  theme(panel.grid.major = element_line(colour = \"gray80\"), \n        panel.grid.minor = element_line(colour = \"gray80\"))\n\n\n\n\nFigure 3.11: Indicador de Escolaridad del jefe de hogar (IEJ) - Urbano\n\n\n\n\n\n# mapview::mapview(censo %>% filter(COD_COM == 4101 & MANZ_EN == \"URBANO\"),\n                 # zcol = \"IEJ\", layer.name = \"IEJ\")\n\nVisualizar la Variable de IEJ comuna de La Serena RURAL:\n\nla_serena_rural <- censo %>% filter(COD_COM == 4101 & MANZ_EN == \"RURAL\")\n\nggplot() +\n  geom_sf(data = la_serena_rural, aes(fill = IEJ), color =NA, \n          alpha=0.8,  size= 0.1)+\n  scale_fill_distiller(palette= \"YlGnBu\", direction = 1)+\n  ggtitle(\"Indicador de Escolaridad del jefe de hogar (IEJ) - Rural\" ) +\n  theme_bw() +\n  theme(panel.grid.major = element_line(colour = \"gray80\"), \n        panel.grid.minor = element_line(colour = \"gray80\"))\n# mapview::mapview(censo %>% filter(COD_COM == 4101 & MANZ_EN == \"RURAL\"),\n                 # zcol = \"IEJ\", layer.name = \"IEJ\")\n\n\n\n\nFigure 3.12: Indicador de Escolaridad del jefe de hogar (IEJ) - Rural"
  },
  {
    "objectID": "datos_vectoriales.html#indicador-de-empleo-iem",
    "href": "datos_vectoriales.html#indicador-de-empleo-iem",
    "title": "3  Datos Vectoriales",
    "section": "3.6 Indicador de Empleo (IEM)",
    "text": "3.6 Indicador de Empleo (IEM)\nPara este indicador se usó la proporción de población activa sin empleo que es la fracción de las personas que no tienen empleo y están buscando uno, respecto al total de personas en condiciones y con deseo de trabajar en cada manzana.\nEsta variable es similar al cálculo de desempleo, pero calculada a escala de manzanas y en un tiempo específico, por lo que representa las brechas potenciales que existen para acceder al empleo en barrios específicos (MDS, 2019).\nCálculo Indicador de Empleo (IEM) \nP17_4: Trabajo la semana pasada, opción 4: “Se encontraba buscando empleo”\nP17_ACT: Total de Actividades Remuneradas (no es pregunta del Censo)\n\n# P17: Trabajo la semana pasada\n# opción `4`: \"Se encontraba buscando empleo\"\n# P17_ACT: Total de Actividades Remuneradas\n\ncenso <- censo %>% mutate( CESA_DENS = P17_4 / P17_ACT)\n\n# Invertir el valor de indicador 1\ncenso <- censo %>% mutate( IEM = 1 - CESA_DENS )\n\nDe aquí continuación se realizarán cartografías solo a zonas urbanas a efecto de limitar la extensión del presente documento, pero el cálculo urbano se puede efectuar perfectamente aplicando un filtro como se ejemplifico en el indicador anterior. Ahora, se procede a filtrar por zonas urbanas\n\nla_serena_urb <- censo %>% filter(COD_COM == 4101 & MANZ_EN == \"URBANO\")\n\nVisualizar la Variable de IEM comuna de La Serena URBANO:\n\nggplot() +\n  geom_sf(data = la_serena_urb, aes(fill = IEM), color =NA, \n          alpha=0.8,  size= 0.1)+\n  scale_fill_distiller(palette= \"PuBu\", direction = 1)+\n  ggtitle(\"Indicador de Empleo (IEM) - Urbano\" ) +\n  theme_bw() +\n  theme(panel.grid.major = element_line(colour = \"gray80\"), \n        panel.grid.minor = element_line(colour = \"gray80\"))\n\n\n\n\nFigure 3.13: Indicador de Empleo (IEM) - Urbano\n\n\n\n\n\n# mapview::mapview(la_serena_urb, \n#                  zcol = \"IEM\", layer.name = \"IEM\")"
  },
  {
    "objectID": "datos_vectoriales.html#indicador-de-participacion-juvenil-en-empleo-y-estudio-ipj",
    "href": "datos_vectoriales.html#indicador-de-participacion-juvenil-en-empleo-y-estudio-ipj",
    "title": "3  Datos Vectoriales",
    "section": "3.7 Indicador de Participación Juvenil en empleo y estudio (IPJ)",
    "text": "3.7 Indicador de Participación Juvenil en empleo y estudio (IPJ)\nPara la construcción de este indicador se utilizó la proporción de jóvenes entre 14 y 24 años que no trabajan ni estudian: es la fracción de jóvenes en este rango edad que no trabajan ni estudian, respecto al total de este segmento etario en cada manzana.\nEsta variable representa un riesgo de exclusión socioeconómica en el período de transición entre el ambiente educativo y el laboral, siendo característico de trayectorias de deserción escolar que conducen al desempleo y que podrían incrementar el riesgo de adopción de comportamientos delictivos (MDS, 2019).\nLuego, el indicador se normalizó con su inverso aditivo, para asegurar que el valor máximo, sea lo más deseable y el 0 lo menos deseable, convirtiéndose así en un indicador de empleo.\nCálculo Indicador de Participación Juvenil en empleo y estudio (IPJ) \nJ_NINI: Jóvenes que no trabajan ni estudian P17 E15A24: Jóvenes entre 15 y 24 años de edad\n\ncenso <- censo %>% mutate( NINI_DENS = J_NINI / E15A24)  \ncenso <- censo %>% mutate( NINI_DENS = ifelse(NINI_DENS > 1, 1, NINI_DENS))  \ncenso <- censo %>% mutate( IPJ = 1 - NINI_DENS )\n\n\nla_serena_urb <- censo %>% filter(COD_COM == 4101 & MANZ_EN == \"URBANO\")\n\nVisualizar la Variable de IPJ comuna de La Serena URBANO:\n\nggplot() +\n  geom_sf(data = la_serena_urb, aes(fill = IPJ), color =NA, \n          alpha=0.8,  size= 0.1)+\n  scale_fill_distiller(palette= \"Purples\", direction = 1)+\n  ggtitle(\"Indicador de Participación Juvenil en empleo y estudio (IPJ) - Urbano\" ) +\n  theme_bw() +\n  theme(panel.grid.major = element_line(colour = \"gray80\"), \n        panel.grid.minor = element_line(colour = \"gray80\"))\n\n\n\n\nFigure 3.14: Indicador de Participación Juvenil enempleo y estudio (IPJ) - Urbano\n\n\n\n\n\n# mapview::mapview(la_serena_urb, \n#                  zcol = \"IPJ\", layer.name = \"IPJ\")"
  },
  {
    "objectID": "datos_vectoriales.html#indicador-de-resiliencia-de-hogares-irh",
    "href": "datos_vectoriales.html#indicador-de-resiliencia-de-hogares-irh",
    "title": "3  Datos Vectoriales",
    "section": "3.8 Indicador de Resiliencia de Hogares (IRH)",
    "text": "3.8 Indicador de Resiliencia de Hogares (IRH)\nEn particular, la monoparentalidad es ampliamente reconocida en la literatura internacional como una situación familiar frágil, que puede afectar las trayectorias de vida de los hijos, en términos de un mayor riesgo de mortalidad (Amato & Patterson, 2017), inestabilidad psicológica (Theodoritsi, Daliana & Antoniou, 2018), problemas de salud (Duriancik & Goff, 2019) y otros.\nEn suma, el Indicador de Resiliencia de Hogares (en base a la monoparentalidad), en complemento a otras variables, es conceptualmente relevante para evaluar riesgos no monetarios de condiciones sociales.\nEste indicador es el inverso aditivo de la proporción de hogares monoparentales dentro de una manzana. Los hogares monoparentales son aquellos con hijos que viven con un solo progenitor, lo que se asocia en diversas formas a la condición social, que abarcan desde un menor ingreso, problemas de salud y delincuencia, entre otros (MDS, 2019).\nAl contrario, los hogares biparentales permiten el apoyo entre progenitores y los hogares sin hijos tienen menores exigencias de gasto y tiempo relacionadas con la paternidad, por lo que se considera que en general son más resilientes.\nCálculo de Indicador de Resiliencia de Hogares (IRH) \nMONOPAR: Hogares Monoparentales\nHOG_N: Número de Hogares\n\ncenso <- censo %>% mutate( MONO_DENS = MONOPAR / HOG_N)\ncenso <- censo %>% mutate( MONO_DENS = ifelse(MONO_DENS > 1, 1, MONO_DENS))  \ncenso <- censo %>% mutate( IRH = 1 - MONO_DENS)\n\n\nla_serena_urb <- censo %>% filter(COD_COM == 4101 & MANZ_EN == \"URBANO\")\n\nVisualizar la Variable de IRH comuna de La Serena URBANO:\n\nggplot() +\n  geom_sf(data = la_serena_urb, aes(fill = IRH), color =NA, \n          alpha=0.8,  size= 0.1)+\n  scale_fill_distiller(palette= \"PuRd\", direction = 1)+\n  ggtitle(\"Indicador de Resiliencia de Hogares (IRH) - Urbano\") +\n  theme_bw() +\n  theme(panel.grid.major = element_line(colour = \"gray80\"), \n        panel.grid.minor = element_line(colour = \"gray80\"))\n\n\n\n\nFigure 3.15: Indicador de Resiliencia de Hogares (IRH) - Urbano\n\n\n\n\n\n# mapview::mapview(la_serena_urb, \n#                  zcol = \"IRH\", layer.name = \"IRH\")"
  },
  {
    "objectID": "datos_vectoriales.html#indicador-de-calidad-de-la-vivienda-ivi",
    "href": "datos_vectoriales.html#indicador-de-calidad-de-la-vivienda-ivi",
    "title": "3  Datos Vectoriales",
    "section": "3.9 Indicador de Calidad de la Vivienda (IVI)",
    "text": "3.9 Indicador de Calidad de la Vivienda (IVI)\nEl indicador de calidad de vivienda es una variable sintética de todas las materialidades de la vivienda. Inicialmente, se construyó como un indicador de mala calidad, tomando un valor más alto cuando la calidad de la vivienda es peor y es más bajo cuando es mejor. Fue elaborado como un promedio lineal del 3 sub-indicadores de paredes, suelo y techo. Cada uno de estos sub-indicadores registra el porcentaje de viviendas de la manzana que tienen paredes, suelo o techo considerado insuficiente. Las construcciones consideradas insuficientes son las siguientes:\nParedes: Material de los muros exteriores\n\nP03A_4: Tabique sin forro interior (madera u otro)\nP03A_5: Adobe, barro, quincha, pirca u otro artesanal tradicional\nP03A_6: Materiales precarios (lata, cartón, plástico, etc.)\n\nTecho: Material en la cubierta del techo\n\nP03B_4: Fonolita o plancha de fieltro embreado\nP03B_6: Materiales precarios (lata, cartón, plásticos, etc.)\nP03B_7: Sin cubierta sólida de techo\n\nSuelo: Material de construcción del piso\n\nP03C_4: Capa de cemento sobre tierra\nP03C_5: Tierra\n\nCálculo Indicador de Calidad de la Vivienda (IVI) \n\ncenso <- censo %>%\n  mutate(paredes = (P03A_4 + P03A_5 + P03A_6)/TOTAL_V,\n         techo = (P03B_4 + P03B_6 + P03B_7)/TOTAL_V,\n         suelo = (P03C_4 +  P03C_5)/TOTAL_V)\n\n# eliminar valores infinitos de la división anterior\ncenso <- censo %>%\n  mutate(paredes = ifelse(paredes > 1, 1, paredes), \n         techo = ifelse(techo > 1, 1, techo), \n         suelo = ifelse(suelo > 1, 1, suelo))\n\ncenso <- censo %>%  mutate(IVI = (paredes+ suelo+ techo)/3)\ncenso <- censo %>%  mutate(IVI =  1 - IVI) # invertir sentido\n\n\nla_serena_urb <- censo %>% filter(COD_COM == 4101 & MANZ_EN == \"URBANO\")\n\nVisualizar la Variable de IVI comuna de La Serena URBANO:\n\nggplot() +\n  geom_sf(data = la_serena_urb, aes(fill = IVI), color =NA, \n          alpha=0.8,  size= 0.1)+\n  scale_fill_distiller(palette= \"YlOrRd\", direction = 1)+\n  ggtitle(\"Indicador de Calidad de la Vivienda (IVI) - Urbano\") +\n  theme_bw() +\n  theme(panel.grid.major = element_line(colour = \"gray80\"), \n        panel.grid.minor = element_line(colour = \"gray80\"))\n\n\n\n\nFigure 3.16: Indicador de Calidad de la Vivienda (IVI) - Urbano\n\n\n\n\n\n# mapview::mapview(la_serena_urb, \n#                  zcol = \"IVI\", layer.name = \"IVI\")"
  },
  {
    "objectID": "datos_vectoriales.html#indicador-de-suficiencia-de-viviendas-isv",
    "href": "datos_vectoriales.html#indicador-de-suficiencia-de-viviendas-isv",
    "title": "3  Datos Vectoriales",
    "section": "3.10 Indicador de Suficiencia de Viviendas (ISV)",
    "text": "3.10 Indicador de Suficiencia de Viviendas (ISV)\nEl indicador de Suficiencia de Viviendas se construyó inicialmente como un indicador de hacinamiento. Se realizó a partir de 2 variables que indican el número de viviendas que se encuentran en situación de hacinamiento y el número de viviendas que se encuentran en situación de hacinamiento severo. El indicador corresponde a la suma de 2 veces las viviendas en situación de hacinamiento severo con las viviendas en situación de hacinamiento normal, dividido por el total de viviendas.\nLuego, el indicador se normalizó con su inverso aditivo, para asegurar que el valor máximo, sea lo más deseable y el 0 lo menos deseable. Con esto se obtuvo el indicador de suficiencia de viviendas.\nCálculo de Indicador de Suficiencia de Viviendas (ISV) \nNIV_HAC2: >= 2.5 personas por habitación\nNIV_HAC3: >= 5 personas por habitación\n\ncenso <- censo %>% mutate(ISV = NIV_HAC2 + (2 * NIV_HAC3))\n\n# función de normalización\nminmax <- function(x) {\n  x <- (x - min(x, na.rm = TRUE)) / \n    (max(x, na.rm = TRUE) - min(x, na.rm = TRUE))\n  return(x)\n}\n\ncenso <- censo %>% mutate(ISV = 1 - minmax(ISV))\n\n\nla_serena_urb <- censo %>% filter(COD_COM == 4101 & MANZ_EN == \"URBANO\")\n\nVisualizar la Variable de ISV comuna de La Serena URBANO:\n\nggplot() +\n  geom_sf(data = la_serena_urb, aes(fill = ISV), color =NA, \n          alpha=0.8,  size= 0.1)+\n  scale_fill_distiller(palette= \"YlOrRd\", direction = 1)+\n  ggtitle(\" Indicador de Suficiencia de Viviendas (ISV) - Urbano\") +\n  theme_bw() +\n  theme(panel.grid.major = element_line(colour = \"gray80\"), \n        panel.grid.minor = element_line(colour = \"gray80\"))\n\n\n\n\nFigure 3.17: Indicador de Suficiencia de Viviendas (ISV) - Urbano\n\n\n\n\n\n# mapview::mapview(la_serena_urb, \n#                  zcol = \"ISV\", layer.name = \"ISV\")"
  },
  {
    "objectID": "datos_vectoriales.html#consolidación-de-dimensión-socioeconómica",
    "href": "datos_vectoriales.html#consolidación-de-dimensión-socioeconómica",
    "title": "3  Datos Vectoriales",
    "section": "3.11 Consolidación de Dimensión Socioeconómica",
    "text": "3.11 Consolidación de Dimensión Socioeconómica\nSelección de Variables de Interés\n\n# names(censo)\nsoc <- censo %>% \n  dplyr::select(ID_MANZ:PERSONAS, IEJ, IEM, IPJ, IRH, IVI, ISV)\n\nVisualización de los Indicadores\n\ncomuna <- soc %>% filter(COD_COM == 4101 & MANZ_EN == \"URBANO\")\nmapview(comuna, zcol = \"IEJ\") + mapview(comuna, zcol = \"IEM\")+\n  mapview(comuna, zcol = \"IPJ\") + mapview(comuna, zcol = \"IRH\")+\n  mapview(comuna, zcol = \"IVI\") + mapview(comuna, zcol = \"ISV\")\n\nGuardar Resultados\n\n# guardar shapefile\npath_file_out <- paste0(\"../data/socioeconomicos/resultados/\",\n                    reg, \"_ind_socioeconomicos.shp\")\nst_write(soc, path_file_out)\n\n#guardar en RDS\npath_file_out_rds <- paste0(\"../data/socioeconomicos/resultados/\",\n                    reg, \"_ind_socioeconomicos.rds\")\nsaveRDS(soc, path_file_out_rds)"
  },
  {
    "objectID": "datos_vectoriales.html#referencias",
    "href": "datos_vectoriales.html#referencias",
    "title": "3  Datos Vectoriales",
    "section": "3.12 Referencias",
    "text": "3.12 Referencias\n\nR para Ciencia de Datos\nRStudio para Estadística Descriptiva en Ciencias Sociales\nR para Principiantes4/\nColores en Ggplot2"
  },
  {
    "objectID": "raster.html",
    "href": "raster.html",
    "title": "4  Datos tipo Raster",
    "section": "",
    "text": "Objetivos del Módulo"
  },
  {
    "objectID": "raster.html#objetivos-del-módulo",
    "href": "raster.html#objetivos-del-módulo",
    "title": "4  Datos tipo Raster",
    "section": "4.1 Objetivos del Módulo",
    "text": "4.1 Objetivos del Módulo\n\nDefinción de Conceptos\nManipulación de datos Raster de imágenes satelitales.\nConstrucción de Indicadores ambientales"
  },
  {
    "objectID": "raster.html#definición-de-conceptos",
    "href": "raster.html#definición-de-conceptos",
    "title": "4  Datos tipo Raster",
    "section": "4.2 Definición de Conceptos",
    "text": "4.2 Definición de Conceptos\n\nPercepción Remota:\n\nPercepción Remota o en una disciplina científica que entrega un amplio conjunto de conocimientos y tecnologías utilizadas para observación, análisis, la interpretación de fenómenos en el territorio. La percepción remota nos permite efectuar observaciones y mediciones de la superficie terrestre mediante dispositivos remotos instalados sobre plataformas como satélites, aviones y actualmente hasta en drones. Los sensores instalados en estas plataformas miden una gran variedad de datos como radiaciones electromagnéticas, espectro electromagnético, perturbaciones atmosféricas, firmas espectrales y captura de imágenes, entre otros.\n\n\n\n\n\nPercepción Remota\n\n\n\nPercepción Remota Satelital:\n\nLos satélites llevan instrumentos o sensores que miden la radiación electromagnética proveniente del sistema tierra - atmósfera. La intensidad de la radiación reflejada y emitida al espacio es influenciada por las condiciones en la superficie y la atmósfera.\n\n\n\n\n\nPercepción Remota Satelital\n\n\n\nEspectro Electromagnético:\n\nEs un conjunto de frecuencias o longitudes de onda en los que se organiza la radiación electromagnética. Abarca las radiaciones entre los rayos gamma y las ondas de radio.\n\n\n\n\n\nEspectro Electromagnético\n\n\n\n\n\nEspectro Electromagnético Satelital\n\n\n\nCaracterísticas de Satélites y Sensores:\n\nLa energía emitida o reflejada por la superficie terrestre es un fenómeno continuo en 4 cuatro dimensiones: espacio, tiempo, longitud de onda y radiancia.\n\n\n\n\n\nSatélites y Sensores\n\n\nResolución espacial: Tamaño del pixel o celda del raster que contiene a la banda espectral (Landsat: 30 m x 30 m)\n\n\n\nResolución espacial\n\n\nResolución temporal: Tiempo entre imágenes sucesivas (Landsat 16 días)\n\n\n\nResolución temporal\n\n\nResolución espectral: Número y rango de las regiones del espectro electromagnético para los que capta información el sensor .\n\n\n\nResolución espectral\n\n\n\nResolución radiométrica: Indica el número de intervalos de intensidad que puede captar el sensor (escala de grises) (Landsat 5 y 7: 256)\n\n\n\n\nResolución radiométrica\n\n\n\n4.2.1 Aplicaciones de Percepción Remota\n\nAplicaciones Generales: Ambientales\n\nBosque Nativo: Superficie anual, Vigor vegetacional y superficie incendiada\nGlaciares: Superficie de cuerpos glaciares\nAmbiente urbano: Superficie anual cubierta con vegetación por manzana urbana\nAmbiente marino costero: Calidad anual del agua superficial del mar\nHumedales Alto Andino: Superficie anual vegetada e inundada en el humedal\n\n\n\n\nAplicaciones Ambientales; temperatura superficial de glaciar\n\n\nAplicaciones Generales: Antrópicas\n\nMancha Urbana: Crecimiento evolutivo\nContaminación de Recursos Naturales: Borde Costero, red hídrica, cuerpos de agua, suelos, aire.\nDeforestación: Actividad de industria a Forestal\nMonitoreo de Edificaciones: Construcción de Industrias, asentamientos, cualquier edificación de grandes dimensiones\n\n\n\n\nAplicaciones Antrópicas; deforestación"
  },
  {
    "objectID": "raster.html#manipulación-de-datos-raster-de-imágenes-satelitales.",
    "href": "raster.html#manipulación-de-datos-raster-de-imágenes-satelitales.",
    "title": "4  Datos tipo Raster",
    "section": "4.3 Manipulación de datos Raster de imágenes satelitales.",
    "text": "4.3 Manipulación de datos Raster de imágenes satelitales.\n\nLeer Archivos Raster (Imagen Satelital)\nVisualización Raster\nReproyectar imagen tipo Raster (Sistema de Referencia de Coords.)\nCortar Imagen Raster desde archivo Shapefile\nCombinacionaciones de Bandas Satelitales\n\n\n4.3.1 Leer Archivos Raster (Imagen Satelital)\n\n\n\n\nlibrary(raster)\nOLI <- brick(\"../data/raster/corte_rm_m.tif\")\nnames(OLI) <- c(\"aerosol\", \"blue\", \"green\", \"red\", \"nir\", \"swir1\", \"swir2\", \"thermal\")\nOLI\n\n\n\nclass      : RasterBrick \ndimensions : 4830, 5978, 28873740, 8  (nrow, ncol, ncell, nlayers)\nresolution : 30, 30  (x, y)\nextent     : 249045, 428385, 6211135, 6356035  (xmin, xmax, ymin, ymax)\ncrs        : +proj=utm +zone=19 +south +datum=WGS84 +units=m +no_defs \nsource     : corte_rm_m.tif \nnames      :  aerosol,     blue,    green,      red,      nir,    swir1,    swir2,  thermal \nmin values : 7036.001, 6386.001, 5463.000, 4955.001, 4585.000, 4639.001, 4854.000, 4832.000 \nmax values :    49865,    52771,    59275,    56142,    59312,    59124,    54972,    14789 \n\n\n\n\n4.3.2 Visualización Raster\n\nplotRGB(OLI, r = 4, g = 3, b = 2, stretch = \"lin\")\n\n\n\n# viewRGB(OLI, r = 4, g = 3, b = 2)\n\n\n\n4.3.3 Cortar Imagen Raster desde archivo Shapefile\nLeer archivo vectorialde la Región Metropolitana\n\nlibrary(sf)\n\n# Leer geometrías Nacional y filtrar RM\nregion_met <- st_read(\"data/shape/Comunas_Chile.shp\") %>% \n  filter(REGION == \"13\")\n\nReading layer `Comunas_Chile' from data source \n  `/Users/denisberroeta/Library/CloudStorage/OneDrive-UniversidadAdolfoIbanez/Goblab/BDPP_2022/geoanalisis_book/data/shape/Comunas_Chile.shp' \n  using driver `ESRI Shapefile'\nSimple feature collection with 346 features and 9 fields\nGeometry type: MULTIPOLYGON\nDimension:     XY\nBounding box:  xmin: -3701691 ymin: 3734031 xmax: 705926.2 ymax: 8065316\nProjected CRS: WGS 84 / UTM zone 19S\n\n# selección de Comuna\nmi_comuna <-  \"LAS CONDES\"\ncomuna <- region_met %>% filter(NOM_COMUNA == mi_comuna)\n\n\nggplot() +\n  geom_sf(data = comuna, fill = NA, color =\"orange\", \n          alpha=0.8,  size= 1)+\n  ggtitle(paste0(\"COMUNA DE \", mi_comuna) ) +\n  theme_bw() +\n  theme(panel.grid.major = element_line(colour = \"gray80\"), \n        panel.grid.minor = element_line(colour = \"gray80\"))\n\n\n\n\nRealizar el corte de la comuna que seleccione\n\ncomuna_img <- mask(crop(OLI, extent(comuna), snap=\"out\"), comuna)\ncomuna_img\n\nclass      : RasterBrick \ndimensions : 449, 562, 252338, 8  (nrow, ncol, ncell, nlayers)\nresolution : 30, 30  (x, y)\nextent     : 350505, 367365, 6293905, 6307375  (xmin, xmax, ymin, ymax)\ncrs        : +proj=utm +zone=19 +south +datum=WGS84 +units=m +no_defs \nsource     : memory\nnames      : aerosol,  blue, green,   red,   nir, swir1, swir2, thermal \nmin values :    8465,  7604,  6500,  5924,  5520,  5191,  5197,    5002 \nmax values :   19119, 20517, 21248, 23237, 29344, 30012, 31166,    5512 \n\nplotRGB(comuna_img, r = 4, g = 3, b = 2, stretch = \"lin\")\n\n\n\n\n\ncomuna_img_df <- as.data.frame(comuna_img[[-8]])\nsuppressMessages(library(tidyr))\n#Transformar una base con dos columnas \nbase <- gather(na.omit(comuna_img_df), key = \"Banda\", value = \"Valor\")\n\nsuppressMessages(library(ggplot2))\nhist_bandas <- ggplot(base, aes(Valor, fill = Banda)) +\n  geom_histogram(bins = 60) + facet_wrap( ~ Banda) + \n  theme(plot.subtitle = element_text(size = 10, hjust = 0.5),\n        axis.ticks = element_line(colour = \"gray10\"),\n        plot.title = element_text(size = 14, hjust = 0.5,\n        face = \"bold\", colour = \"gray30\"), \n        panel.background = element_rect(fill = \"gray98\")) +\n  labs(title = \"Histograma de las Bandas Espectrales Landsat 8\", \n       subtitle = mi_comuna)\n\n\n\nhist_bandas\n\n\n\n\n\n\n4.3.4 Reproyectar imagen tipo Raster (Sistema de Referencia de Coords.)\n\ncrs_latlon <- \"+proj=longlat +datum=WGS84 +no_defs\"# geográficas o elipsoidales\ncrs_utm <- \"+proj=utm +zone=19 +south +datum=WGS84 +units=m +no_defs\" # UTM o cartográficas\n\n# utm a latlon\ncomuna_img <- projectRaster(comuna_img, crs = crs_latlon)\n\n# latlon a utm\ncomuna_img <- projectRaster(comuna_img, crs = crs_utm)\n\n\n\n4.3.5 Combinacionaciones de Bandas Satelitales\n Referencias: https://mappinggis.com/2019/05/combinaciones-de-bandas-en-imagenes-de-satelite-landsat-y-sentinel/\n\n# Falso Color (7,6,4)\nplotRGB(comuna_img, r = 7, g = 6, b = 4, stretch = \"lin\")\n\n\n\n\n\n\n\n\n\n# Infrarojo (5,4,3)\nplotRGB(comuna_img, r = 5, g = 4, b = 3, stretch = \"lin\")\n\n\n\n\n\n\n\n\n\n# Agricultura (6,5,2)\nplotRGB(comuna_img, r = 6, g = 5, b = 2, stretch = \"lin\")\n\n\n\n\n\n\n\n\n\n# Penetración de la Radiación en la Atmósfera (7,6,5)\nplotRGB(comuna_img, r = 7, g = 6, b = 5, stretch = \"lin\")\n\n\n\n\n\n\n\n\n\n# Uso del Suelo / Masas de Agua (5,6,4)\nplotRGB(comuna_img, r = 5, g = 6, b = 4, stretch = \"lin\")\n\n\n\n\n\n\n\n\n\n# Infrarojo de Onda Corta (7,5,4)\nplotRGB(comuna_img, r = 7, g = 5, b = 4, stretch = \"lin\")\n\n\n\n\n\n\n\n\n\n# Análisis de Vegetación (6,5,4)\nplotRGB(comuna_img, r = 6, g = 5, b = 4, stretch = \"lin\")\n\n\n\n\n\n\n\n\n\n# Análisis de Vegetación Sana (5,6,2)\nplotRGB(comuna_img, r = 5, g = 6, b = 2, stretch = \"lin\")"
  },
  {
    "objectID": "raster.html#construcción-de-indicadores-ambientales",
    "href": "raster.html#construcción-de-indicadores-ambientales",
    "title": "4  Datos tipo Raster",
    "section": "4.4 Construcción de Indicadores ambientales",
    "text": "4.4 Construcción de Indicadores ambientales\n\nCalcular NDVI\nCalcular Indicador Cobertura Vegetacional\n\n\n4.4.1 Calcular NDVI\n\n\n\nFórmula para el cáculo de NDVI\n\n\nCreación de la función de NDVI\n\n#NDVI(img, red, NIR)\nNDVI <- function(img, i, k) {\n   bi <- img[[i]]\n   bk <- img[[k]]\n   vi <- (bk - bi) / (bk + bi)\n   return(vi)\n}\n\n\nNDVI_com <- NDVI(comuna_img, 4, 5)\n\nVisualización de NDVI en ggplot2\n\n# rastero to df (na omit)\nNDVI_com_df <- raster::as.data.frame(NDVI_com, xy = TRUE) %>% na.omit()\n\n#paleta\npal_ndvi<- colorRampPalette(c(\"gray20\", \"yellow\", \"green\",\"springgreen4\"))( 200 )\n\nggplot() +\n  geom_raster(data = NDVI_com_df , \n             aes(x = x, y = y, \n                  fill = layer)) + \n  scale_fill_gradientn(name = \"NDVI\", colors = pal_ndvi)+\n  coord_fixed()+\n  ggtitle(paste0(\"NDVI DE \", mi_comuna) ) +\n  theme_bw() +\n  theme(panel.grid.major = element_line(colour = \"gray80\"), \n        panel.grid.minor = element_line(colour = \"gray80\"))\n\n\n\n\n\n\n4.4.2 Calcular Indicador de Cobertura Vegetacional\nSe ha estudiado que el umbral de valores de NDVI superiores a 0.4 se entienede como vegetación y sana\n\nhist(NDVI_com, col=\"springgreen4\", main=\"Histograma NDVI\",\n  ylab=\"Número de Pixeles\", xlab=\"valor NDVI\")\n\n\n\n\nFigure 4.1: Histograma de valores de NDVI\n\n\n\n\nConsiderando el gráfico anterior se deberá crear una función para definir umbral y eliminar (transformar NA) los valores de pixeles que esten bajo ese umbral.\n\n#función para definir umbral\ncorte_eq_may <- function(value) {\n  function(x) {\n    ifelse(x >= value, 1, NA)\n  }\n}\n\n\nlibrary(mapview)\n\nmapview(NDVI_com, na.color = \"transparent\")\n\n\n\n\n\nAplicación de la función para definir umbral utilizando calc():\n\nvegetacion <- calc(NDVI_com, fun = corte_eq_may(value = 0.30))\n\n\nvegetacion_df <- raster::as.data.frame(vegetacion, xy = TRUE) %>% na.omit()\nggplot() +\n  geom_sf(data = comuna, fill = NA, color =\"orange\", \n          alpha=0.8,  size= 0.5)+\n  geom_raster(data = vegetacion_df , \n             aes(x = x, y = y, \n                  fill = layer)) + \n  scale_fill_gradientn(name = \"Veg\", colors = \"springgreen4\")+\n  ggtitle(paste0(\"VEGETACIÓN DE \", mi_comuna) ) +\n  theme_bw() +\n  theme(panel.grid.major = element_line(colour = \"gray80\"), \n        panel.grid.minor = element_line(colour = \"gray80\"))\n\n\n\n\nVisualización Dinámica\n\nmview <- mapview(vegetacion, na.color = \"transparent\", \n                 col.regions = \"springgreen4\", legend =FALSE)+\n  mapview(comuna, color = \"magenta\", alpha.region =0, size = 2,\n          legend =FALSE)\nmview\n\n\n\n\n\n\n\n\nCrear Indicador por manzana:\n\nPara esto se debe contar los pixeles que existe por manzana calcular su superficie sabiendo la resolución espacila (30x30) y dividirla por el toral de superficie de la manzana, afin de obtener un porcentaje de cobertura vegetal por manzana.\n\n\nLeer manzanas del Censo\n\nmz_comuna <- readRDS(\"data/censo/manzanas.rds\") %>% \n  filter(NOM_COM == mi_comuna) %>% \n  st_transform(32719)\n\nCalcular el área por cada polígono\n\nmz_comuna <-  mz_comuna %>% \n  mutate(AREA = as.numeric(st_area(.))) #mts2\n\nContar los piexeles por manzana y multiplicar por área que representan estos pixeles. Para contar la cantidad de pixeles por manzana usaremos la función exacextract()\n\nlibrary(exactextractr)\n\nmz_comuna  <- mz_comuna %>% \n  mutate(pix_veg = exact_extract(vegetacion,y = ., 'sum', progress = FALSE)) %>% \n  mutate(area_veg = pix_veg * 30 * 30) %>% # resolución espacial landsat (30*30)\n  mutate(ICV = round((area_veg /AREA)*100, 1))  \n\nVisualización del Indicador\n\nggplot() +\n  geom_sf(data = mz_comuna, aes(fill = ICV), color =\"gray70\", \n          alpha=0.8,  size= 0.1)+\n  scale_fill_distiller(palette= \"Greens\", direction = 1)+\n  ggtitle(\"Indicador de Cobertura Vegetal (ICV) - Urbano\") +\n  theme_bw() +\n  theme(panel.grid.major = element_line(colour = \"gray80\"), \n        panel.grid.minor = element_line(colour = \"gray80\"))"
  },
  {
    "objectID": "inferencia.html",
    "href": "inferencia.html",
    "title": "5  Inferencia Espacial",
    "section": "",
    "text": "Objetivos del Módulo\n\n\n\nConocer los fundamentos teóricos de la inferencia espacial\nConstrucción Indicadores en base de Kernel Density Estimation (KDE)\nConstrucción Indicadores en base de Interpolación Inverso a la Distancia ponderada (IDW)"
  },
  {
    "objectID": "inferencia.html#kernel-density-estimation",
    "href": "inferencia.html#kernel-density-estimation",
    "title": "5  Inferencia Espacial",
    "section": "5.2 Kernel Density Estimation",
    "text": "5.2 Kernel Density Estimation\n\n5.2.1 Introducción\nIdentificar el tipo de distribución que tiene a una variable es un paso fundamental en prácticamente todos los estudios que implican datos, son muchas las ventajas que tiene disponer de una función que describa aproximadamente los datos. Por ejemplo, se puede calcular la probabilidad (o densidad en el caso de variables aleatorias continuas) de que una observación tome un determinado valor. También es posible simular nuevos. valores.\nEn términos generales, ajustar una distribución consiste en encontrar una función matemática capaz de describir un conjunto de datos. De entre todas las posibles funciones candidatas, lo interesante es encontrar aquella que, con mayor probabilidad, puede haber generado los datos observados.\nUna de las aproximaciones más prácticas es utilizar como candidatas distribuciones paramétricas, estas son distribuciones conocidas cuyo comportamiento está determinado usando un número finito de parámetros. Por ejemplo, la distribución normal está parametrizada por la media y la desviación típica.\nCuando ninguna de las distribuciones paramétricas disponibles describe correctamente los datos, es necesario recurrir lo que se conoce como métodos de ajuste no paramétricos, cuyo objetivo es encontrar funciones que describan distribuciones cualesquiera, entendiendo por cualesquiera a que no se limitan a las distribuciones paramétricas conocidas. Uno de los métodos más empleados es kernel density estimation (KDE).\n\n\n5.2.2 Conceptos relacionados KDE en general\nEn estadística, kernel density estimation (KDE), es un método no paramétrico que permite estimar la función de densidad de probabilidad de una variable aleatoria a partir de un número finito de observaciones (muestra). Fué propuesto por Fix y Hodges (1951) y Rosenblatt (1956).\nUna forma de entender cómo funciona un kernel density estimation (KDE) es partiendo del histograma. El histograma es una de las formas más utilizadas en estadística para representar la distribución de datos unidimensionales.\n\n\n\nHistograma de una variable aleatoria bimodal\n\n\nEl Kernel density estimation (KDE) expande la idea del histograma, “cada observación aumenta la densidad de probabilidad en la zona donde se encuentra”, pero lo hace de forma que las contribuciones se agrupen creando una curva continua y suave (smooth).\n\n\n\nObservaciones y sus posiciones ordenadas\n\n\nA continuación, sobre cada observación se centra una distribución normal, con media igual al valor de la observación y desviación típica de 1 (más adelante se detalla la elección de este valor).\n\n\n\nDistribución normal por cada observaciones con media igual valor y desviación estándar = 1\n\n\nDe esta forma se consigue que cada observación contribuya justo en la posición que ocupa pero también, de forma gradual, en las regiones cercanas.\nPor último, si se suman las contribuciones individuales y se dividen por el total de curvas (observaciones), se consigue una curva final que describe la distribución de las observaciones.sy\n\n\n\nSuma de las Distribuciones\n\n\nEn esta idea se fundamenta el método kernel density estimation (KDE): aproximar una función de densidad como la suma de funciones (kernel) de cada observación.\nDefinición matemática\nDado un conjunto de datos x={x_1,x_2,...,x_n} la función de distribución de densidad f(x) puede aproximarse utilizando un kernel density estimation (KDE) tal que:\n\n\\hat{f}(x)=\\frac{1}{n}\\sum_{i = 1}^{n}K_h(x-x_i)= \\frac{1}{nh}\\sum_{i = 1}^{n}K\\left(\\frac{x-x_i}{h}\\right)\n\n\nn: es el número de datos (observaciones). Cada uno de ellos es el centro sobre el que se coloca un kernel.\nh: es el ancho de banda (bandwidth o smoothing parameter). Controla cuánto se expande la influencia de cada observación. Si se emplea como kernel una distribución normal, equivale a la desviación típica. Este es el valor más determinante a la hora de ajustar un KDE, puesto que condiciona el nivel de sobreajuste.\nK: es el Kernel, una función que define la forma y la distribución de la influencia (peso) que se asocian a cada observación. En los ejemplos anteriores se ha utilizado como kernel la distribución normal.\n\nSelección de Ancho de Banda\nEl ancho de banda es crucial a la hora de estimar una función densidad mediante el método KDE. Si su valor es muy bajo, se genera overfitting y la función resultante estará demasiado influenciada por el “ruido” de los datos. Si su valor es muy elevado, la función resultante no será capaz de aprender la distribución subyacente.\n\n\n\nTipos de Distribuciones de acuerdo a valor de ancho de Banda\n\n\nReglas empíricas\n\nScott’s rule: h≈1.06 \\cdot \\hat{\\sigma}n^{−1/5}\nSilverman’s rule: h=0.9\\cdot min(\\hat{\\sigma},IQR/1.35)n^{−1/5}\n\nSi bien estos métodos son muy rápidos, tienen el limitante de funcionar bien solo cuando la función de densidad real es aproximadamente normal.\nTambién se puede usar validación cruzada que requiere de mayor tiempo de computación pero es útil para cualquier tipo de distribución. Validación cruzada es la opción disponible en Scikit learn, utilizando como métrica de comparación en log-likelihood.\nEs importante destacar que, cuando se dispone de pocos datos, conviene utilizar one leave out crossvalidation.\nTipos de kernel\nEl kernel es la función que determina cómo se distribuye la influencia de cada observación, por lo tanto, puede tener un impacto notable en la estimación de la función de densidad resultante. Aunque en la gran mayoría de casos se emplea un kernel gaussiano (distribución normal), existen otras posibilidades.\n\nGaussian: asigna los pesos siguiendo la distribución normal con una desviación estándar equivalente al ancho de banda.\nEpanechnikov: las observaciones que están a una distancia entre 0 y h tienen un peso entre \\frac{3}{4} y 0 con disminución cuadrática. Toda observación fuera de este rango tiene pero 0.\nTophat: Asigna el mismo peso a todas las observaciones que estén dentro del ancho de banda.\nExponential: el peso decae de forma exponencial.\nLinear: el peso decae de forma lineal dentro del ancho de banda. Más allá de este el pero es 0.\nCosine: el peso dentro del ancho de banda es proporcional al coseno.\n\n\n\n\nAlgunos tipos de Kernel más utilizados\n\n\nTO-DO: Agregar formulas de cada Kernel\n\n\n5.2.3 KDE aproximación espacial\nPara entender el concepto KDE se presentó anteriormente en su forma básica correspondiente a una distribución univariada, como por ejemplo la distribución (bimodal) siguiente:\n\n\n\nDistribución Univariada\n\n\nPara aplicar los KDE a casos espaciales, se tiene que entender que las variables aleatorias antes señaladas, ahora van a corresponder a eventos o condiciones físicas que ocurren en el espacio, por ende bajo un sistema de coordenadas, por lo cual el eje de coordenadas x e y que también intervienen como nuevas dimensiones, entonces los que se predente estimar una distribución multivariante.\n\n\n\nDe puentos espaciales a Mapa de Densidad.\n\n\nUna de las aplicaciones más comunas es de el análisis criminal, ya que los algunas categorías delitos coproducen bajo ciertas condiciones espaciales.\n\n\n\nEjemplo de Kernel Density Estimation de Delitos en Domicilios en la Comuna de Las Condes\n\n\nEntonces para el caso espacial lo que se prentende identificar patrones de cluster basándose en proximidad espacial\nLos elementos del KDE Univariado tambien están presentes en el caso espacial como por ejemplo en ancho debanda como se observa a continuación.\n\n\n\nKDE Espacial con diferentes tipos de Ancho de Banda.\n\n\n\n\n5.2.4 Kernel Density Estimation en delitos Violentos\nExiste una gama importante de métodos de interpolación como el Kriging, las superficies de tendencia, el inverso de la distancia y los modelos de regresión local, (Anselin, 1992; Clevelend at al. 1993, Venables & Ripley, 1997) los cuales requieren en su mayoría que los puntos de muestreo/entrada asuman valores heterogéneos diferentes de cero.\nConsiderando que los dato con que se trabajará son eventos delictivos, por ensde no se hace muetreo de la información, el universo está dado por la totalidad de los eventos registrados, adicionalmente cada punto representa un evento particular.\nComo no en toda la superficie de una zona de estudio han sucedido delitos, pero existe una probabilidad de que ocurran, la estimación de densidad de kernel sirve para calcular esa probabilidad (Smith & Bruce 2008, 60-64) de modo que la interpolación produce “superficies de riesgo”.\n\n\n\nSuma de funciones normales de Kernel de 5 Puntos\n\n\nFuente: Estimación de densidad de Kernel. Adaptado de Wilson, R. y Eck, J. (2005: 27).\nCargar Librerías\n\nlibrary(rgdal)\nlibrary(sf)\nlibrary(dplyr)\nlibrary(rgeos)\nlibrary(raster)\nlibrary(spatstat)\nlibrary(spdep)\nlibrary(mapview)\nlibrary(viridis)\nlibrary(ggplot2)\n\nLectura de casos violencia (Las Condes, anonimizados)\n\nviolencia_df <- readRDS(file = \"data/delitos/casos_violencia.rds\")\nhead(violencia_df)\n\n     id        x       y\n4423  1 351501.2 6301276\n4836  2 359214.9 6303245\n4837  3 351866.6 6301303\n4844  4 351303.1 6301359\n4916  5 351536.6 6301306\n5125  6 357105.9 6301723\n\n\nTransformar a Objeto Espacial\n\nviolencia <-  st_as_sf(x = violencia_df, \n                          coords = c(\"x\", \"y\"), crs = 32719)\n\nggplot() +\n  geom_sf(data = violencia,  color =  \"red\", \n          alpha=0.8,  size= 0.1)+\n  scale_fill_distiller(palette= \"YlGnBu\", direction = 1)+\n  ggtitle(\"Delitos Violentos en Las Condes\") +\n  theme_bw() +\n  theme(panel.grid.major = element_line(colour = \"gray80\"), \n        panel.grid.minor = element_line(colour = \"gray80\"))\n\n\n\n\nKDE con Raster\nCalcular KDE con Función cuartica o esférica (quartic)\nSupone una distribución relativamente uniforme que al llegar a cierto umbral decae sin suavidad:\n\n\n\nKernel cuártica o esférica\n\n\nDefinir Parámetros\n\nlibrary(SpatialKDE)\n\n#Definirán Parámemetros de Estudio\ncell_size <- 100 # Tamaño de Celda\nband_width <- 500 #  Parámetro de Suavisado (denominada ventana o h)\n\nCrear Raster Vacío\n\nraster_violencia <- violencia %>% \n  create_raster(cell_size = cell_size, side_offset = band_width)\n\nCrear Kernel raster\n\nkde_raster <- violencia %>% \n  kde(band_width = band_width, kernel = \"quartic\", grid = raster_violencia)\n\nHistograma de valores de Densidad\n\nhist(kde_raster, col=\"springgreen4\", main=\"Histograma KDE\",\n  ylab=\"Número de Pixeles\", xlab=\"valor KDE\")\n\n\n\n# writeRaster(kde_raster, \"data/delitos/kde_delvio_LC.tif\")\n\nVisualizar Raster KDE con ggplot\n\n# rastero to df (na omit)\nkde_raster_df <- raster::as.data.frame(kde_raster, xy = TRUE) %>% na.omit()\n\numbral <- 1\nkde_raster_df <- kde_raster_df %>% \n  mutate(layer = ifelse(layer < umbral, NA, layer))\n\n\nggplot() +\n  geom_raster(data = kde_raster_df %>% na.omit() , \n             aes(x = x, y = y, \n                  fill = layer)) + \n  scale_fill_gradientn(name = \"KDE\", \n                       colors = (viridis::magma(100)), na.value = NA)+\n  coord_fixed()+\n  ggtitle(paste0(\"KDE Raster de Delitos\") ) +\n  theme_bw() +\n  theme(panel.grid.major = element_line(colour = \"gray80\"), \n        panel.grid.minor = element_line(colour = \"gray80\"))\n\n\n\n\nFunción Para filtrar Raster (solo para tener en cuenta)\n\nna_menor <- function(x){\n  x[x < 10] <- NA\n  return(x)\n}\nkde_raster2 <- calc(kde_raster, fun = na_menor)\n\nKDE a Indicador Territorial\nLeer manzanas del Censo\n\nmi_comuna <-  \"LAS CONDES\"\nmz_comuna <- readRDS(\"data/censo/manzanas.rds\") %>% \n  filter(NOM_COM == mi_comuna) %>% \n  st_transform(32719)\n\nCálculo de Indicador de Delitos Violentos\n\nlibrary(exactextractr)\n\nmz_comuna  <- mz_comuna %>% \n  mutate(idelv = exact_extract(kde_raster,y = ., 'mean', \n                               progress = FALSE))\n\n# saveRDS(mz_comuna, \"data/delitos/idel_violentos_LC.rds\")\n\nVisualización del Indicador\n\n# pal_idelv<- colorRampPalette(c(\"white\",  \"red\"))( 100 )\nggplot() +\n  geom_sf(data = mz_comuna, aes(fill = idelv), color =\"gray80\", \n          alpha=0.8,  size= 0.1)+\n  # scale_fill_gradientn(colors = pal_idelv)+\n  scale_fill_distiller(palette= \"Reds\", direction = 1)+\n  ggtitle(\"Indicador de Delitos Violentos\") +\n  theme_bw() +\n  theme(panel.grid.major = element_line(colour = \"gray80\"), \n        panel.grid.minor = element_line(colour = \"gray80\"))"
  },
  {
    "objectID": "inferencia.html#interpolación-inverso-a-distancia-ponderada-idw",
    "href": "inferencia.html#interpolación-inverso-a-distancia-ponderada-idw",
    "title": "5  Inferencia Espacial",
    "section": "5.3 Interpolación Inverso a Distancia Ponderada IDW",
    "text": "5.3 Interpolación Inverso a Distancia Ponderada IDW\n\n5.3.1 Definiciones\nEste tipo de interpolación, determina los valores de celda a través de una combinación ponderada linealmente de un conjunto de datos de puntos de muestra. Esto significa que los puntos de muestreo se ponderan de tal manera que la influencia de un punto frente a otro, disminuye con la distancia.\nCuanto más cerca está un punto del centro de la celda que se está estimando, más influencia o peso tendrá en el proceso de cálculo del promedio.\n\n\n\nEstimación de valores por interpolación de inverso a la distancia\n\n\nlos puntos rojos tienen valores de elevación conocidos. Los otros puntos serán interpolados. Si desea medir el punto púrpura, puede configurar su interpolación para que tome un número fijo o variable de puntos. En este ejemplo, utiliza un número fijo de 3 puntos de 3 y utiliza los tres puntos más cercanos.\n\n\n\nDescripción gráfica de los resultados de interpolación\n\n\nDado que la IDW es un promedio de distancia ponderada, el promedio no puede ser mayor que la entrada máxima o inferior que la entrada mínima. Por lo tanto, no puede crear crestas o valles si estos extremos aún no se han muestreado (Watson y Philip 1985).\n\n\n5.3.2 Usos prácticos\nPasos\n\nDefinición de Área de Estudio\nInterpolación de información Comercio y Oficina\nCrear Indicador de Atractor de Comercios y Oficina\n\nDesarrollo\nDefinición de Área de Estudio\nPara efectos de este ejemplo práctico se utilizará el área urbana de la comuna de Las Condes.\n\nmi_comuna <-  \"LAS CONDES\"\nzonas <-  readRDS(\"data/censo/zonas_urb_consolidadas.rds\")\ncomuna <-  zonas %>% filter(NOM_COMUNA == mi_comuna)\n\nVisualizaciíon de Área de Estudio\n\nggplot() +\n  geom_sf(data = comuna, aes(fill = ESC_JH), color =NA, \n          alpha=0.8,  size= 0.1)+\n  scale_fill_distiller(palette= \"YlGnBu\", direction = 1)+\n  ggtitle(\"Población Zonas Censales - Urbano\" ) +\n  theme_bw() +\n  theme(panel.grid.major = element_line(colour = \"gray80\"), \n        panel.grid.minor = element_line(colour = \"gray80\"))\n\n\n\n\nObtener el Borde comunal\n\ncomuna_border <- comuna %>% st_union()\n\n\nggplot() +\n  geom_sf(data = comuna_border, fill = \"gray90\", color =\"gray30\", \n          alpha=0.8,  size= 0.8)+\n  ggtitle(\"Borde Zonas Censales - Urbano\" ) +\n  theme_bw() +\n  theme(panel.grid.major = element_line(colour = \"gray80\"), \n        panel.grid.minor = element_line(colour = \"gray80\"))\n\n\n\n\nImputar información SII a zonas censales\nLectura de datos de SII (puntos)\n\nsii_ptos <- st_read(\"data/sii/urbes.shp\", quiet = T)\n\nSelección de Comuna\n\ncomuna_sii <-  sii_ptos %>% filter(n_com == mi_comuna) %>% \n  st_transform(32719)\n# comuna_sii\n\nVisualización de los Puntos del SII\n\nggplot() +\n  geom_sf(data = comuna_sii,  color =\"orange\", \n          alpha=0.8,  size= 0.5)+\n  ggtitle(\"Predios SII - Urbano\" ) +\n  theme_bw() +\n  theme(panel.grid.major = element_line(colour = \"gray80\"), \n        panel.grid.minor = element_line(colour = \"gray80\"))\n\n\n\n\nInterpolación de Inverso a la Distancia ponderada por Atractores (SII)\nDefinción ventana de trabajo\n\ncrs_utm <- \"+proj=utm +zone=19 +south +datum=WGS84 +units=m +no_defs\" # 32719\nsuppressMessages(library(raster))\n# grilla desde mancha comuna\nurbano_utm <- st_transform(comuna, crs_utm)\nurbano_sp <- as(urbano_utm, \"Spatial\")\next <- raster::extent(urbano_sp)\nx_min <- ext[1] - 100\nx_max <- ext[2] + 100\ny_min <- ext[3] - 100\ny_max <- ext[4] + 100\n\nDefinción grilla de interpolación**\n\n## Definir espaciado de interpolacion\ngrd=expand.grid(x = seq(from = x_min,to = x_max, by=100),\n                y = seq(from = y_min,to = y_max, by=100))\ncoordinates(grd)=~x+y\ngridded(grd)=T\nproj4string(grd)= \"+proj=utm +zone=19 +south +datum=WGS84 +units=m +no_defs\" # 32719\nplot(grd)\n\n\n\n\n\n\n\n\nCálculo de Interpolación de Inverso a la Distancia\n\n# Decsar Valores NA\nsii_sp <- comuna_sii%>%\n  st_transform(crs_utm) %>% \n  filter(!is.na(atractor))%>%\n  as(\"Spatial\")\n\n\ninterp_sii=gstat::idw(formula = sii_sp@data$atractor ~ 1, \n                 locations = sii_sp, \n                 newdata = grd, idp = 1,\n                 na.action = na.omit, nmax = 4)\n\n[inverse distance weighted interpolation]\n\n\nAjustes del Resultado\n\nAsiganar CRS\nTranformar valores NA a 0\nTransformar raster y cortar por contorno urbano\n\n\nproj4string(interp_sii) = proj4string(sii_sp) # Asignar crs\ninterp_sii@data[is.na(interp_sii@data)] = 0 # trasnformar los valores 0 en NA\ninterp_sii <- mask(raster(interp_sii, values = T), urbano_sp) # cortar por borde comunal\n\nVisualización\n\ninterp_sii_df <- raster::as.data.frame(interp_sii, xy = TRUE) %>% na.omit()\n\nggplot() +\n  geom_raster(data = interp_sii_df , \n             aes(x = x, y = y, \n                  fill = var1.pred)) + \n  scale_fill_gradientn(name = \"IDW\", \n                       colors = (viridis::viridis(100)), na.value = NA)+\n  coord_fixed()+\n  ggtitle(paste0(\"IDW Atractores de Comercio y Oficina\") ) +\n  theme_bw() +\n  theme(panel.grid.major = element_line(colour = \"gray80\"), \n        panel.grid.minor = element_line(colour = \"gray80\"))\n\n\n\n\nCálculo de Indicador de Atractor IDW\n\nmz_comuna  <- mz_comuna %>% \n  mutate(atractor_sii = exact_extract(interp_sii,y = ., 'mean', \n                               progress = FALSE))\n\nVisualización del Indicador atractor_sii\n\nggplot() +\n  geom_sf(data = mz_comuna, aes(fill = atractor_sii), color =NA, \n          alpha=0.8,  size= 0.1)+\n  scale_fill_viridis_c()+\n  ggtitle(\"Indicador de Atractor de Comercio y Oficinas\") +\n  theme_bw() +\n  theme(panel.grid.major = element_line(colour = \"gray80\"), \n        panel.grid.minor = element_line(colour = \"gray80\"))"
  },
  {
    "objectID": "inferencia.html#referencias",
    "href": "inferencia.html#referencias",
    "title": "5  Inferencia Espacial",
    "section": "5.4 Referencias",
    "text": "5.4 Referencias\n\nAjuste de distribuciones con kernel density estimation y Python\nRole of Big Data in the Development of Smart City by Analyzing the Density of Residents in Shanghai\nHow Is the Confidentiality of Crime Locations Affected by Parameters in Kernel Density Estimation?\nIDW (Spatial Analyst)\nIMPORTANCIA DE LOS ESPACIOS COMUNES: UNA ADAPTACIÓN DE LA TÉCNICA DE INTERPOLACIÓN ESPACIAL INVERSE DISTANCE WEIGHTED (IDW) EN LA PREDICCIÓN DE DATOS SOCIOECONÓMICOS AUSENTES"
  },
  {
    "objectID": "autocorrelacion.html",
    "href": "autocorrelacion.html",
    "title": "6  Autocorrelación Espacial",
    "section": "",
    "text": "Objetivos del Módulo\n\n\n\nConceptos Generales de Autocorrelación Espacial\nDefinición de Matrices de vecindad\nCálculo de índice de Moran (global y local)"
  },
  {
    "objectID": "autocorrelacion.html#conceptos-generales-de-autocorrelación-espacial",
    "href": "autocorrelacion.html#conceptos-generales-de-autocorrelación-espacial",
    "title": "6  Autocorrelación Espacial",
    "section": "6.2 Conceptos Generales de Autocorrelación Espacial",
    "text": "6.2 Conceptos Generales de Autocorrelación Espacial\n\n6.2.1 Introducción\nLa primera ley de la geografía de Tobler: “Todo está relacionado con todo lo demás, pero las cosas cercanas están más relacionadas que las lejanas” no se cumple de siempre de forma absoluta. Es y ha sido siempre una simplificación excesiva, que encubre posibles problemas subyacentes de entitación, apoyo y otros errores de especificación. ¿Son las unidades de observación apropiadas para la escala del proceso espacial subyacente? ¿Podría explicarse el patrón espacial de la variable de interés para la entitación elegida mediante otra variable?\nTeniendo lo anterior como contexto, existe un test estadístico que nos permite estimar bajo ciertas condiciones evidencia la autoproducción espacial llamado I de Moran es posiblemente el indicador más utilizado de autocorrelación espacial global y para ampliamente utilizado para en temáticas segregación o clusterización social. Fue sugerido inicialmente por (P. Moran 1948) y popularizado a través del trabajo clásico sobre autocorrelación espacial de Cliff y Ord (1973).\nA continuación se realizará un análisis teórico y práctico de las diferentes técnicas de autocorrelación espacial usado en ciencias sociales, en particular haciendo usos de Índice de Moran y todos los tratamientos previos. Se tratará evidenciar estadísticamente si existe agrupamiento o segregación por nivel Socieconómico en la una comuna de Chile, haciendo uso del nivel de años de estudio de jefe de hogar, más aún, identificar espacialmente donde se ubican estas concentraciones tanto de ingresos alto como bajos.\nPasos:\n\nPreparación de Datos\nMatriz de Vecindad\nIndicador de Global Moran\nIndicador de Local Moran"
  },
  {
    "objectID": "autocorrelacion.html#prepararación-de-datos",
    "href": "autocorrelacion.html#prepararación-de-datos",
    "title": "6  Autocorrelación Espacial",
    "section": "6.3 Prepararación de Datos",
    "text": "6.3 Prepararación de Datos\nCargar Librerías\n\nlibrary(dplyr)\nlibrary(sf)\nlibrary(ggplot2)\nlibrary(raster)\nlibrary(mapview)\nlibrary(spdep)\nlibrary(spatstat)\n\nLectura de Manzanas Censales\nSe procede a leer las manzanas censales y se filtra la comuna objeto de estudio, para efecto de este documento se seleccionará la comuna de LAS CONDES.\n\nmi_comuna <-  \"LAS CONDES\"\nmz_comuna <- readRDS(\"data/censo/manzanas.rds\") %>% \n  filter(NOM_COM == mi_comuna) %>% \n  st_transform(32719)\n\nEliminar valores Nulos\nEs procedimiento es clave para realizar los cálculos posteriores, por lo cual se debe eliminar las manzanas sin registros de población y por ende sin registro de escolaridad del jefe de hogar.\n\nmz_comuna <-  mz_comuna %>% \n  mutate(nived = JH_ESC_P) %>% # Usaremos variable auxiliar de nivel educacional\n  filter(!is.na(nived))\n\nVisualización del Escolaridad del Jefe de Hogar\n\nggplot() +\n  geom_sf(data = mz_comuna, aes(fill = nived), color =\"gray80\", \n          alpha=1,  size= 0.1)+\n  scale_fill_distiller(palette= \"YlGnBu\", direction = 1)+\n  ggtitle(\"Nivel Educacional del Jefe de Hogar\") +\n  theme_bw() +\n  theme(plot.title = element_text(size=12))+\n  theme(panel.grid.major = element_line(colour = \"gray80\"), \n        panel.grid.minor = element_line(colour = \"gray80\"))"
  },
  {
    "objectID": "autocorrelacion.html#construcción-de-la-matriz-de-vecindad",
    "href": "autocorrelacion.html#construcción-de-la-matriz-de-vecindad",
    "title": "6  Autocorrelación Espacial",
    "section": "6.4 Construcción de la Matriz de Vecindad",
    "text": "6.4 Construcción de la Matriz de Vecindad\nLa matriz de vecindad W_{ij} es un elemento central de la estadística y el análisis espacial es la cercanía y la distancia, a partir de la cual definimos que elementos cercanos, o vecinos.\nMatemáticamente se puede expresar si ciertos elementos son continuos:\nW=(w_{ij}:i,j=1,...,n)\nDonde los el valor de w_ij expresa la relación de vecindad entre los elementos i y j:\nw_{ij} = \\begin{cases}1 \\space vecino \\\\\n0 \\space no \\space vecino\n\\end{cases}\nComo ilustración, si tuviéramos 3 observaciones y una matriz de la siguiente forma: $$$$\nW=\\begin{pmatrix}\nw_{11} & w_{12} & w_{13} \\\\\nw_{21} & w_{22} & w_{23} \\\\\nw_{31} & w_{32} & w_{33}\n\\end{pmatrix}=\\begin{pmatrix}\n1 &  0 & 0 \\\\\n1 &  1 & 0 \\\\\n1 &  0 & 0\n\\end{pmatrix}\nPolígonos a puntos\n\nptos_comuna <- mz_comuna%>%\n  st_geometry() %>%\n  st_centroid()\n\nggplot() +\n  geom_sf(data = ptos_comuna,  color =\"#525252\", alpha=1,  size= 0.5)+\n  ggtitle(\"Puntos Centroides de Manzanas\") +\n  theme_bw() +\n  theme(plot.title = element_text(size=12))+\n  theme(panel.grid.major = element_line(colour = \"gray80\"), \n        panel.grid.minor = element_line(colour = \"gray80\"))\n\n\n\n\nCálculo de K Vecinos\nAunque existen muchas de construir una matriz de vecindad, para los efectos prácticos usaremos el algoritmo K Vecinos más Cercanos conocido de knn (K Nearest Neightbours).\nPara definir la vecindad se calcula la distancia desde un origen una centroide de manzana cualquiera respecto a todas las demás, quedando con las k distancias mas cortas.\nDistancia Euclidiana:  Para calcular la separación entre dos puntos la distancia Euclidiana es la más utilizada y se define matemáticamente con la siguiente ecuación (Equation 6.1):\nd_{ij}= \\sqrt{(x_i-x_j)^2+(y_i-y_j)^2} \\tag{6.1}\nEs la distancia “ordinaria” entre dos puntos de un espacio euclídeo, la cual se deduce a partir del teorema de Pitágoras.\n\n\n\nRepresentación gráfica de la Distancia Euclediana\n\n\nDistancia Great Circle: El el tipo de distancia que utiliza cuando las objetos espaciales se encuentran coordenadas geográfica ya que considera la curvatura de la tierra.\n\n\n\nDistancia Great Circle\n\n\n\n# vecinos mas cercanos (neighbours)\nk <- 8 # numero de vecinos a buscar\nnb_mzs <- knearneigh(ptos_comuna, k = k) %>%  # por punto calcula K vecinos\n  knn2nb() # Knn a matriz de vecindad\n\nVisualización de la relaciones por cada Centroide\n\n# matri< de vecindad a lines solo oara visualizaciñon\nneighbors_sf <- as(nb2lines(nb_mzs, coords = st_geometry(ptos_comuna)), 'sf')\n\np_mv <- ggplot() +\n  geom_sf(data = mz_comuna, fill = NA, color =\"gray60\", alpha=1,  size= 0.3)+\n  geom_sf(data = neighbors_sf,  color = \"red\", alpha=0.5,  size= 0.5)+\n  geom_sf(data = ptos_comuna,  color =\"#525252\", alpha=1,  size= 1)+\n  ggtitle(\"Relaciones de Vecindad por cada manzana (k = 8)\") +\n  theme_bw() +\n  theme(plot.title = element_text(size=12))+\n  theme(panel.grid.major = element_line(colour = \"gray80\"), \n        panel.grid.minor = element_line(colour = \"gray80\"))\n\np_mv\n\n\n\n\nRevisión de la Matriz\nSolo para ver la estructura de relaciones, correspondiente una matriz simétrica n \\times n donde la diagonal es 0. El valor 0 representa no relación y 1 relación o conexión.\n\n# relaciones entre 10 primeros elementos\nmatriz_vec <- listw2mat(nb2listw(nb_mzs, style = \"B\"))\ndim(matriz_vec)\n\n[1] 1474 1474\n\n# rowSums(matriz_vec) %>% max()\n\n\n\n\nEstrucutura de una Matriz de Distancia\n\n\n\nmatriz_vec[1:10,1:10]\n\n   [,1] [,2] [,3] [,4] [,5] [,6] [,7] [,8] [,9] [,10]\n1     0    1    1    1    1    0    0    1    0     1\n2     1    0    1    1    1    0    0    1    0     1\n3     1    1    0    0    1    0    0    1    0     1\n4     1    0    0    0    1    1    1    1    0     1\n5     1    1    0    1    0    1    0    1    0     1\n6     1    0    0    1    1    0    1    1    0     0\n7     0    0    0    1    1    1    0    1    0     0\n8     1    1    1    0    1    0    0    0    0     1\n9     0    0    0    0    1    0    0    1    0     1\n10    1    0    1    0    1    0    0    1    1     0\n\n\nAsignar Pesos por Población\nAhora a la matriz de vecindad le vamos a convertir en una matriz de pesos y para nuestro caso vamos asignar los pesos por población, asumiendo que la influencia por cercanía espacial sería proporcional a la cantidad de personas.\n\nnb <-nb2listw(nb_mzs)\nmz_comuna$id <- 1:nrow(mz_comuna)\n\n# Estado actual (todos los vecinos pesan lo mismo)\nnb$weights %>% head(5)\n\n[[1]]\n[1] 0.125 0.125 0.125 0.125 0.125 0.125 0.125 0.125\n\n[[2]]\n[1] 0.125 0.125 0.125 0.125 0.125 0.125 0.125 0.125\n\n[[3]]\n[1] 0.125 0.125 0.125 0.125 0.125 0.125 0.125 0.125\n\n[[4]]\n[1] 0.125 0.125 0.125 0.125 0.125 0.125 0.125 0.125\n\n[[5]]\n[1] 0.125 0.125 0.125 0.125 0.125 0.125 0.125 0.125\n\n\nEl siguiente bloque de código a través de un proceso iterativo identifica el id de cada uno de los 8 vecinos, captura la población y le asigna la proporción respecto a la suma de personas de las manzanas de los 8 vecinos.\n\nnb$weights = lapply(1:nrow(mz_comuna), function(i)\n  mz_comuna$POBLACION[mz_comuna$id %in% nb$neighbours[[i]]] / \n    sum(mz_comuna$POBLACION[mz_comuna$id %in% nb$neighbours[[i]]]))\n\nnb$weights %>% head(5)\n\n[[1]]\n[1] 0.06053812 0.28699552 0.11210762 0.21973094 0.11883408 0.05381166 0.06950673\n[8] 0.07847534\n\n[[2]]\n[1] 0.41724618 0.17802503 0.06954103 0.13630042 0.07371349 0.03337969 0.04311544\n[8] 0.04867872\n\n[[3]]\n[1] 0.48231511 0.04340836 0.15755627 0.08520900 0.03858521 0.04983923 0.08681672\n[8] 0.05627010\n\n[[4]]\n[1] 0.38119441 0.12452351 0.21092757 0.10165184 0.06734435 0.03049555 0.03939009\n[8] 0.04447268\n\n[[5]]\n[1] 0.43731778 0.03935860 0.07288630 0.24198251 0.07725948 0.03498542 0.04518950\n[8] 0.05102041\n\n\nVolvamos a revisar la matriz de distancia pero ponderada por población.\n\n# relaciones entre 10 primeros elementos\nmatriz_vec_pond <- listw2mat(nb)\ndim(matriz_vec_pond)\n\n[1] 1474 1474\n\n# rowSums(matriz_vec_pond)\n\nmatriz_vec_pond[1:10,1:10]\n\n        [,1]       [,2]      [,3]       [,4]      [,5]      [,6]      [,7]\n1  0.0000000 0.06053812 0.2869955 0.11210762 0.2197309 0.0000000 0.0000000\n2  0.4172462 0.00000000 0.1780250 0.06954103 0.1363004 0.0000000 0.0000000\n3  0.4823151 0.04340836 0.0000000 0.00000000 0.1575563 0.0000000 0.0000000\n4  0.3811944 0.00000000 0.0000000 0.00000000 0.1245235 0.2109276 0.1016518\n5  0.4373178 0.03935860 0.0000000 0.07288630 0.0000000 0.2419825 0.0000000\n6  0.4267425 0.00000000 0.0000000 0.07112376 0.1394026 0.0000000 0.1137980\n7  0.0000000 0.00000000 0.0000000 0.09727626 0.1906615 0.3229572 0.0000000\n8  0.4304161 0.03873745 0.1836442 0.00000000 0.1406026 0.0000000 0.0000000\n9  0.0000000 0.00000000 0.0000000 0.00000000 0.0798696 0.0000000 0.0000000\n10 0.3521127 0.00000000 0.1502347 0.00000000 0.1150235 0.0000000 0.0000000\n         [,8]      [,9]      [,10]\n1  0.11883408 0.0000000 0.05381166\n2  0.07371349 0.0000000 0.03337969\n3  0.08520900 0.0000000 0.03858521\n4  0.06734435 0.0000000 0.03049555\n5  0.07725948 0.0000000 0.03498542\n6  0.07539118 0.0000000 0.00000000\n7  0.10311284 0.0000000 0.00000000\n8  0.00000000 0.0000000 0.03443329\n9  0.04319478 0.0000000 0.01955990\n10 0.06220657 0.1795775 0.00000000"
  },
  {
    "objectID": "autocorrelacion.html#cálculo-de-índice-de-morán-global-y-local",
    "href": "autocorrelacion.html#cálculo-de-índice-de-morán-global-y-local",
    "title": "6  Autocorrelación Espacial",
    "section": "6.5 Cálculo de índice de Morán (global y local)",
    "text": "6.5 Cálculo de índice de Morán (global y local)\n\n6.5.1 Índice de Moran\nPara efectos del presente curso el indicador se utilizará como test para evidenciar la segregación que pueda existir en el territorio, entendiéndose por segregación la agrupación de individuos de características similares en el espacio, resultando en cierta homogeneidad de la población.\nEl índice de Moran en esencia, se trata de un estadístico de producto cruzado entre una variable y su retardo espacial, con la variable expresada en desviaciones de su media.\nI= \\frac{n}{S_0 }\\frac{\\sum_{i=1}^n  \\sum_{j=1}^n W_{ij} Z_iZ_j}{ \\sum_{i=1}^n Z_i^2} \\tag{6.2}\nDonde:\n\nzi = valor de la desviación de la media de la variable de interés, es decir z_i=x_i-\\bar{x}.\nS_o= \\sum_{i=1}^n \\sum_{j=1}^n W_{ij}\nW_{ij} = Matriz de Vecindad\n\nLa inferencia de I de Moran se basa en una hipótesis nula de aleatoriedad espacial. La distribución del estadístico bajo la hipótesis nula puede derivarse utilizando un supuesto de normalidad (variantes aleatorias normales independientes), o la llamada aleatoriedad (es decir, cada valor tiene la misma probabilidad de ocurrir en cualquier lugar).\nPara efectos prácticos de evaluación de la autocorrelación espacial se buscará usar el promedio de educación del jefe de hogar como un indicador del nivel socioeconómico del hogar. El promedio de estos a nivel de manzana, nos indicará a grandes rasgos las características de la población a este nivel desagregado.\nAplicación de Moran Test (global) (Equation 6.2) ::: {.cell}\n## Test de Moran de autocorrelacion global\nspdep::moran.test(x = mz_comuna$nived,  listw = nb)\n\n\n    Moran I test under randomisation\n\ndata:  mz_comuna$nived  \nweights: nb    \n\nMoran I statistic standard deviate = 53.93, p-value < 2.2e-16\nalternative hypothesis: greater\nsample estimates:\nMoran I statistic       Expectation          Variance \n     0.7887762573     -0.0006788866      0.0002142838 \n\n:::\nEl p-value es menor que 0.05 se rechaza la hipótesis nula, por ende podemos descartar un patrón aleatorio en los datos de muestra.\n**Gráfico de Moran*\n\nmoran.plot(x = mz_comuna$nived,  listw = nb, \n           labels=as.character(mz_comuna$id))\n\n\n\n\nEn este gráfico se se divide el espacio en cuadrantes de Valores Altos rodeados de Valores Altos (hotspots), Bajos rodeados de Bajos (Coldspot) y los intermedios.\n\n\n6.5.2 Local Moran\nEl Índice de Moran (global) fue diseñado para rechazar la hipótesis nula de aleatoriedad espacial a favor de una alternativa de agrupación. Dicha agrupación es una característica del patrón espacial completo y no proporciona una indicación de la ubicación de las agrupaciones.\nEl estadístico Moran local fue sugerido por(Anselin 1995) Acomo una forma de identificar los clusters locales y los valores atípicos espaciales locales.\nPara nuestro caso práctico este test permite identificar la significancia de los cluster y poder clasificar las observaciones (manzanas) e identificar denominadas “Hight Hight” y “Low Low” en coherencia de los cuadrantes diagonales del gráfico de Moran antes visualizado.\nCon las ponderaciones estandarizadas por filas, S_0=\\sum_i\\sum_jw_{ij} la suma de todas las ponderaciones es igual al número de observaciones, n. Como resultado, del gráfico de dispersión de Moran, el estadístico I de Moran se simplifica a:\nI=\\frac{\\sum_i\\sum_jw_{ij}Z_iZj}{{\\sum_i z_i^2},}\nEl correspondiente estadístico local de Moran consistiría en el componente de la suma doble que corresponde a cada observación i, o:\nI_i= \\frac{\\sum_{j}w_{ij}Z_iZj}{\\sum_i z_i^2},\nEn esta expresión, el denominador es fijo y, por lo tanto, se puede ignorar. Para simplificar la notación, lo sustituimos por c de modo que la expresión de Moran local se convierte en la expresión:\nI_i= c.Z_i\\sum_jw_{ij}Z_j\nSe podría demostrar (Matemáticamente) que la suma de las estadísticas locales es proporcional a la I de Moran global o, alternativamente, que la I de Moran global se corresponde con la media de las estadísticas locales (para más detalles, (Anselin 1995).\nPara realizar estos cálculos en R haremos uso de la función localmoran\n\n# moran local\nlmoran <-\n  localmoran(mz_comuna$nived,\n             listw = nb) %>%\n  as_tibble() # llevar a tabla para facilitar trabajo\n\nHaciendo uso del test de local Moran podemos identificar los cluster haciendo uso de los resultados significancia estadística:\n\n# resultados\nmzs_cluster <-\n  mz_comuna %>%\n  mutate(\n    z_i = as.numeric(scale(mz_comuna$nived)), # var estandarizada\n    z_j = lag.listw(nb, z_i) # promedio vecinos\n    ) %>%\n  mutate(\n    P = as.numeric(lmoran$`Pr(z != E(Ii))`) # significancia\n  )\n\n\nLas puntuaciones z y los valores p son medidas de significancia estadística que indican si se rechazará la hipótesis nula, entidad por entidad. En efecto, indican si la aparente similitud (un clustering espacial de valores altos o bajos) o la falta de similitud (un valor atípico espacial) es más marcada de lo que se espera en una distribución aleatoria\nUna puntuación z positiva alta para una entidad indica que las entidades circundantes tienen valores similares (ya sea valores altos o bajos). La salida será Alto/alto para un clúster de valores altos estadísticamente significativo y Bajo/bajo para un clúster de valores bajos estadísticamente significativo.\nUna puntuación z negativa baja para una entidad indica un valor atípico de datos espacial estadísticamente significativo. La salida indicará si la entidad tiene un valor alto y está rodeada por entidades con valores bajos (Alto/bajo) o si la entidad tiene un valor bajo y está rodeada por entidades con valores altos (Bajo/alto).\n\n\nmzs_cluster <- mzs_cluster%>%\n  mutate(\n    clusterM = # clasificar cluster\n      case_when(\n        (P <= 0.5) & (z_i >  0) & (z_j >  0) ~ \"HH\",\n        (P <= 0.5) & (z_i <= 0) & (z_j >  0) ~ \"LH\",\n        (P <= 0.5) & (z_i >  0) & (z_j <= 0) ~ \"HL\",\n        (P <= 0.5) & (z_i <= 0) & (z_j <= 0) ~ \"LL\",\n        TRUE ~ \"NS\"\n        )\n  )\n\n# st_write(mzs_cluster, \"data/shape/clusters_LC.shp\")\n\nEl campo clusterM indicará siempre clusters y valores atípicos estadísticamente significativos para un nivel de confianza del 95 por ciento.\n\n# resultados clusters\ntable(mzs_cluster$clusterM)\n\n\n HH  HL  LH  LL  NS \n532  20  59 174 689 \n\n\nVisualización de cluster HH y LL\n\nmzs_cluster_segr <- mzs_cluster %>% filter(clusterM %in% c( \"HH\", \"LL\"))\n\nggplot() +\n  geom_sf(data = mz_comuna, fill =NA,  color =\"gray80\", \n          alpha=1,  size= 0.1)+\n  geom_sf(data = mzs_cluster_segr, aes(fill = clusterM),\n          color =NA, alpha=0.8,  size= 0.1)+\n  scale_fill_manual(values = c(\"#08519c\", \"#e31a1c\"))+\n  ggtitle(\"Segregación en la comuna de Las Condes\") +\n  theme_bw() +\n  theme(plot.title = element_text(size=12))+\n  theme(panel.grid.major = element_line(colour = \"gray80\"), \n        panel.grid.minor = element_line(colour = \"gray80\"))\n\n\n\n# mapview(mzs_cluster_segr, zcol = \"clusterM\")\n\n\nkde_raster <-  raster(\"data/delitos/kde_delvio_LC.tif\")\n\nmapview(kde_raster)+\n    mapview(mzs_cluster_segr, zcol = \"clusterM\", layer.name =  \"clusterM\")"
  },
  {
    "objectID": "autocorrelacion.html#actividades",
    "href": "autocorrelacion.html#actividades",
    "title": "6  Autocorrelación Espacial",
    "section": "6.6 Actividades:",
    "text": "6.6 Actividades:\n\nCalcular local Moran para la variable de Atractor comercial de la Base del SII\nCalcular local Moran cualquier otra variable de la base comunal.\nCalcular local Moran cualquier otra variable en otra comuna."
  },
  {
    "objectID": "autocorrelacion.html#referencias-del-capítulo",
    "href": "autocorrelacion.html#referencias-del-capítulo",
    "title": "6  Autocorrelación Espacial",
    "section": "6.7 Referencias del Capítulo",
    "text": "6.7 Referencias del Capítulo\n\nDistance-Band Spatial Weights - Luc Anselin\nGlobal Spatial Autocorrelation - Luc Anselin\nLocal Spatial Autocorrelation - Luc Anselin\nAnalizaR Datos Políticos- Mapas y datos espaciales\n\n\n\n\n\nAnselin, Luc. 1995. “Local Indicators of Spatial Association—LISA.” Geographical Analysis 27 (2): 93–115. https://doi.org/10.1111/j.1538-4632.1995.tb00338.x.\n\n\nP. Moran, P. a. 1948. “The Interpretation of Statistical Maps.” Journal of the Royal Statistical Society: Series B (Methodological) 10 (2): 243–51. https://doi.org/10.1111/j.2517-6161.1948.tb00012.x."
  },
  {
    "objectID": "tarea_1.html",
    "href": "tarea_1.html",
    "title": "Tarea 1",
    "section": "",
    "text": "Fecha de entrega: 30 de Octubre 2022\nFormato: Informe (pdf, html) + Código\nIntegrantes: 3 o 4"
  },
  {
    "objectID": "tarea_1.html#instrucciones",
    "href": "tarea_1.html#instrucciones",
    "title": "Tarea 1",
    "section": "Instrucciones",
    "text": "Instrucciones\n\nParte 1: Indicadores Socioeconómicos\n\nCalcular los 6 Indicadores Socioenómicos en una Región de su área de estudio (1 pt) Section 3.4\nSeleccione una Provincia y un indicador socioeconómico que consideren que evidencia una nencesidad prioritaria en la provincia. Defina un valor de indicador como umbral crítico (ej: menor a 0.25) y genere una tabla resumen (usar función group_by()) donde se contabilice la cantidad de personas que están bajo el umbral crítico y promedio del indicador por comuna en la provincia seleccionada. (1 pt)\nDe la tabla anterior, seleccione una comuna, ya sea por la mayor cantidad de personas (bajo el umbral) o por valor promedio del indicador más bajo (justifique la selección de comuna). Realicé representación cartográfica del valor del indicador a nivel de manzana censal e identifique visualmente si existen concentraciones de valores de indicadores altos y/o bajos y haga una descripción del sector basándose en su conocimiento en terreno, experiencia general o valores de indicadores. (1 pt)\n\n\n\nParte 2: Indicadores Ambientales\n\nSeleccionar una Comuna de la Región metropolitana (no Las Condes) Section 4.3.3 y calcular NDVI usando la función vista en clases Section 4.4.1 . (1pt)\nCalcular Vegentación que existe en la comuna seleccionada, filtrando y dejando solo los pixeles sobre un valor de umbral que ustedes determinen. Section 4.4.2 (1pt)\nCalcule el indicador de cobertura vegetal para la manzanas urbanas de la comuna seleccionada. Section 4.4.2 (1 pt)"
  },
  {
    "objectID": "luces_nocturnas.html",
    "href": "luces_nocturnas.html",
    "title": "Luces Nocturnas con GEE",
    "section": "",
    "text": "Construir un indicador territorial que represente la luminosidad nocturna, cuya unidad mínima sea manzana urbana y entidad rural, a nivel país que se denominará “Indicador de Iluminosidad Nocturna (ILN)."
  },
  {
    "objectID": "luces_nocturnas.html#metodología",
    "href": "luces_nocturnas.html#metodología",
    "title": "Luces Nocturnas con GEE",
    "section": "Metodología",
    "text": "Metodología\nDe forma general se utilizará como base producto satelital llamado VIIRS Stray Light Corrected Nighttime Day/Night Band Composites Version 1, que entrega valores de radiancia media mensual del infrarojo visible, utilizando la plataflorma de GEE para su adquisisción y procesamiento.\nSe definirá una región de estudio, paral el caso práctico de cálculo es la área urbana de las comunas de Valparaíso y Viña del Mar en la V Región, se le aplicará un buffer de 1000 metros y se cortará imagen tipo raster obtendida del producto satelital antes mecionado.\nFinalmente se procederá extraer el valor de indicador por unidad territorial mínima, manzana urbana y entidad censal, mediante el cáculo del promedio de los valores de pixeles que contiene en su interior, y este valor será el del indicador ILN. Para tener control de flujo de este proceso se rezarará mediante un ciclo interativo por Distrito censal, en caso de caerse la conexión con GEE, se puede continuar en el distrito correcto, sin perder lo avanzado."
  },
  {
    "objectID": "luces_nocturnas.html#producto-satelital",
    "href": "luces_nocturnas.html#producto-satelital",
    "title": "Luces Nocturnas con GEE",
    "section": "Producto Satelital",
    "text": "Producto Satelital\n\nNombre:\n\nVIIRS Stray Light Corrected Nighttime Day/Night Band Composites Version 1\n\nDescripción:\n\nImágenes compuestas de radiancia media mensual utilizando datos nocturnos del Visible Infrared Imaging Radiometer Suite (VIIRS) Day/Night Band (DNB).\nComo estos datos se componen mensualmente, hay muchas zonas del planeta en las que es imposible obtener una cobertura de datos de buena calidad para ese mes. Esto puede deberse a la nubosidad, especialmente en las regiones tropicales, o a la iluminación solar, como ocurre hacia los polos en sus respectivos meses de verano. Por lo tanto, se recomienda que los usuarios de estos datos utilicen la banda ‘cf_cvg’ y no asuman que un valor de cero en la imagen de radiancia media significa que no se observaron luces.\nLa cobertura de nubes se determina utilizando el producto VIIRS Cloud Mask (VCM). Además, los datos cercanos a los bordes de la franja no se incluyen en los compuestos (zonas de agregación 29-32). La versión 1 NO ha sido filtrada para separar las luces de la aurora, los incendios, los barcos y otras luces temporales. Esta separación está en desarrollo y se incluirá en una versión posterior de esta serie temporal. También está en desarrollo un método para separar las luces de los valores de fondo (no luces).\nEste producto es una configuración alternativa del DNB de VIIRS que utiliza un procedimiento para corregir la luz parásita. El procedimiento de corrección extiende las áreas visibles más cerca de los polos y mejora el rango dinámico. Hay que tener en cuenta que se introducen algunos artefactos debido al procedimiento utilizado en las regiones crepusculares; véase el documento de referencia para más detalles. Este producto excluye los datos afectados por la nubosidad.\n\nBandas:\n\nResolution: 463.83 meters\n\n\n\n\nInformación de Producto Satelital\n \n  \n    Name \n    Units \n    Min \n    Max \n    Description \n  \n \n\n  \n    avg_rad \n    nanoWatts/cm2/sr \n    -1.5* \n    193565* \n    Average DNB radiance values. \n  \n  \n    cf_cvg \n    NA \n    0* \n    84* \n    Cloud-free coverages; the total number of observations that went into each pixel. This band can be used to identify areas with low numbers of observations where the quality is reduced. \n  \n\n\n\n\n\n\n\n\nEstimated min or max value"
  },
  {
    "objectID": "luces_nocturnas.html#cálculo",
    "href": "luces_nocturnas.html#cálculo",
    "title": "Luces Nocturnas con GEE",
    "section": "Cálculo",
    "text": "Cálculo\nA continuación se define el flujo de trabajo para calcular el indicador de ILN.\n\nCargar Librerías\n\nlibrary(dplyr)\nlibrary(sf)\nlibrary(mapview)\nlibrary(ggplot2)\nlibrary(viridis)\nlibrary(rgee)\nee_Initialize()\n\n── rgee 1.1.5 ─────────────────────────────────────── earthengine-api 0.1.317 ── \n ✔ user: not_defined\n ✔ Initializing Google Earth Engine:\n ✔ Initializing Google Earth Engine:  DONE!\n\n ✔ Earth Engine account: users/denisberroeta \n──────────────────────────────────────────────────────────────────────────────── \n\n\n\n\nDefinición de Área de Estudio\nPara este ejemplo se definirá como área de estudio las zonas urbanas del gran Valparaíso. Para esto tenemos un archivo tipo llamado Zonas_Censales_2017_Nacional.rds tipo polígonos espaciales, que corresponden a zonas censales (INE) que son urbanas únicamente. Estas geometrías se utilizarán únicamente para definir la región de estudio.\n\nzonas_ine <- readRDS(\"data/censo/zonas_urb_consolidadas.rds\")\n\nA continuación utilizaremos las zonas censales, para definir una región de estudio general, filtrando las comuna de nuestro interés en este caso las comunas de Valparaíso y Viña del Mar.Debemos tener especial cuidado en el Sistema de Referencias de Coordenadas (CRS), ya que necesitamos que en coordenadas geográfica EPSG(4326), si está en algún otro CRS, se puede transformar utilizando la función st_transform(). Posterriormente se ibuja una geometría única que toma solamente el contorno de las zonas censales filtradas utilizando la función st_union. Finalmente a esta geometría única se le aplicarà un buffer (st_buffer()) de 1000 metros, a fin de asegurarnos que no queden partes de polígonos sin curbrir con el raster.\n\nmis_comunas <- c(\"VALPARAÍSO\", \"VIÑA DEL MAR\")\nae <- zonas_ine %>%\n  st_as_sf() %>%\n  filter(NOM_COMUNA %in% mis_comunas) %>%\n  st_transform(4326) %>%\n  st_union() %>%\n  st_buffer(1000)\n\nA continuación se visualiza el área de\n\nmapview(ae)\n\n\n\n\n\nTrannsformar a formato soportado por google earth Engine\n\nae_ee <- ae %>% sf_as_ee()\n\n\n\nLectura de Producto Satelital\n\ndataset <-  ee$ImageCollection('NOAA/VIIRS/DNB/MONTHLY_V1/VCMSLCFG')$\n  filterDate('2020-01-01', '2020-12-01')$\n  select(\"avg_rad\")$\n  median()\n\nimagen <- dataset$clip(ae_ee)\n\n\nvis <- list(min = 0, max = 60,\n            palette = c('0602ff', '235cb1', '307ef3', '269db1', '30c8e2',\n                        '32d3ef', '3ae237','b5e22e', 'd6e21f', 'fff705',\n                        'ffd611', 'ffb613', 'ff8b13', 'ff6e08', 'ff500d',\n                        'ff0000', 'de0101', 'c21301'))\n\n\nregion <- ae_ee$bounds()\n\nVisualización del producto satelital\n\nMap$centerObject(region, zoom = 11)\nMap$addLayer(imagen, vis, name = \"Nighttime\")\n\n\n\n\n\n\n\nCálculo de Indicador\n\nmz_comuna <- readRDS(\"data/censo/manzanas.rds\") %>% \n  filter(NOM_COM %in% mis_comunas) %>%\n  mutate(DISTRITO = substr(COD_ZON, 5, 7)) %>% \n  st_transform(4326)\n# mapview(valpo_mz, zcol = \"PERSONAS\")\n\nEs un proceso costoso computacionalmente, lo que toma un tiempo cercano a 3 minutos, es recomendable iterar por Distrito Censalcon objetivo si se cae la conexión con GEE en medio del cálculo, podriamos recomenzar eventualmente en el distrito censal donde se paro la instrucción.\n\nmz_lum <- NULL\nfor(distrito in unique(mz_comuna$DISTRITO)){\n  print(paste0(\"Procesando DISTRITO censal \", distrito))\n  mz_filtrada <- mz_comuna %>%\n    filter(DISTRITO == distrito)\n  # calculando  la luminosidad\n  mz_luminocidad <- ee_extract(x = imagen, y = mz_filtrada,\n                               sf = T,scale = 500,\n                               fun =ee$Reducer$mean())\n  mz_lum <- rbind(mz_lum, mz_luminocidad)\n}\n\nGuardar los resultados del objeto espacial generado en formato rds\n\nsaveRDS(mz_lum, \"data/shape/luces_noc_gran_valpo.rds\")\n\n\n\n\n\n# mapview::mapview(mz_lum, zcol = \"avg_rad\")\n\n# vislauzación cartografica\nind_LN <- ggplot() + \n  geom_sf(data = mz_lum, aes(fill = avg_rad), color=NA) + \n  scale_fill_viridis()+ theme_bw()+\n  # xlab( \"longitud\") + ylab(\"latitud\")+\n  labs(title = \"ILN: Indicador de Luces Nocturnas\", \n       subtitle = \"Utilizando Google Earth Engine\",\n       fill = \"ILN\")+\n  theme(panel.grid.major = element_line(colour = \"gray94\"), \n      panel.grid.minor = element_line(colour = \"gray94\"), \n      plot.title = element_text(hjust = 0.5, size = rel(0.9)), \n      plot.subtitle = element_text(hjust = 0.5, size = rel(0.7)),\n      legend.title = element_text(size = rel(0.7)),\n      panel.background = element_rect(fill = \"gray100\"),\n      axis.text.x = element_text(color = \"grey20\", size = rel(0.7)),\n      axis.text.y = element_text(color = \"grey20\", size = rel(0.7))) \nind_LN"
  },
  {
    "objectID": "references.html",
    "href": "references.html",
    "title": "References",
    "section": "",
    "text": "Anselin, Luc. 1995. “Local Indicators of\nSpatial Association—LISA.”\nGeographical Analysis 27 (2): 93–115. https://doi.org/10.1111/j.1538-4632.1995.tb00338.x.\n\n\nP. Moran, P. a. 1948. “The Interpretation of\nStatistical Maps.” Journal of the Royal\nStatistical Society: Series B (Methodological) 10 (2): 243–51. https://doi.org/10.1111/j.2517-6161.1948.tb00012.x."
  }
]